/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

enum __anonenum_xbool_1 {
    FALSE = 0,
    TRUE = 1
} ;
typedef enum __anonenum_xbool_1 xbool;
struct __anonstruct_move_s_13 {
   int from ;
   int target ;
   int captured ;
   int promoted ;
   int castled ;
   int ep ;
};
typedef struct __anonstruct_move_s_13 move_s;
typedef unsigned long __darwin_size_t;
typedef __darwin_size_t size_t;
struct __anonstruct_ECacheType_15 {
   unsigned int stored_hash ;
   unsigned int hold_hash ;
   int score ;
};
typedef struct __anonstruct_ECacheType_15 ECacheType;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef int __darwin_ct_rune_t;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
typedef long __darwin_time_t;
typedef __int64_t __darwin_off_t;
struct __anonstruct__RuneEntry_3 {
   __darwin_rune_t __min ;
   __darwin_rune_t __max ;
   __darwin_rune_t __map ;
   __uint32_t *__types ;
};
typedef struct __anonstruct__RuneEntry_3 _RuneEntry;
struct __anonstruct__RuneRange_4 {
   int __nranges ;
   _RuneEntry *__ranges ;
};
typedef struct __anonstruct__RuneRange_4 _RuneRange;
struct __anonstruct__RuneCharClass_5 {
   char __name[14] ;
   __uint32_t __mask ;
};
typedef struct __anonstruct__RuneCharClass_5 _RuneCharClass;
struct __anonstruct__RuneLocale_6 {
   char __magic[8] ;
   char __encoding[32] ;
   __darwin_rune_t (*__sgetrune)(char const   * , __darwin_size_t  , char const   ** ) ;
   int (*__sputrune)(__darwin_rune_t  , char * , __darwin_size_t  , char ** ) ;
   __darwin_rune_t __invalid_rune ;
   __uint32_t __runetype[1 << 8] ;
   __darwin_rune_t __maplower[1 << 8] ;
   __darwin_rune_t __mapupper[1 << 8] ;
   _RuneRange __runetype_ext ;
   _RuneRange __maplower_ext ;
   _RuneRange __mapupper_ext ;
   void *__variable ;
   int __variable_len ;
   int __ncharclasses ;
   _RuneCharClass *__charclasses ;
};
typedef struct __anonstruct__RuneLocale_6 _RuneLocale;
typedef __darwin_off_t fpos_t;
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
struct __sFILEX;
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   void *_cookie ;
   int (*_close)(void * ) ;
   int (*_read)(void * , char * , int  ) ;
   fpos_t (*_seek)(void * , fpos_t  , int  ) ;
   int (*_write)(void * , char const   * , int  ) ;
   struct __sbuf _ub ;
   struct __sFILEX *_extra ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   fpos_t _offset ;
};
typedef struct __sFILE FILE;
typedef __darwin_time_t time_t;
typedef time_t rtime_t;
struct __anonstruct_move_x_14 {
   int cap_num ;
   int was_promoted ;
   int epsq ;
   int fifty ;
};
typedef struct __anonstruct_move_x_14 move_x;
typedef int (*EVALFUNC)(int sq , int c );
struct node {
   unsigned char value ;
   unsigned char num_children ;
   unsigned char expanded ;
   unsigned char evaluated ;
   int proof ;
   int disproof ;
   struct node **children ;
   struct node *parent ;
   move_s move ;
};
typedef struct node node_t;
struct __anonstruct_see_data_15 {
   int piece ;
   int square ;
};
typedef struct __anonstruct_see_data_15 see_data;
struct __anonstruct_TType_15 {
   char Depth ;
   char OnMove ;
   char Threat ;
   char Type ;
   unsigned short Bestmove ;
   unsigned int HashKey ;
   unsigned int Hold_hash ;
   int Bound ;
};
typedef struct __anonstruct_TType_15 TType;
struct __anonstruct_QTType_16 {
   char OnMove ;
   char Type ;
   unsigned short Bestmove ;
   unsigned int HashKey ;
   unsigned int Hold_hash ;
   int Bound ;
};
typedef struct __anonstruct_QTType_16 QTType;
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-enTMRKzR.i","-O3")
xbool is_attacked(int square , int color ) ;
xbool nk_attacked(int square , int color ) ;
int calc_attackers(int square , int color ) ;
int board[144] ;
static int const   rook_o[4]  = {      (int const   )12,      (int const   )-12,      (int const   )1,      (int const   )-1};
static int const   bishop_o[4]  = {      (int const   )11,      (int const   )-11,      (int const   )13,      (int const   )-13};
static int const   knight_o[8]  = 
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
int calc_attackers(int square , int color ) 
{ 
  int a_sq ;
  int i ;
  int attackers ;

  {
  attackers = 0;
  if (board[square] == 0) {
    return (0);
  }
  if (color % 2) {
    i = 0;
    while (i < 4) {
      a_sq = square + (int )rook_o[i];
      if (board[a_sq] == 5) {
        attackers ++;
        break;
      } else {
        while (board[a_sq] != 0) {
          if (board[a_sq] == 7) {
            attackers ++;
            break;
          } else
          if (board[a_sq] == 9) {
            attackers ++;
            break;
          } else
          if (board[a_sq] != 13) {
            break;
          }
          a_sq += (int )rook_o[i];
        }
      }
      i ++;
    }
    i = 0;
    while (i < 4) {
      a_sq = square + (int )bishop_o[i];
      if (board[a_sq] == 1) {
        if (i % 2) {
          attackers ++;
          break;
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (board[a_sq] == 5) {
        attackers ++;
        break;
      } else {
        while (board[a_sq] != 0) {
          if (board[a_sq] == 11) {
            attackers ++;
            break;
          } else
          if (board[a_sq] == 9) {
            attackers ++;
            break;
          } else
          if (board[a_sq] != 13) {
            break;
          }
          a_sq += (int )bishop_o[i];
        }
      }
      i ++;
    }
    i = 0;
    while (i < 8) {
      a_sq = square + (int )knight_o[i];
      if (board[a_sq] == 3) {
        attackers ++;
      }
      i ++;
    }
  } else {
    i = 0;
    while (i < 4) {
      a_sq = square + (int )rook_o[i];
      if (board[a_sq] == 6) {
        attackers ++;
        break;
      } else {
        while (board[a_sq] != 0) {
          if (board[a_sq] == 8) {
            attackers ++;
            break;
          } else
          if (board[a_sq] == 10) {
            attackers ++;
            break;
          }
          if (board[a_sq] != 13) {
            break;
          }
          a_sq += (int )rook_o[i];
        }
      }
      i ++;
    }
    i = 0;
    while (i < 4) {
      a_sq = square + (int )bishop_o[i];
      if (board[a_sq] == 2) {
        if (! (i % 2)) {
          attackers ++;
          break;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (board[a_sq] == 6) {
        attackers ++;
        break;
      } else {
        while (board[a_sq] != 0) {
          if (board[a_sq] == 12) {
            attackers ++;
            break;
          } else
          if (board[a_sq] == 10) {
            attackers ++;
            break;
          } else
          if (board[a_sq] != 13) {
            break;
          }
          a_sq += (int )bishop_o[i];
        }
      }
      i ++;
    }
    i = 0;
    while (i < 8) {
      a_sq = square + (int )knight_o[i];
      if (board[a_sq] == 4) {
        attackers ++;
      }
      i ++;
    }
  }
  return (attackers);
}
}
static int const   rook_o___0[4]  = {      (int const   )12,      (int const   )-12,      (int const   )1,      (int const   )-1};
static int const   bishop_o___0[4]  = {      (int const   )11,      (int const   )-11,      (int const   )13,      (int const   )-13};
static int const   knight_o___0[8]  = 
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
xbool is_attacked(int square , int color ) 
{ 
  register int ndir ;
  register int a_sq ;
  register int basq ;
  register int i ;

  {
  if (color & 1) {
    i = 0;
    while (i < 4) {
      ndir = (int )bishop_o___0[i];
      a_sq = square + ndir;
      basq = board[a_sq];
      if (basq == 1) {
        if (i & 1) {
          return ((xbool )1);
        }
      }
      if (basq == 5) {
        return ((xbool )1);
      }
      while (basq != 0) {
        if (basq == 11) {
          return ((xbool )1);
        } else
        if (basq == 9) {
          return ((xbool )1);
        }
        if (basq != 13) {
          break;
        }
        a_sq += ndir;
        basq = board[a_sq];
      }
      i ++;
    }
    i = 0;
    while (i < 8) {
      if (board[square + (int )knight_o___0[i]] == 3) {
        return ((xbool )1);
      }
      i ++;
    }
    i = 0;
    while (i < 4) {
      ndir = (int )rook_o___0[i];
      a_sq = square + ndir;
      basq = board[a_sq];
      if (basq == 5) {
        return ((xbool )1);
      }
      while (basq != 0) {
        if (basq == 7) {
          return ((xbool )1);
        } else
        if (basq == 9) {
          return ((xbool )1);
        }
        if (basq != 13) {
          break;
        }
        a_sq += ndir;
        basq = board[a_sq];
      }
      i ++;
    }
    return ((xbool )0);
  } else {
    i = 0;
    while (i < 4) {
      ndir = (int )bishop_o___0[i];
      a_sq = square + ndir;
      basq = board[a_sq];
      if (basq == 2) {
        if (! (i & 1)) {
          return ((xbool )1);
        }
      }
      if (basq == 6) {
        return ((xbool )1);
      }
      while (basq != 0) {
        if (basq == 12) {
          return ((xbool )1);
        } else
        if (basq == 10) {
          return ((xbool )1);
        }
        if (basq != 13) {
          break;
        }
        a_sq += ndir;
        basq = board[a_sq];
      }
      i ++;
    }
    i = 0;
    while (i < 8) {
      if (board[square + (int )knight_o___0[i]] == 4) {
        return ((xbool )1);
      }
      i ++;
    }
    i = 0;
    while (i < 4) {
      ndir = (int )rook_o___0[i];
      a_sq = square + (int )rook_o___0[i];
      basq = board[a_sq];
      if (basq == 6) {
        return ((xbool )1);
      }
      while (basq != 0) {
        if (basq == 8) {
          return ((xbool )1);
        } else
        if (basq == 10) {
          return ((xbool )1);
        }
        if (basq != 13) {
          break;
        }
        a_sq += ndir;
        basq = board[a_sq];
      }
      i ++;
    }
    return ((xbool )0);
  }
}
}
static int const   rook_o___1[4]  = {      (int const   )12,      (int const   )-12,      (int const   )1,      (int const   )-1};
static int const   bishop_o___1[4]  = {      (int const   )11,      (int const   )-11,      (int const   )13,      (int const   )-13};
static int const   knight_o___1[8]  = 
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
xbool nk_attacked(int square , int color ) 
{ 
  register int ndir ;
  register int a_sq ;
  register int basq ;
  register int i ;

  {
  if (color & 1) {
    i = 0;
    while (i < 4) {
      ndir = (int )bishop_o___1[i];
      a_sq = square + ndir;
      basq = board[a_sq];
      if (basq == 1) {
        if (i & 1) {
          return ((xbool )1);
        }
      }
      while (basq != 0) {
        if (basq == 11) {
          return ((xbool )1);
        } else
        if (basq == 9) {
          return ((xbool )1);
        }
        if (basq != 13) {
          break;
        }
        a_sq += ndir;
        basq = board[a_sq];
      }
      i ++;
    }
    i = 0;
    while (i < 8) {
      if (board[square + (int )knight_o___1[i]] == 3) {
        return ((xbool )1);
      }
      i ++;
    }
    i = 0;
    while (i < 4) {
      ndir = (int )rook_o___1[i];
      a_sq = square + ndir;
      basq = board[a_sq];
      while (basq != 0) {
        if (basq == 7) {
          return ((xbool )1);
        } else
        if (basq == 9) {
          return ((xbool )1);
        }
        if (basq != 13) {
          break;
        }
        a_sq += ndir;
        basq = board[a_sq];
      }
      i ++;
    }
    return ((xbool )0);
  } else {
    i = 0;
    while (i < 4) {
      ndir = (int )bishop_o___1[i];
      a_sq = square + ndir;
      basq = board[a_sq];
      if (basq == 2) {
        if (! (i & 1)) {
          return ((xbool )1);
        }
      }
      while (basq != 0) {
        if (basq == 12) {
          return ((xbool )1);
        } else
        if (basq == 10) {
          return ((xbool )1);
        }
        if (basq != 13) {
          break;
        }
        a_sq += ndir;
        basq = board[a_sq];
      }
      i ++;
    }
    i = 0;
    while (i < 8) {
      if (board[square + (int )knight_o___1[i]] == 4) {
        return ((xbool )1);
      }
      i ++;
    }
    i = 0;
    while (i < 4) {
      ndir = (int )rook_o___1[i];
      a_sq = square + (int )rook_o___1[i];
      basq = board[a_sq];
      while (basq != 0) {
        if (basq == 8) {
          return ((xbool )1);
        } else
        if (basq == 10) {
          return ((xbool )1);
        }
        if (basq != 13) {
          break;
        }
        a_sq += ndir;
        basq = board[a_sq];
      }
      i ++;
    }
    return ((xbool )0);
  }
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-g7muRCkJ.i","-O3")
move_s dummy ;
int init_book(void) 
{ 


  {
  return (1);
}
}
move_s choose_book_move(void) 
{ 


  {
  return (dummy);
}
}
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-loflmlTN.i","-O3")
extern int ( /* format attribute */  printf)(char const   *  , ...) ;
__inline static void *__inline_memset_chk(void *__dest , int __val , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memset_chk(__dest, __val, __len, tmp);
  return (tmp___0);
}
}
__inline static char *__inline_strncpy_chk(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strncpy_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
void ProcessHoldings(char *str ) ;
void addHolding(int what , int who ) ;
void removeHolding(int what , int who ) ;
void DropaddHolding(int what , int who ) ;
void DropremoveHolding(int what , int who ) ;
void printHolding(void) ;
int SwitchColor(int piece ) ;
int SwitchPromoted(int piece ) ;
void reset_ecache(void) ;
int comp_color ;
int holding[2][16]  ;
int num_holding[2]  ;
int white_hand_eval  ;
int black_hand_eval  ;
int hand_value[13] ;
int drop_piece  ;
unsigned int zobrist[14][144] ;
unsigned int hold_hash  ;
int Material ;
int material[14] ;
int Variant ;
int userealholdings  ;
char realholdings[255]  ;
void ProcessHoldings(char *str ) 
{ 
  int c ;
  int i ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned long tmp___18 ;
  unsigned long tmp___19 ;

  {
  i = 0;
  tmp___0 = __builtin_object_size((void *)(holding), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(holding), 0);
    __builtin___memset_chk((void *)(holding), 0, sizeof(holding), tmp);
  } else {
    __inline_memset_chk((void *)(holding), 0, sizeof(holding));
  }
  hold_hash = 3237998080U;
  white_hand_eval = 0;
  black_hand_eval = 0;
  reset_ecache();
  num_holding[0] = 0;
  num_holding[1] = 0;
  c = 0;
  while (c <= 1) {
    while (1) {
      tmp___1 = i;
      i ++;
      if (! ((int )*(str + tmp___1) != 91)) {
        break;
      }
      if ((int )*(str + i) == 0) {
        return;
      }
    }
    while ((int )*(str + i) != 93) {
      tmp___2 = i;
      i ++;
      switch ((int )*(str + tmp___2)) {
      case 80: 
      case 112: 
      if (c == 0) {
        tmp___3 = 1;
      } else {
        tmp___3 = 2;
      }
      (holding[c][tmp___3]) ++;
      (num_holding[c]) ++;
      if (c == 0) {
        tmp___4 = 1;
      } else {
        tmp___4 = 2;
      }
      if (c == 0) {
        tmp___5 = 1;
      } else {
        tmp___5 = 2;
      }
      hold_hash ^= zobrist[tmp___4][holding[c][tmp___5]];
      break;
      case 81: 
      case 113: 
      if (c == 0) {
        tmp___6 = 9;
      } else {
        tmp___6 = 10;
      }
      (holding[c][tmp___6]) ++;
      (num_holding[c]) ++;
      if (c == 0) {
        tmp___7 = 9;
      } else {
        tmp___7 = 10;
      }
      if (c == 0) {
        tmp___8 = 9;
      } else {
        tmp___8 = 10;
      }
      hold_hash ^= zobrist[tmp___7][holding[c][tmp___8]];
      break;
      case 82: 
      case 114: 
      if (c == 0) {
        tmp___9 = 7;
      } else {
        tmp___9 = 8;
      }
      (holding[c][tmp___9]) ++;
      (num_holding[c]) ++;
      if (c == 0) {
        tmp___10 = 7;
      } else {
        tmp___10 = 8;
      }
      if (c == 0) {
        tmp___11 = 7;
      } else {
        tmp___11 = 8;
      }
      hold_hash ^= zobrist[tmp___10][holding[c][tmp___11]];
      break;
      case 66: 
      case 98: 
      if (c == 0) {
        tmp___12 = 11;
      } else {
        tmp___12 = 12;
      }
      (holding[c][tmp___12]) ++;
      (num_holding[c]) ++;
      if (c == 0) {
        tmp___13 = 11;
      } else {
        tmp___13 = 12;
      }
      if (c == 0) {
        tmp___14 = 11;
      } else {
        tmp___14 = 12;
      }
      hold_hash ^= zobrist[tmp___13][holding[c][tmp___14]];
      break;
      case 78: 
      case 110: 
      if (c == 0) {
        tmp___15 = 3;
      } else {
        tmp___15 = 4;
      }
      (holding[c][tmp___15]) ++;
      (num_holding[c]) ++;
      if (c == 0) {
        tmp___16 = 3;
      } else {
        tmp___16 = 4;
      }
      if (c == 0) {
        tmp___17 = 3;
      } else {
        tmp___17 = 4;
      }
      hold_hash ^= zobrist[tmp___16][holding[c][tmp___17]];
      break;
      default: 
      return;
      }
    }
    c ++;
  }
  if (Variant == 1) {
    if (! userealholdings) {
      tmp___19 = __builtin_object_size((void *)(realholdings), 0);
      if (tmp___19 != 0xffffffffffffffffUL) {
        tmp___18 = __builtin_object_size((void *)(realholdings), 1);
        __builtin___strncpy_chk(realholdings, (char const   *)str, 200UL, tmp___18);
      } else {
        __inline_strncpy_chk(realholdings, (char const   *)str, (size_t )200);
      }
      if (comp_color == 1) {
        if (holding[1][2] == 0) {
          (holding[1][2]) ++;
          (num_holding[1]) ++;
          hold_hash ^= zobrist[2][holding[1][2]];
        }
        if (holding[1][12] == 0) {
          (holding[1][12]) ++;
          (num_holding[1]) ++;
          hold_hash ^= zobrist[2][holding[1][12]];
        }
        if (holding[1][4] == 0) {
          (holding[1][4]) ++;
          (num_holding[1]) ++;
          hold_hash ^= zobrist[4][holding[1][4]];
        }
        if (holding[1][8] == 0) {
          (holding[1][8]) ++;
          (num_holding[1]) ++;
          hold_hash ^= zobrist[4][holding[1][8]];
        }
        if (holding[1][10] == 0) {
          (holding[1][10]) ++;
          (num_holding[1]) ++;
          hold_hash ^= zobrist[4][holding[1][10]];
        }
      } else {
        if (holding[0][9] == 0) {
          (holding[0][9]) ++;
          (num_holding[0]) ++;
          hold_hash ^= zobrist[9][holding[0][9]];
        }
        if (holding[0][7] == 0) {
          (holding[0][7]) ++;
          (num_holding[0]) ++;
          hold_hash ^= zobrist[9][holding[0][7]];
        }
        if (holding[0][11] == 0) {
          (holding[0][11]) ++;
          (num_holding[0]) ++;
          hold_hash ^= zobrist[9][holding[0][11]];
        }
        if (holding[0][3] == 0) {
          (holding[0][3]) ++;
          (num_holding[0]) ++;
          hold_hash ^= zobrist[9][holding[0][3]];
        }
        if (holding[0][1] == 0) {
          (holding[0][1]) ++;
          (num_holding[0]) ++;
          hold_hash ^= zobrist[9][holding[0][1]];
        }
      }
    }
  }
  return;
}
}
int text_to_piece(char txt , int who ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  switch ((int )txt) {
  case 80: 
  case 112: 
  if (who == 0) {
    tmp = 1;
  } else {
    tmp = 2;
  }
  return (tmp);
  case 66: 
  case 98: 
  if (who == 0) {
    tmp___0 = 11;
  } else {
    tmp___0 = 12;
  }
  return (tmp___0);
  case 78: 
  case 110: 
  if (who == 0) {
    tmp___1 = 3;
  } else {
    tmp___1 = 4;
  }
  return (tmp___1);
  case 82: 
  case 114: 
  if (who == 0) {
    tmp___2 = 7;
  } else {
    tmp___2 = 8;
  }
  return (tmp___2);
  case 81: 
  case 113: 
  if (who == 0) {
    tmp___3 = 9;
  } else {
    tmp___3 = 10;
  }
  return (tmp___3);
  }
  return (13);
}
}
int SwitchColor(int piece ) 
{ 
  int t[13] ;

  {
  t[0] = 0;
  t[1] = 2;
  t[2] = 1;
  t[3] = 4;
  t[4] = 3;
  t[5] = 0;
  t[6] = 0;
  t[7] = 8;
  t[8] = 7;
  t[9] = 10;
  t[10] = 9;
  t[11] = 12;
  t[12] = 11;
  return (t[piece]);
}
}
int SwitchPromoted(int piece ) 
{ 
  int t[13] ;

  {
  t[0] = 0;
  t[1] = 2;
  t[2] = 1;
  t[3] = 2;
  t[4] = 1;
  t[5] = 0;
  t[6] = 0;
  t[7] = 2;
  t[8] = 1;
  t[9] = 2;
  t[10] = 1;
  t[11] = 2;
  t[12] = 1;
  return (t[piece]);
}
}
void addHolding(int what , int who ) 
{ 


  {
  if (Variant == 0) {
    (holding[who][what]) ++;
    (num_holding[who]) ++;
    hold_hash ^= zobrist[what][holding[who][what]];
  }
  if (who == 0) {
    white_hand_eval += hand_value[what];
  } else {
    black_hand_eval += hand_value[what];
  }
  Material += material[what];
  return;
}
}
void removeHolding(int what , int who ) 
{ 


  {
  if (Variant == 0) {
    hold_hash ^= zobrist[what][holding[who][what]];
    (holding[who][what]) --;
    (num_holding[who]) --;
  }
  if (who == 0) {
    white_hand_eval -= hand_value[what];
  } else {
    black_hand_eval -= hand_value[what];
  }
  Material -= material[what];
  return;
}
}
void DropaddHolding(int what , int who ) 
{ 


  {
  (holding[who][what]) ++;
  (num_holding[who]) ++;
  hold_hash ^= zobrist[what][holding[who][what]];
  if (who == 0) {
    white_hand_eval += hand_value[what];
  } else {
    black_hand_eval += hand_value[what];
  }
  Material += material[what];
  return;
}
}
void DropremoveHolding(int what , int who ) 
{ 


  {
  hold_hash ^= zobrist[what][holding[who][what]];
  (holding[who][what]) --;
  (num_holding[who]) --;
  if (who == 0) {
    white_hand_eval -= hand_value[what];
  } else {
    black_hand_eval -= hand_value[what];
  }
  Material -= material[what];
  return;
}
}
void printHolding(void) 
{ 


  {
  printf("WP: %d WR: %d WB: %d WN: %d WQ: %d\n", holding[0][1], holding[0][7], holding[0][11],
         holding[0][3], holding[0][9]);
  printf("BP: %d BR: %d BB: %d BN: %d BQ: %d\n", holding[1][2], holding[1][8], holding[1][12],
         holding[1][4], holding[1][10]);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-SgEIGZcS.i","-O3")
int ply ;
int fifty ;
unsigned int hash ;
int move_number ;
unsigned int hash_history[600] ;
xbool is_draw(void) ;
xbool is_draw(void) 
{ 
  int i ;
  int repeats ;
  int end ;
  int start ;

  {
  repeats = 0;
  if (fifty >= 4) {
    if (move_number < ((move_number + ply) - 1) - fifty) {
      end = ((move_number + ply) - 1) - fifty;
    } else {
      end = move_number;
    }
    i = (move_number + ply) - 3;
    while (1) {
      if (i >= 0) {
        if (! (i >= end)) {
          break;
        }
      } else {
        break;
      }
      if (hash == hash_history[i]) {
        return ((xbool )1);
      }
      i -= 2;
    }
  }
  if (fifty >= 6) {
    start = (move_number - 1) - ply % 2;
    end = ((move_number + ply) - 1) - fifty;
    i = start;
    while (1) {
      if (i >= 0) {
        if (! (i >= end)) {
          break;
        }
      } else {
        break;
      }
      if (hash == hash_history[i]) {
        repeats ++;
      }
      if (repeats >= 2) {
        return ((xbool )1);
      }
      i -= 2;
    }
  }
  return ((xbool )0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-ao122SYj.i","-O3")
extern  __attribute__((__noreturn__)) void exit(int  ) ;
extern void free(void * ) ;
extern void *malloc(size_t  ) ;
void checkECache(int *score , int *in_cache ) ;
void storeECache(int score ) ;
void alloc_ecache(void) ;
void free_ecache(void) ;
unsigned int ECacheProbes  ;
unsigned int ECacheHits  ;
int ECacheSize ;
ECacheType *ECache  ;
void storeECache(int score ) 
{ 
  int ecindex ;

  {
  ecindex = (int )(hash % (unsigned int )ECacheSize);
  (ECache + ecindex)->stored_hash = hash;
  (ECache + ecindex)->hold_hash = hold_hash;
  (ECache + ecindex)->score = score;
  return;
}
}
void checkECache(int *score , int *in_cache ) 
{ 
  int ecindex ;

  {
  ECacheProbes ++;
  ecindex = (int )(hash % (unsigned int )ECacheSize);
  if ((ECache + ecindex)->stored_hash == hash) {
    if ((ECache + ecindex)->hold_hash == hold_hash) {
      ECacheHits ++;
      *in_cache = 1;
      *score = (ECache + ecindex)->score;
    }
  }
  return;
}
}
void reset_ecache(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size((void *)ECache, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)ECache, 0);
    __builtin___memset_chk((void *)ECache, 0, sizeof(ECacheType ) * (unsigned long )ECacheSize,
                           tmp);
  } else {
    __inline_memset_chk((void *)ECache, 0, sizeof(ECacheType ) * (unsigned long )ECacheSize);
  }
  return;
}
}
void alloc_ecache(void) 
{ 
  void *tmp ;

  {
  tmp = malloc(sizeof(ECacheType ) * (unsigned long )ECacheSize);
  ECache = (ECacheType *)tmp;
  if ((unsigned long )ECache == (unsigned long )((void *)0)) {
    printf("Out of memory allocating ECache.\n");
    exit(1);
  }
  return;
}
}
void free_ecache(void) 
{ 


  {
  free((void *)ECache);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-0U3fSY3j.i","-O3")
extern _RuneLocale _DefaultRuneLocale ;
__inline static int isascii(int _c ) 
{ 


  {
  return ((_c & -128) == 0);
}
}
extern int __maskrune(__darwin_ct_rune_t  , unsigned long  ) ;
__inline static int __istype(__darwin_ct_rune_t _c , unsigned long _f ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___3 = isascii(_c);
  if (tmp___3) {
    tmp___2 = ! (! ((unsigned long )_DefaultRuneLocale.__runetype[_c] & _f));
  } else {
    tmp___0 = __maskrune(_c, _f);
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    tmp___2 = tmp___1;
  }
  return (tmp___2);
}
}
__inline static __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c , unsigned long _f ) 
{ 
  int tmp ;

  {
  if (_c < 0) {
    tmp = 0;
  } else
  if (_c >= 1 << 8) {
    tmp = 0;
  } else {
    tmp = ! (! ((unsigned long )_DefaultRuneLocale.__runetype[_c] & _f));
  }
  return (tmp);
}
}
__inline static int isalpha(int _c ) 
{ 
  int tmp ;

  {
  tmp = __istype(_c, 256UL);
  return (tmp);
}
}
__inline static int isdigit(int _c ) 
{ 
  __darwin_ct_rune_t tmp ;

  {
  tmp = __isctype(_c, 1024UL);
  return (tmp);
}
}
extern int atoi(char const   * ) ;
extern long atol(char const   * ) ;
extern FILE *__stdinp ;
extern FILE *__stdoutp ;
extern int fclose(FILE * ) ;
extern char *fgets(char * , int  , FILE * ) ;
extern FILE *fopen(char const   * , char const   * )  __asm__("_fopen")  ;
extern char *strstr(char const   * , char const   * ) ;
void display_board(FILE *stream , int color ) ;
int eval(int alpha , int beta ) ;
void reset_piece_square(void) ;
void rinput(char *str , int n , FILE *stream ) ;
rtime_t rtime(void) ;
move_s think(void) ;
void initialize_hash(void) ;
int interrupt(void) ;
void run_epd_testsuite(void) ;
void run_autotest(char *testset ) ;
void comp_to_san(move_s move , char *str ) ;
void clear_tt(void) ;
void setup_epd_line(char *inbuff ) ;
int moved[144] ;
int ep_square ;
int white_to_move ;
int wking_loc ;
int bking_loc ;
int white_castled ;
int black_castled ;
int nodes ;
int qnodes ;
int maxdepth ;
int maxposdiff ;
unsigned int TTProbes ;
unsigned int TTHits ;
unsigned int TTStores ;
int book_ply ;
unsigned int NTries ;
unsigned int NCuts ;
unsigned int TExt ;
unsigned int FH ;
unsigned int FHF ;
unsigned int ext_check ;
unsigned int razor_drop ;
unsigned int razor_material ;
int forcedwin ;
int fixed_time ;
int root_to_move ;
static int rankoffsets[8]  = 
  {      110,      98,      86,      74, 
        62,      50,      38,      26};
void setup_epd_line(char *inbuff ) 
{ 
  int i ;
  int rankp ;
  int rankoffset ;
  int fileoffset ;
  int j ;
  int stage ;
  int converterf ;
  int converterr ;
  int ep_file ;
  int ep_rank ;
  int norm_file ;
  int norm_rank ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  i = 0;
  rankp = 0;
  rankoffset = 0;
  fileoffset = 0;
  stage = 0;
  converterf = 'a';
  converterr = '1';
  tmp___0 = __builtin_object_size((void *)(board), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(board), 0);
    __builtin___memset_chk((void *)(board), 0, sizeof(board), tmp);
  } else {
    __inline_memset_chk((void *)(board), 0, sizeof(board));
  }
  white_castled = 0;
  black_castled = 0;
  book_ply = 50;
  rankoffset = rankoffsets[0];
  while ((int )*(inbuff + i) == 32) {
    i ++;
  }
  while (1) {
    if ((int )*(inbuff + i) != 10) {
      if (! ((int )*(inbuff + i) != 0)) {
        break;
      }
    } else {
      break;
    }
    if (stage == 0) {
      tmp___6 = isdigit((int )*(inbuff + i));
      if (tmp___6) {
        j = 0;
        while (1) {
          tmp___1 = atoi((char const   *)(inbuff + i));
          if (! (j < tmp___1)) {
            break;
          }
          board[(rankoffset + j) + fileoffset] = 13;
          j ++;
        }
        tmp___2 = atoi((char const   *)(inbuff + i));
        fileoffset += tmp___2;
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (stage == 0) {
      if ((int )*(inbuff + i) == 47) {
        rankp ++;
        rankoffset = rankoffsets[rankp];
        fileoffset = 0;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (stage == 0) {
      tmp___5 = isalpha((int )*(inbuff + i));
      if (tmp___5) {
        switch ((int )*(inbuff + i)) {
        case 112: 
        board[rankoffset + fileoffset] = 2;
        break;
        case 80: 
        board[rankoffset + fileoffset] = 1;
        break;
        case 110: 
        board[rankoffset + fileoffset] = 4;
        break;
        case 78: 
        board[rankoffset + fileoffset] = 3;
        break;
        case 98: 
        board[rankoffset + fileoffset] = 12;
        break;
        case 66: 
        board[rankoffset + fileoffset] = 11;
        break;
        case 114: 
        board[rankoffset + fileoffset] = 8;
        break;
        case 82: 
        board[rankoffset + fileoffset] = 7;
        break;
        case 113: 
        board[rankoffset + fileoffset] = 10;
        break;
        case 81: 
        board[rankoffset + fileoffset] = 9;
        break;
        case 107: 
        bking_loc = rankoffset + fileoffset;
        board[bking_loc] = 6;
        break;
        case 75: 
        wking_loc = rankoffset + fileoffset;
        board[wking_loc] = 5;
        break;
        }
        fileoffset ++;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((int )*(inbuff + i) == 32) {
      stage ++;
      if (stage == 1) {
        while ((int )*(inbuff + i) == 32) {
          i ++;
        }
        if ((int )*(inbuff + i) == 119) {
          white_to_move = 1;
        } else {
          white_to_move = 0;
        }
      } else
      if (stage == 2) {
        moved[30] = 1;
        moved[33] = moved[30];
        moved[26] = moved[33];
        moved[117] = 1;
        moved[114] = moved[117];
        moved[110] = moved[114];
        while ((int )*(inbuff + i) == 32) {
          i ++;
        }
        while ((int )*(inbuff + i) != 32) {
          switch ((int )*(inbuff + i)) {
          case 45: 
          break;
          case 75: 
          moved[33] = 0;
          moved[30] = moved[33];
          break;
          case 81: 
          moved[26] = 0;
          moved[30] = moved[26];
          break;
          case 107: 
          moved[117] = 0;
          moved[114] = moved[117];
          break;
          case 113: 
          moved[110] = 0;
          moved[114] = moved[110];
          break;
          }
          i ++;
        }
        i --;
      } else
      if (stage == 3) {
        while ((int )*(inbuff + i) == 32) {
          i ++;
        }
        if ((int )*(inbuff + i) == 45) {
          ep_square = 0;
        } else {
          tmp___3 = i;
          i ++;
          ep_file = (int )*(inbuff + tmp___3);
          tmp___4 = i;
          i ++;
          ep_rank = (int )*(inbuff + tmp___4);
          norm_file = ep_file - converterf;
          norm_rank = ep_rank - converterr;
          ep_square = (norm_rank * 12 + 26) + norm_file;
        }
      }
    }
    i ++;
  }
  reset_piece_square();
  initialize_hash();
  return;
}
}
int check_solution(char *inbuff , move_s cmove ) 
{ 
  char san[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  comp_to_san(cmove, san);
  tmp___2 = strstr((char const   *)inbuff, "bm");
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    tmp = strstr((char const   *)inbuff, (char const   *)(san));
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      return (1);
    } else {
      return (0);
    }
  } else {
    tmp___1 = strstr((char const   *)inbuff, "am");
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      tmp___0 = strstr((char const   *)inbuff, (char const   *)(san));
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        return (0);
      } else {
        return (1);
      }
    } else {
      printf("No best-move or avoid-move found!");
    }
  }
  return (0);
}
}
void run_epd_testsuite(void) 
{ 
  FILE *testsuite ;
  char readbuff[2000] ;
  char testname[1024] ;
  char tempbuff[2000] ;
  int thinktime ;
  move_s comp_move ;
  int tested ;
  int found ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  tested = 0;
  found = 0;
  printf("\nName of EPD testsuite: ");
  rinput(testname, 256, __stdinp);
  printf("\nTime per move (s): ");
  rinput(readbuff, 256, __stdinp);
  tmp = atol((char const   *)(readbuff));
  thinktime = (int )tmp;
  printf("\n");
  thinktime *= 100;
  testsuite = fopen((char const   *)(testname), "r");
  while (1) {
    tmp___3 = fgets(readbuff, 2000, testsuite);
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
      break;
    }
    tested ++;
    setup_epd_line(readbuff);
    if (white_to_move) {
      root_to_move = 0;
    } else {
      root_to_move = 1;
    }
    clear_tt();
    initialize_hash();
    display_board(__stdoutp, 1);
    forcedwin = 0;
    tmp___0 = interrupt();
    if (tmp___0) {
      rinput(tempbuff, 256, __stdinp);
    }
    fixed_time = thinktime;
    comp_move = think();
    printf("\nNodes: %i (%0.2f%% qnodes)\n", nodes, (double )((float )((double )((float )qnodes / (float )nodes) * 100.0)));
    printf("ECacheProbes : %u   ECacheHits : %u   HitRate : %f%%\n", ECacheProbes,
           ECacheHits, (double )(((float )ECacheHits / ((float )ECacheProbes + (float )1)) * (float )100));
    printf("TTStores : %u TTProbes : %u   TTHits : %u   HitRate : %f%%\n", TTStores,
           TTProbes, TTHits, (double )(((float )TTHits / ((float )TTProbes + (float )1)) * (float )100));
    printf("NTries : %u  NCuts : %u  CutRate : %f%%  TExt: %u\n", NTries, NCuts, (double )(((float )NCuts * (float )100) / ((float )NTries + (float )1)),
           TExt);
    printf("Check extensions: %u  Razor drops : %u  Razor Material : %u\n", ext_check,
           razor_drop, razor_material);
    printf("Move ordering : %f%%\n", (double )(((float )FHF * (float )100) / (float )FH + (float )1));
    tmp___1 = eval(-1000000, 1000000);
    printf("Material score: %d  Eval : %d  MaxPosDiff: %d\n", Material, tmp___1, maxposdiff);
    printf("\n");
    if (! forcedwin) {
      tmp___2 = check_solution(readbuff, comp_move);
      if (tmp___2) {
        found ++;
        printf("Solution found.\n");
      } else {
        printf("Solution not found.\n");
      }
    } else {
      found ++;
    }
    printf("Solved: %d/%d\n", found, tested);
  }
  printf("\n");
  return;
}
}
void run_autotest(char *testset ) 
{ 
  FILE *testsuite ;
  char readbuff[256] ;
  int searchdepth ;
  rtime_t start ;
  rtime_t end ;
  move_s comp_move ;
  char *tmp ;
  char *tmp___0 ;

  {
  testsuite = fopen((char const   *)testset, "r");
  if ((unsigned long )testsuite == (unsigned long )((void *)0)) {
    exit(1);
  }
  start = rtime();
  while (1) {
    tmp___0 = fgets(readbuff, 256, testsuite);
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
      break;
    }
    setup_epd_line(readbuff);
    if (white_to_move) {
      root_to_move = 0;
    } else {
      root_to_move = 1;
    }
    clear_tt();
    initialize_hash();
    printf("\n");
    display_board(__stdoutp, 1);
    printf("EPD: %s\n", readbuff);
    tmp = fgets(readbuff, 256, testsuite);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      exit(1);
    }
    searchdepth = atoi((char const   *)(readbuff));
    printf("Searching to %d ply\n", searchdepth);
    maxdepth = searchdepth;
    fixed_time = 1000000;
    comp_move = think();
  }
  end = rtime();
  fclose(testsuite);
  exit(0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-22TGqTRP.i","-O3")
extern int abs(int  )  __attribute__((__const__)) ;
int piece_count ;
int pieces[62] ;
int Material  ;
int zh_material[14] ;
int std_material[14] ;
int suicide_material[14] ;
int losers_material[14] ;
int const   Xrank[144] ;
int const   Xfile[144] ;
int const   Xdiagl[144] ;
int const   Xdiagr[144] ;
int const   sqcolor[144] ;
int distance[144][144] ;
int rookdistance[144][144] ;
int const   upscale[64] ;
int cfg_devscale ;
int cfg_smarteval ;
int cfg_attackeval ;
int std_eval(int alpha , int beta ) ;
int suicide_eval(void) ;
int losers_eval(void) ;
void initialize_eval(void) ;
int std_material[14]  = 
  {      0,      100,      -100,      310, 
        -310,      4000,      -4000,      500, 
        -500,      900,      -900,      325, 
        -325,      0};
int zh_material[14]  = 
  {      0,      100,      -100,      210, 
        -210,      4000,      -4000,      250, 
        -250,      450,      -450,      230, 
        -230,      0};
int suicide_material[14]  = 
  {      0,      15,      -15,      150, 
        -150,      500,      -500,      150, 
        -150,      50,      -50,      0, 
        0,      0};
int losers_material[14]  = 
  {      0,      80,      -80,      320, 
        -320,      1000,      -1000,      350, 
        -350,      400,      -400,      270, 
        -270,      0};
int material[14]  = 
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0};
int const   Xfile[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   Xrank[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )6,      (int const   )6, 
        (int const   )6,      (int const   )6,      (int const   )6,      (int const   )6, 
        (int const   )6,      (int const   )6,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )7,      (int const   )7, 
        (int const   )7,      (int const   )7,      (int const   )7,      (int const   )7, 
        (int const   )7,      (int const   )7,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   Xdiagl[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )9,      (int const   )1, 
        (int const   )2,      (int const   )3,      (int const   )4,      (int const   )5, 
        (int const   )6,      (int const   )7,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )10,      (int const   )9, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )11,      (int const   )10, 
        (int const   )9,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )12,      (int const   )11, 
        (int const   )10,      (int const   )9,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )13,      (int const   )12, 
        (int const   )11,      (int const   )10,      (int const   )9,      (int const   )1, 
        (int const   )2,      (int const   )3,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )14,      (int const   )13, 
        (int const   )12,      (int const   )11,      (int const   )10,      (int const   )9, 
        (int const   )1,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )15,      (int const   )14, 
        (int const   )13,      (int const   )12,      (int const   )11,      (int const   )10, 
        (int const   )9,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   Xdiagr[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )15,      (int const   )14, 
        (int const   )13,      (int const   )12,      (int const   )11,      (int const   )10, 
        (int const   )9,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )14,      (int const   )13, 
        (int const   )12,      (int const   )11,      (int const   )10,      (int const   )9, 
        (int const   )1,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )13,      (int const   )12, 
        (int const   )11,      (int const   )10,      (int const   )9,      (int const   )1, 
        (int const   )2,      (int const   )3,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )12,      (int const   )11, 
        (int const   )10,      (int const   )9,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )11,      (int const   )10, 
        (int const   )9,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )10,      (int const   )9, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )4, 
        (int const   )5,      (int const   )6,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )9,      (int const   )1, 
        (int const   )2,      (int const   )3,      (int const   )4,      (int const   )5, 
        (int const   )6,      (int const   )7,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )8,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   sqcolor[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )1, 
        (int const   )0,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   pcsqbishop[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )-5, 
        (int const   )-10,      (int const   )-5,      (int const   )-5,      (int const   )-10, 
        (int const   )-5,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )10, 
        (int const   )5,      (int const   )10,      (int const   )10,      (int const   )5, 
        (int const   )10,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )5, 
        (int const   )6,      (int const   )15,      (int const   )15,      (int const   )6, 
        (int const   )5,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )3, 
        (int const   )15,      (int const   )10,      (int const   )10,      (int const   )15, 
        (int const   )3,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )3, 
        (int const   )15,      (int const   )10,      (int const   )10,      (int const   )15, 
        (int const   )3,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )5, 
        (int const   )6,      (int const   )15,      (int const   )15,      (int const   )6, 
        (int const   )5,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )10, 
        (int const   )5,      (int const   )10,      (int const   )10,      (int const   )5, 
        (int const   )10,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-5,      (int const   )-5, 
        (int const   )-10,      (int const   )-5,      (int const   )-5,      (int const   )-10, 
        (int const   )-5,      (int const   )-5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   black_knight[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-10, 
        (int const   )-10,      (int const   )-10,      (int const   )-10,      (int const   )-10, 
        (int const   )-10,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )15, 
        (int const   )25,      (int const   )25,      (int const   )25,      (int const   )25, 
        (int const   )15,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )15, 
        (int const   )25,      (int const   )35,      (int const   )35,      (int const   )35, 
        (int const   )15,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )10, 
        (int const   )25,      (int const   )20,      (int const   )25,      (int const   )25, 
        (int const   )10,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )20,      (int const   )20,      (int const   )20,      (int const   )20, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )15,      (int const   )15,      (int const   )15,      (int const   )15, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )0,      (int const   )3,      (int const   )3,      (int const   )0, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-35, 
        (int const   )-10,      (int const   )-10,      (int const   )-10,      (int const   )-10, 
        (int const   )-35,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   white_knight[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-35, 
        (int const   )-10,      (int const   )-10,      (int const   )-10,      (int const   )-10, 
        (int const   )-35,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )0,      (int const   )3,      (int const   )3,      (int const   )0, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )15,      (int const   )15,      (int const   )15,      (int const   )15, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )0, 
        (int const   )20,      (int const   )20,      (int const   )20,      (int const   )20, 
        (int const   )0,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )10, 
        (int const   )25,      (int const   )20,      (int const   )25,      (int const   )25, 
        (int const   )10,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )15, 
        (int const   )25,      (int const   )35,      (int const   )35,      (int const   )35, 
        (int const   )15,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-10,      (int const   )15, 
        (int const   )25,      (int const   )25,      (int const   )25,      (int const   )25, 
        (int const   )15,      (int const   )-10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-10, 
        (int const   )-10,      (int const   )-10,      (int const   )-10,      (int const   )-10, 
        (int const   )-10,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   white_pawn[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )25,      (int const   )25, 
        (int const   )35,      (int const   )5,      (int const   )5,      (int const   )50, 
        (int const   )45,      (int const   )30,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )7,      (int const   )5, 
        (int const   )5,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )14,      (int const   )14,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )10,      (int const   )20,      (int const   )20,      (int const   )10, 
        (int const   )5,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )12,      (int const   )18, 
        (int const   )18,      (int const   )27,      (int const   )27,      (int const   )18, 
        (int const   )18,      (int const   )18,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )25,      (int const   )30, 
        (int const   )30,      (int const   )35,      (int const   )35,      (int const   )35, 
        (int const   )30,      (int const   )25,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   black_pawn[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )30,      (int const   )30, 
        (int const   )30,      (int const   )35,      (int const   )35,      (int const   )35, 
        (int const   )30,      (int const   )25,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )12,      (int const   )18, 
        (int const   )18,      (int const   )27,      (int const   )27,      (int const   )18, 
        (int const   )18,      (int const   )18,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )10,      (int const   )20,      (int const   )20,      (int const   )10, 
        (int const   )5,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )14,      (int const   )14,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )7,      (int const   )5, 
        (int const   )5,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )25,      (int const   )25, 
        (int const   )35,      (int const   )5,      (int const   )5,      (int const   )50, 
        (int const   )45,      (int const   )30,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   white_king[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-100,      (int const   )7, 
        (int const   )4,      (int const   )0,      (int const   )10,      (int const   )4, 
        (int const   )7,      (int const   )-100,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-250,      (int const   )-200, 
        (int const   )-150,      (int const   )-100,      (int const   )-100,      (int const   )-150, 
        (int const   )-200,      (int const   )-250,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-350,      (int const   )-300, 
        (int const   )-300,      (int const   )-250,      (int const   )-250,      (int const   )-300, 
        (int const   )-300,      (int const   )-350,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-400,      (int const   )-400, 
        (int const   )-400,      (int const   )-350,      (int const   )-350,      (int const   )-400, 
        (int const   )-400,      (int const   )-400,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-450,      (int const   )-450, 
        (int const   )-450,      (int const   )-450,      (int const   )-450,      (int const   )-450, 
        (int const   )-450,      (int const   )-450,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   black_king[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )-500,      (int const   )-500, 
        (int const   )-500,      (int const   )-500,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-450,      (int const   )-450, 
        (int const   )-450,      (int const   )-450,      (int const   )-450,      (int const   )-450, 
        (int const   )-450,      (int const   )-450,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-400,      (int const   )-400, 
        (int const   )-400,      (int const   )-350,      (int const   )-350,      (int const   )-400, 
        (int const   )-400,      (int const   )-400,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-350,      (int const   )-300, 
        (int const   )-300,      (int const   )-250,      (int const   )-250,      (int const   )-300, 
        (int const   )-300,      (int const   )-350,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-250,      (int const   )-200, 
        (int const   )-150,      (int const   )-100,      (int const   )-100,      (int const   )-150, 
        (int const   )-200,      (int const   )-250,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-100,      (int const   )7, 
        (int const   )4,      (int const   )0,      (int const   )10,      (int const   )4, 
        (int const   )7,      (int const   )-100,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   black_queen[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )10,      (int const   )10,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-30,      (int const   )-30, 
        (int const   )-30,      (int const   )-30,      (int const   )-30,      (int const   )-30, 
        (int const   )-30,      (int const   )-30,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-60,      (int const   )-40, 
        (int const   )-40,      (int const   )-60,      (int const   )-60,      (int const   )-40, 
        (int const   )-40,      (int const   )-60,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-40,      (int const   )-40, 
        (int const   )-40,      (int const   )-40,      (int const   )-40,      (int const   )-40, 
        (int const   )-40,      (int const   )-40,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-15,      (int const   )-15, 
        (int const   )-15,      (int const   )-10,      (int const   )-10,      (int const   )-15, 
        (int const   )-15,      (int const   )-15,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )10,      (int const   )5, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   white_queen[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )10,      (int const   )5, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-15,      (int const   )-15, 
        (int const   )-15,      (int const   )-10,      (int const   )-10,      (int const   )-15, 
        (int const   )-15,      (int const   )-15,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-40,      (int const   )-40, 
        (int const   )-40,      (int const   )-40,      (int const   )-40,      (int const   )-40, 
        (int const   )-40,      (int const   )-40,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-60,      (int const   )-40, 
        (int const   )-40,      (int const   )-60,      (int const   )-60,      (int const   )-40, 
        (int const   )-40,      (int const   )-60,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-30,      (int const   )-30, 
        (int const   )-30,      (int const   )-30,      (int const   )-30,      (int const   )-30, 
        (int const   )-30,      (int const   )-30,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )10,      (int const   )10,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   black_rook[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )10,      (int const   )15, 
        (int const   )20,      (int const   )25,      (int const   )25,      (int const   )20, 
        (int const   )15,      (int const   )10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )10, 
        (int const   )15,      (int const   )20,      (int const   )20,      (int const   )15, 
        (int const   )10,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-30,      (int const   )-30,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-15,      (int const   )-15, 
        (int const   )-15,      (int const   )-10,      (int const   )-10,      (int const   )-15, 
        (int const   )-15,      (int const   )-15,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )10,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   white_rook[144]  = 
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )7,      (int const   )10,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-15,      (int const   )-15, 
        (int const   )-15,      (int const   )-10,      (int const   )-10,      (int const   )-15, 
        (int const   )-15,      (int const   )-15,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-30,      (int const   )-30,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )-20,      (int const   )-20, 
        (int const   )-20,      (int const   )-20,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )10, 
        (int const   )15,      (int const   )20,      (int const   )20,      (int const   )15, 
        (int const   )10,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )10,      (int const   )15, 
        (int const   )20,      (int const   )25,      (int const   )25,      (int const   )20, 
        (int const   )15,      (int const   )10,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   upscale[64]  = 
  {      (int const   )26,      (int const   )27,      (int const   )28,      (int const   )29, 
        (int const   )30,      (int const   )31,      (int const   )32,      (int const   )33, 
        (int const   )38,      (int const   )39,      (int const   )40,      (int const   )41, 
        (int const   )42,      (int const   )43,      (int const   )44,      (int const   )45, 
        (int const   )50,      (int const   )51,      (int const   )52,      (int const   )53, 
        (int const   )54,      (int const   )55,      (int const   )56,      (int const   )57, 
        (int const   )62,      (int const   )63,      (int const   )64,      (int const   )65, 
        (int const   )66,      (int const   )67,      (int const   )68,      (int const   )69, 
        (int const   )74,      (int const   )75,      (int const   )76,      (int const   )77, 
        (int const   )78,      (int const   )79,      (int const   )80,      (int const   )81, 
        (int const   )86,      (int const   )87,      (int const   )88,      (int const   )89, 
        (int const   )90,      (int const   )91,      (int const   )92,      (int const   )93, 
        (int const   )98,      (int const   )99,      (int const   )100,      (int const   )101, 
        (int const   )102,      (int const   )103,      (int const   )104,      (int const   )105, 
        (int const   )110,      (int const   )111,      (int const   )112,      (int const   )113, 
        (int const   )114,      (int const   )115,      (int const   )116,      (int const   )117};
int pre_p_tropism[9]  = 
  {      9999,      40,      20,      10, 
        3,      1,      1,      0, 
        9999};
int pre_r_tropism[9]  = 
  {      9999,      50,      40,      15, 
        5,      1,      1,      0, 
        9999};
int pre_n_tropism[9]  = 
  {      9999,      50,      70,      35, 
        10,      2,      1,      0, 
        9999};
int pre_q_tropism[9]  = 
  {      9999,      100,      60,      20, 
        5,      2,      0,      0, 
        9999};
int pre_b_tropism[9]  = 
  {      9999,      50,      25,      15, 
        5,      2,      2,      2, 
        9999};
unsigned char p_tropism[144][144]  ;
unsigned char q_tropism[144][144]  ;
unsigned char n_tropism[144][144]  ;
unsigned char r_tropism[144][144]  ;
unsigned char b_tropism[144][144]  ;
int ksafety_scaled[15][9]  = 
  { {        -5,        5,        10,        15, 
            50,        80,        150,        150, 
            150}, 
   {        -5,        15,        20,        25, 
            70,        150,        200,        200, 
            200}, 
   {        -5,        15,        30,        30, 
            100,        200,        300,        300, 
            300}, 
   {        -10,        20,        40,        40, 
            100,        200,        300,        300, 
            400}, 
   {        -10,        30,        50,        80, 
            150,        300,        400,        400, 
            500}, 
   {        -10,        35,        60,        100, 
            200,        250,        400,        400, 
            500}, 
   {        -10,        40,        70,        110, 
            210,        300,        500,        500, 
            600}, 
   {        -10,        45,        75,        125, 
            215,        300,        500,        600, 
            700}, 
   {        -10,        60,        90,        130, 
            240,        350,        500,        600, 
            700}, 
   {        -15,        60,        95,        145, 
            260,        350,        500,        600, 
            700}, 
   {        -15,        60,        100,        150, 
            270,        350,        500,        600, 
            700}, 
   {        -15,        60,        110,        160, 
            280,        400,        600,        700, 
            800}, 
   {        -20,        70,        115,        165, 
            290,        400,        600,        700, 
            800}, 
   {        -20,        80,        120,        170, 
            300,        450,        700,        800, 
            900}, 
   {        -20,        80,        125,        175, 
            310,        450,        700,        800, 
            900}};
void initialize_eval(void) 
{ 
  int i ;
  int j ;
  int sd ;
  int sdi ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
  i = 0;
  while (i < 64) {
    j = 0;
    while (j < 64) {
      sd = abs((i & 7) - (j & 7));
      sdi = abs((i >> 3) - (j >> 3));
      rookdistance[upscale[i]][upscale[j]] = sd + sdi;
      if (sd > sdi) {
        distance[upscale[i]][upscale[j]] = sd;
      } else {
        distance[upscale[i]][upscale[j]] = sdi;
      }
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < 144) {
    j = 0;
    while (j < 144) {
      tmp___4 = abs((int )(Xrank[i] - Xrank[j]));
      tmp___5 = abs((int )(Xfile[i] - Xfile[j]));
      if (tmp___4 > tmp___5) {
        tmp___1 = abs((int )(Xrank[i] - Xrank[j]));
        tmp___3 = tmp___1;
      } else {
        tmp___2 = abs((int )(Xfile[i] - Xfile[j]));
        tmp___3 = tmp___2;
      }
      p_tropism[i][j] = (unsigned char )pre_p_tropism[tmp___3];
      tmp___11 = abs((int )(Xrank[i] - Xrank[j]));
      tmp___12 = abs((int )(Xfile[i] - Xfile[j]));
      if (tmp___11 > tmp___12) {
        tmp___8 = abs((int )(Xrank[i] - Xrank[j]));
        tmp___10 = tmp___8;
      } else {
        tmp___9 = abs((int )(Xfile[i] - Xfile[j]));
        tmp___10 = tmp___9;
      }
      b_tropism[i][j] = (unsigned char )pre_b_tropism[tmp___10];
      tmp___18 = abs((int )(Xrank[i] - Xrank[j]));
      tmp___19 = abs((int )(Xfile[i] - Xfile[j]));
      if (tmp___18 > tmp___19) {
        tmp___15 = abs((int )(Xrank[i] - Xrank[j]));
        tmp___17 = tmp___15;
      } else {
        tmp___16 = abs((int )(Xfile[i] - Xfile[j]));
        tmp___17 = tmp___16;
      }
      n_tropism[i][j] = (unsigned char )pre_n_tropism[tmp___17];
      tmp___25 = abs((int )(Xrank[i] - Xrank[j]));
      tmp___26 = abs((int )(Xfile[i] - Xfile[j]));
      if (tmp___25 > tmp___26) {
        tmp___22 = abs((int )(Xrank[i] - Xrank[j]));
        tmp___24 = tmp___22;
      } else {
        tmp___23 = abs((int )(Xfile[i] - Xfile[j]));
        tmp___24 = tmp___23;
      }
      r_tropism[i][j] = (unsigned char )pre_r_tropism[tmp___24];
      tmp___32 = abs((int )(Xrank[i] - Xrank[j]));
      tmp___33 = abs((int )(Xfile[i] - Xfile[j]));
      if (tmp___32 > tmp___33) {
        tmp___29 = abs((int )(Xrank[i] - Xrank[j]));
        tmp___31 = tmp___29;
      } else {
        tmp___30 = abs((int )(Xfile[i] - Xfile[j]));
        tmp___31 = tmp___30;
      }
      q_tropism[i][j] = (unsigned char )pre_q_tropism[tmp___31];
      j ++;
    }
    i ++;
  }
  return;
}
}
int eval(int alpha , int beta ) 
{ 
  int i ;
  int a ;
  int j ;
  int score ;
  int in_cache ;
  int safety ;
  int badsquares ;
  int norm_white_hand_eval ;
  int norm_black_hand_eval ;
  int wdev_dscale ;
  int bdev_dscale ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  xbool tmp___2 ;
  unsigned int tmp___3 ;
  xbool tmp___4 ;
  unsigned int tmp___5 ;
  xbool tmp___6 ;
  unsigned int tmp___7 ;
  xbool tmp___8 ;
  unsigned int tmp___9 ;
  xbool tmp___10 ;
  unsigned int tmp___11 ;
  xbool tmp___12 ;
  unsigned int tmp___13 ;
  xbool tmp___14 ;
  unsigned int tmp___15 ;
  xbool tmp___16 ;
  unsigned int tmp___17 ;
  xbool tmp___18 ;
  unsigned int tmp___19 ;
  xbool tmp___20 ;
  unsigned int tmp___21 ;
  xbool tmp___22 ;
  unsigned int tmp___23 ;
  xbool tmp___24 ;
  unsigned int tmp___25 ;
  xbool tmp___26 ;
  unsigned int tmp___27 ;
  xbool tmp___28 ;
  unsigned int tmp___29 ;
  xbool tmp___30 ;
  unsigned int tmp___31 ;
  xbool tmp___32 ;
  unsigned int tmp___33 ;
  xbool tmp___34 ;
  unsigned int tmp___35 ;
  xbool tmp___36 ;
  unsigned int tmp___37 ;
  xbool tmp___38 ;
  unsigned int tmp___39 ;
  xbool tmp___40 ;
  unsigned int tmp___41 ;
  xbool tmp___42 ;
  unsigned int tmp___43 ;
  xbool tmp___44 ;
  unsigned int tmp___45 ;
  xbool tmp___46 ;
  unsigned int tmp___47 ;
  xbool tmp___48 ;
  unsigned int tmp___49 ;

  {
  score = 0;
  if (Variant == 2) {
    tmp = std_eval(alpha, beta);
    return (tmp);
  } else
  if (Variant == 3) {
    tmp___0 = suicide_eval();
    return (tmp___0);
  } else
  if (Variant == 4) {
    tmp___1 = losers_eval();
    return (tmp___1);
  }
  in_cache = 0;
  checkECache(& score, & in_cache);
  if (in_cache) {
    if (white_to_move == 1) {
      return (score);
    }
    return (- score);
  }
  if (cfg_devscale) {
    if (white_to_move != comp_color) {
      if (white_hand_eval <= 200) {
        if (Variant != 1) {
          wdev_dscale = 2;
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (white_hand_eval >= 700) {
        wdev_dscale = 0;
      } else {
        wdev_dscale = 1;
      }
    } else {
      wdev_dscale = 0;
    }
    if (white_to_move == comp_color) {
      if (- black_hand_eval <= 200) {
        if (Variant != 1) {
          bdev_dscale = 2;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (- black_hand_eval >= 700) {
        bdev_dscale = 0;
      } else {
        bdev_dscale = 1;
      }
    } else {
      bdev_dscale = 0;
    }
  } else {
    bdev_dscale = 0;
    wdev_dscale = bdev_dscale;
  }
  a = 1;
  j = 1;
  while (a <= piece_count) {
    i = pieces[j];
    if (! i) {
      goto __Cont;
    } else {
      a ++;
    }
    switch (board[i]) {
    case 1: 
    score += 100;
    score += (int )(white_pawn[i] >> wdev_dscale);
    score += (int )p_tropism[i][bking_loc];
    break;
    case 2: 
    score -= 100;
    score -= (int )(black_pawn[i] >> bdev_dscale);
    score -= (int )p_tropism[i][wking_loc];
    break;
    case 7: 
    score += 250;
    score += (int )(white_rook[i] >> wdev_dscale);
    score += (int )r_tropism[i][bking_loc];
    break;
    case 8: 
    score -= 250;
    score -= (int )(black_rook[i] >> bdev_dscale);
    score -= (int )r_tropism[i][wking_loc];
    break;
    case 11: 
    score += 230;
    score += (int )(pcsqbishop[i] >> wdev_dscale);
    score += (int )b_tropism[i][bking_loc];
    break;
    case 12: 
    score -= 230;
    score -= (int )(pcsqbishop[i] >> bdev_dscale);
    score -= (int )b_tropism[i][wking_loc];
    break;
    case 3: 
    score += 210;
    score += (int )(white_knight[i] >> wdev_dscale);
    score += (int )n_tropism[i][bking_loc];
    break;
    case 4: 
    score -= 210;
    score -= (int )(black_knight[i] >> bdev_dscale);
    score -= (int )n_tropism[i][wking_loc];
    break;
    case 9: 
    score += 450;
    score += (int )(white_queen[i] >> wdev_dscale);
    score += (int )q_tropism[i][bking_loc];
    break;
    case 10: 
    score -= 450;
    score -= (int )(black_queen[i] >> bdev_dscale);
    score -= (int )q_tropism[i][wking_loc];
    break;
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  score += (int )(white_king[wking_loc] >> bdev_dscale);
  score -= (int )(black_king[bking_loc] >> wdev_dscale);
  if (! white_castled) {
    if (moved[30]) {
      score -= 30;
    }
  }
  if (! black_castled) {
    if (moved[114]) {
      score += 30;
    }
  }
  if (! moved[41]) {
    if (board[53] != 13) {
      score -= 15;
    }
  }
  if (! moved[42]) {
    if (board[54] != 13) {
      score -= 15;
    }
  }
  if (! moved[101]) {
    if (board[89] != 13) {
      score += 15;
    }
  }
  if (! moved[102]) {
    if (board[90] != 13) {
      score += 15;
    }
  }
  if (cfg_smarteval) {
    if (wking_loc != 30) {
      if (wking_loc != 29) {
        if (board[wking_loc + 11] != 1) {
          score -= 24;
        }
        if (board[wking_loc + 12] != 1) {
          score -= 35;
        }
        if (board[wking_loc + 13] != 1) {
          score -= 24;
        }
        if (white_castled) {
          if (board[bking_loc - 25] == 2) {
            score += 11;
          }
          if (board[bking_loc - 24] == 2) {
            score += 15;
          }
          if (board[bking_loc - 23] == 2) {
            score += 11;
          }
        }
      }
    }
    if (bking_loc != 114) {
      if (bking_loc != 113) {
        if (board[bking_loc - 13] != 2) {
          score += 24;
        }
        if (board[bking_loc - 12] != 2) {
          score += 35;
        }
        if (board[bking_loc - 11] != 2) {
          score += 24;
        }
        if (black_castled) {
          if (board[bking_loc - 25] == 2) {
            score -= 11;
          }
          if (board[bking_loc - 24] == 2) {
            score -= 15;
          }
          if (board[bking_loc - 23] == 2) {
            score -= 11;
          }
        }
      }
    }
    if (moved[42]) {
      score += 30;
      if (moved[41]) {
        score += 25;
      }
      if (moved[32]) {
        score += 20;
      }
      if (moved[27]) {
        score += 15;
      }
      if (moved[28]) {
        score += 10;
      }
    }
    if (moved[102]) {
      score -= 30;
      if (moved[101]) {
        score -= 25;
      }
      if (moved[116]) {
        score -= 20;
      }
      if (moved[111]) {
        score -= 15;
      }
      if (moved[112]) {
        score -= 10;
      }
    }
    if (board[44] != 1) {
      if (board[55] == 2) {
        score -= 30;
      } else
      if (board[66] == 2) {
        score -= 30;
      }
    }
    if (board[104] != 2) {
      if (board[91] == 1) {
        score += 30;
      } else
      if (board[78] == 1) {
        score += 30;
      }
    }
    if (board[wking_loc + 12] == 2) {
      goto _L___1;
    } else
    if (board[wking_loc + 12] == 12) {
      _L___1: /* CIL Label */ 
      score -= 35;
      if (board[wking_loc + 12] == 0) {
        tmp___3 = 0U;
      } else {
        tmp___2 = is_attacked(wking_loc + 12, 0);
        tmp___3 = (unsigned int )tmp___2;
      }
      if (tmp___3) {
        score -= 150 >> bdev_dscale;
      }
    }
    if (board[bking_loc - 12] == 1) {
      goto _L___2;
    } else
    if (board[bking_loc - 12] == 11) {
      _L___2: /* CIL Label */ 
      score += 35;
      if (board[bking_loc - 12] == 0) {
        tmp___5 = 0U;
      } else {
        tmp___4 = is_attacked(bking_loc - 12, 1);
        tmp___5 = (unsigned int )tmp___4;
      }
      if (tmp___5) {
        score += 150 >> wdev_dscale;
      }
    }
    if (board[43] == 1) {
      goto _L___3;
    } else
    if (board[54] == 1) {
      goto _L___3;
    } else
    if (board[54] == 2) {
      _L___3: /* CIL Label */ 
      if (board[54] == 0) {
        tmp___7 = 0U;
      } else {
        tmp___6 = is_attacked(54, 0);
        tmp___7 = (unsigned int )tmp___6;
      }
      if (tmp___7) {
        if (board[43] == 1) {
          score += 10;
        }
        if (board[54] == 1) {
          score += 20;
        } else
        if (board[54] == 2) {
          score -= 15;
        }
      }
    }
    if (board[103] == 2) {
      goto _L___4;
    } else
    if (board[90] == 2) {
      goto _L___4;
    } else
    if (board[90] == 1) {
      _L___4: /* CIL Label */ 
      if (board[90] == 0) {
        tmp___9 = 0U;
      } else {
        tmp___8 = is_attacked(90, 1);
        tmp___9 = (unsigned int )tmp___8;
      }
      if (tmp___9) {
        if (board[103] == 2) {
          score -= 10;
        }
        if (board[90] == 2) {
          score -= 20;
        } else
        if (board[90] == 1) {
          score += 15;
        }
      }
    }
    if (board[bking_loc] == 0) {
      tmp___13 = 0U;
    } else {
      tmp___12 = is_attacked(bking_loc, 1);
      tmp___13 = (unsigned int )tmp___12;
    }
    if (tmp___13) {
      score += 50 >> wdev_dscale;
    } else {
      if (board[wking_loc] == 0) {
        tmp___11 = 0U;
      } else {
        tmp___10 = is_attacked(wking_loc, 0);
        tmp___11 = (unsigned int )tmp___10;
      }
      if (tmp___11) {
        score -= 50 >> bdev_dscale;
      }
    }
    if (board[44] == 4) {
      score -= 20;
      if (board[44] == 0) {
        tmp___15 = 0U;
      } else {
        tmp___14 = is_attacked(44, 0);
        tmp___15 = (unsigned int )tmp___14;
      }
      if (tmp___15) {
        score -= 40;
      }
      if (board[32] == 7) {
        score += 10;
      }
      if (board[31] == 11) {
        score += 10;
      }
    }
    if (board[104] == 3) {
      score += 20;
      if (board[104] == 0) {
        tmp___17 = 0U;
      } else {
        tmp___16 = is_attacked(104, 1);
        tmp___17 = (unsigned int )tmp___16;
      }
      if (tmp___17) {
        score += 40;
      }
      if (board[116] == 8) {
        score -= 10;
      }
      if (board[115] == 12) {
        score -= 10;
      }
    }
    if (board[57] == 12) {
      if (board[44] != 1) {
        score -= 20;
        if (board[44] == 4) {
          score -= 40;
          if (board[31] == 5) {
            score -= 80;
          } else
          if (board[32] == 5) {
            score -= 80;
          } else
          if (board[33] == 5) {
            score -= 80;
          }
        }
      }
    }
    if (board[93] == 11) {
      if (board[104] != 2) {
        score += 20;
        if (board[104] == 3) {
          score += 40;
          if (board[115] == 6) {
            score += 80;
          } else
          if (board[116] == 6) {
            score += 80;
          } else
          if (board[117] == 6) {
            score += 80;
          }
        }
      }
    }
  }
  if (cfg_attackeval) {
    badsquares = 0;
    safety = 0;
    if (board[wking_loc - 13] == 0) {
      tmp___19 = 0U;
    } else {
      tmp___18 = nk_attacked(wking_loc - 13, 0);
      tmp___19 = (unsigned int )tmp___18;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___19);
    if (board[wking_loc - 12] == 0) {
      tmp___21 = 0U;
    } else {
      tmp___20 = nk_attacked(wking_loc - 12, 0);
      tmp___21 = (unsigned int )tmp___20;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___21);
    if (board[wking_loc - 11] == 0) {
      tmp___23 = 0U;
    } else {
      tmp___22 = nk_attacked(wking_loc - 11, 0);
      tmp___23 = (unsigned int )tmp___22;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___23);
    if (board[wking_loc - 1] == 0) {
      tmp___25 = 0U;
    } else {
      tmp___24 = nk_attacked(wking_loc - 1, 0);
      tmp___25 = (unsigned int )tmp___24;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___25);
    if (board[wking_loc + 1] == 0) {
      tmp___27 = 0U;
    } else {
      tmp___26 = nk_attacked(wking_loc + 1, 0);
      tmp___27 = (unsigned int )tmp___26;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___27);
    if (board[wking_loc + 11] == 0) {
      tmp___29 = 0U;
    } else {
      tmp___28 = nk_attacked(wking_loc + 11, 0);
      tmp___29 = (unsigned int )tmp___28;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___29);
    if (board[wking_loc + 12] == 0) {
      tmp___31 = 0U;
    } else {
      tmp___30 = nk_attacked(wking_loc + 12, 0);
      tmp___31 = (unsigned int )tmp___30;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___31);
    if (board[wking_loc + 13] == 0) {
      tmp___33 = 0U;
    } else {
      tmp___32 = nk_attacked(wking_loc + 13, 0);
      tmp___33 = (unsigned int )tmp___32;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___33);
    norm_black_hand_eval = - black_hand_eval / 100;
    if (norm_black_hand_eval > 14) {
      norm_black_hand_eval = 14;
    } else
    if (norm_black_hand_eval < 0) {
      norm_black_hand_eval = 0;
    }
    safety -= ksafety_scaled[norm_black_hand_eval][badsquares];
    badsquares = 0;
    if (board[bking_loc - 13] == 0) {
      tmp___35 = 0U;
    } else {
      tmp___34 = nk_attacked(bking_loc - 13, 1);
      tmp___35 = (unsigned int )tmp___34;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___35);
    if (board[bking_loc - 12] == 0) {
      tmp___37 = 0U;
    } else {
      tmp___36 = nk_attacked(bking_loc - 12, 1);
      tmp___37 = (unsigned int )tmp___36;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___37);
    if (board[bking_loc - 11] == 0) {
      tmp___39 = 0U;
    } else {
      tmp___38 = nk_attacked(bking_loc - 11, 1);
      tmp___39 = (unsigned int )tmp___38;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___39);
    if (board[bking_loc - 1] == 0) {
      tmp___41 = 0U;
    } else {
      tmp___40 = nk_attacked(bking_loc - 1, 1);
      tmp___41 = (unsigned int )tmp___40;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___41);
    if (board[bking_loc + 1] == 0) {
      tmp___43 = 0U;
    } else {
      tmp___42 = nk_attacked(bking_loc + 1, 1);
      tmp___43 = (unsigned int )tmp___42;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___43);
    if (board[bking_loc + 11] == 0) {
      tmp___45 = 0U;
    } else {
      tmp___44 = nk_attacked(bking_loc + 11, 1);
      tmp___45 = (unsigned int )tmp___44;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___45);
    if (board[bking_loc + 12] == 0) {
      tmp___47 = 0U;
    } else {
      tmp___46 = nk_attacked(bking_loc + 12, 1);
      tmp___47 = (unsigned int )tmp___46;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___47);
    if (board[bking_loc + 13] == 0) {
      tmp___49 = 0U;
    } else {
      tmp___48 = nk_attacked(bking_loc + 13, 1);
      tmp___49 = (unsigned int )tmp___48;
    }
    badsquares = (int )((unsigned int )badsquares + tmp___49);
    norm_white_hand_eval = white_hand_eval / 100;
    if (norm_white_hand_eval > 14) {
      norm_white_hand_eval = 14;
    } else
    if (norm_white_hand_eval < 0) {
      norm_white_hand_eval = 0;
    }
    safety += ksafety_scaled[norm_white_hand_eval][badsquares];
    score += safety;
  }
  score += white_hand_eval + black_hand_eval;
  storeECache(score);
  if (white_to_move == 1) {
    return (score);
  } else {
    return (- score);
  }
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-qLi7bteq.i","-O3")
static int lcentral[144]  = 
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -20,      -15, 
        -15,      -15,      -15,      -15, 
        -15,      -20,      0,      0, 
        0,      0,      -15,      0, 
        3,      5,      5,      3, 
        0,      -15,      0,      0, 
        0,      0,      -15,      0, 
        15,      15,      15,      15, 
        0,      -15,      0,      0, 
        0,      0,      -15,      0, 
        15,      30,      30,      15, 
        0,      -15,      0,      0, 
        0,      0,      -15,      0, 
        15,      30,      30,      15, 
        0,      -15,      0,      0, 
        0,      0,      -15,      0, 
        15,      15,      15,      15, 
        0,      -15,      0,      0, 
        0,      0,      -15,      0, 
        3,      5,      5,      3, 
        0,      -15,      0,      0, 
        0,      0,      -20,      -15, 
        -15,      -15,      -15,      -15, 
        -15,      -20,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
static int l_bishop_mobility(int square ) 
{ 
  register int l ;
  register int m ;

  {
  m = 0;
  l = square - 13;
  while (board[l] == 13) {
    m ++;
    l -= 13;
  }
  l = square - 11;
  while (board[l] == 13) {
    m ++;
    l -= 11;
  }
  l = square + 11;
  while (board[l] == 13) {
    m ++;
    l += 11;
  }
  l = square + 13;
  while (board[l] == 13) {
    m ++;
    l += 13;
  }
  return (m);
}
}
static int l_rook_mobility(int square ) 
{ 
  register int l ;
  register int m ;

  {
  m = 0;
  l = square - 12;
  while (board[l] == 13) {
    m ++;
    l -= 12;
  }
  l = square - 1;
  while (board[l] == 13) {
    m ++;
    l --;
  }
  l = square + 1;
  while (board[l] == 13) {
    m ++;
    l ++;
  }
  l = square + 12;
  while (board[l] == 13) {
    m ++;
    l += 12;
  }
  return (m);
}
}
static int l_knight_mobility(int square ) ;
static int const   knight_o___2[8]  = 
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
static int l_knight_mobility(int square ) 
{ 
  register int d ;
  register int m ;

  {
  m = 0;
  d = 0;
  while (d < 8) {
    if (board[square + (int )knight_o___2[d]] == 13) {
      m ++;
    }
    d ++;
  }
  return (m);
}
}
static int l_pawn_mobility(int square ) 
{ 
  register int m ;

  {
  m = 0;
  if (board[square] == 1) {
    if (board[square + 12] == 13) {
      m ++;
    }
  } else
  if (board[square - 12] == 13) {
    m ++;
  }
  return (m);
}
}
static int l_king_mobility(int square ) ;
static int const   king_o[8]  = 
  {      (int const   )13,      (int const   )12,      (int const   )11,      (int const   )1, 
        (int const   )-1,      (int const   )-11,      (int const   )-12,      (int const   )-13};
static int l_king_mobility(int square ) 
{ 
  register int d ;
  register int m ;

  {
  m = 0;
  d = 0;
  while (d < 8) {
    if (board[square + (int )king_o[d]] == 13) {
      m ++;
    }
    d ++;
  }
  return (m);
}
}
int losers_eval(void) 
{ 
  int srank ;
  int pawn_file ;
  int pawns[2][11] ;
  int white_back_pawn[11] ;
  int black_back_pawn[11] ;
  int isolated ;
  int backwards ;
  int i ;
  int a ;
  int j ;
  int score ;
  int in_cache ;
  int wp ;
  int bp ;
  int wks ;
  int bks ;
  int wpassp ;
  int bpassp ;
  int wpawns ;
  int bpawns ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  srank = 0;
  pawn_file = 0;
  score = 0;
  wp = 0;
  bp = 0;
  wks = 0;
  bks = 0;
  wpassp = 0;
  bpassp = 0;
  wpawns = 0;
  bpawns = 0;
  in_cache = 0;
  checkECache(& score, & in_cache);
  if (in_cache) {
    if (white_to_move == 1) {
      return (score);
    }
    return (- score);
  }
  tmp___0 = __builtin_object_size((void *)(pawns), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(pawns), 0);
    __builtin___memset_chk((void *)(pawns), 0, sizeof(pawns), tmp);
  } else {
    __inline_memset_chk((void *)(pawns), 0, sizeof(pawns));
  }
  i = 0;
  while (i < 11) {
    white_back_pawn[i] = 7;
    black_back_pawn[i] = 2;
    i ++;
  }
  j = 1;
  a = 1;
  while (a <= piece_count) {
    i = pieces[j];
    if (! i) {
      goto __Cont;
    } else {
      a ++;
    }
    pawn_file = (int )(Xfile[i] + 1);
    srank = (int )Xrank[i];
    if (board[i] == 1) {
      (pawns[1][pawn_file]) ++;
      if (srank < white_back_pawn[pawn_file]) {
        white_back_pawn[pawn_file] = srank;
      }
    } else
    if (board[i] == 2) {
      (pawns[0][pawn_file]) ++;
      if (srank > black_back_pawn[pawn_file]) {
        black_back_pawn[pawn_file] = srank;
      }
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  j = 1;
  a = 1;
  while (a <= piece_count) {
    i = pieces[j];
    if (! i) {
      goto __Cont___0;
    } else {
      a ++;
    }
    switch (board[i]) {
    case 1: 
    wp ++;
    wpawns ++;
    score += lcentral[i];
    tmp___1 = l_pawn_mobility(i);
    score += tmp___1 << 2;
    score += (int )((Xrank[i] - 2) * 8);
    isolated = 0;
    backwards = 0;
    if (white_back_pawn[pawn_file + 1] > srank) {
      if (white_back_pawn[pawn_file - 1] > srank) {
        score -= 8;
        backwards = 1;
        if (! pawns[1][pawn_file + 1]) {
          if (! pawns[1][pawn_file - 1]) {
            score -= 12;
            isolated = 1;
          }
        }
      }
    }
    if (! pawns[0][pawn_file]) {
      if (backwards) {
        score -= 5;
      }
      if (isolated) {
        score -= 8;
      }
    }
    if (pawns[1][pawn_file] > 1) {
      score -= 8 * (pawns[1][pawn_file] - 1);
    }
    if (! pawns[0][pawn_file]) {
      if (srank >= black_back_pawn[pawn_file - 1]) {
        if (srank >= black_back_pawn[pawn_file + 1]) {
          score += 25 + 10 * (int )(Xrank[i] - 2);
          if (Xrank[i] == 7) {
            score += 50;
          }
          wpassp ++;
          if (Xfile[i] == 1) {
            score += 4 + 2 * (int )(Xrank[i] - 2);
          } else
          if (Xfile[i] == 8) {
            score += 4 + 2 * (int )(Xrank[i] - 2);
          }
          if (! isolated) {
            score += 24;
          }
        }
      }
    }
    if (! pawns[1][pawn_file - 1]) {
      score -= 5;
    }
    break;
    case 2: 
    bp ++;
    bpawns ++;
    score -= lcentral[i];
    tmp___2 = l_pawn_mobility(i);
    score -= tmp___2 << 2;
    score -= (7 - (int )Xrank[i]) * 8;
    isolated = 0;
    backwards = 0;
    if (black_back_pawn[pawn_file + 1] < srank) {
      if (black_back_pawn[pawn_file - 1] < srank) {
        score += 8;
        backwards = 1;
        if (! pawns[0][pawn_file + 1]) {
          if (! pawns[0][pawn_file - 1]) {
            score += 12;
            isolated = 1;
          }
        }
      }
    }
    if (! pawns[1][pawn_file]) {
      if (backwards) {
        score += 5;
      }
      if (isolated) {
        score += 8;
      }
    }
    if (pawns[0][pawn_file] > 1) {
      score += 8 * (pawns[0][pawn_file] - 1);
    }
    if (! pawns[1][pawn_file]) {
      if (srank <= white_back_pawn[pawn_file - 1]) {
        if (srank <= white_back_pawn[pawn_file + 1]) {
          score -= 25 + 10 * (7 - (int )Xrank[i]);
          if (Xrank[i] == 2) {
            score -= 50;
          }
          bpassp ++;
          if (Xfile[i] == 1) {
            score -= 4 + 2 * (7 - (int )Xrank[i]);
          } else
          if (Xfile[i] == 8) {
            score -= 4 + 2 * (7 - (int )Xrank[i]);
          }
          if (! isolated) {
            score -= 24;
          }
        }
      }
    }
    if (! pawns[0][pawn_file - 1]) {
      score += 5;
    }
    break;
    case 7: 
    wp ++;
    tmp___3 = l_rook_mobility(i);
    score += tmp___3 << 2;
    score += lcentral[i];
    break;
    case 8: 
    bp ++;
    tmp___4 = l_rook_mobility(i);
    score -= tmp___4 << 2;
    score -= lcentral[i];
    break;
    case 11: 
    wp ++;
    tmp___5 = l_bishop_mobility(i);
    score += tmp___5 << 2;
    score += lcentral[i];
    break;
    case 12: 
    bp ++;
    tmp___6 = l_bishop_mobility(i);
    score -= tmp___6 << 2;
    score -= lcentral[i];
    break;
    case 3: 
    wp ++;
    score += lcentral[i] << 1;
    tmp___7 = l_knight_mobility(i);
    score += tmp___7 << 2;
    break;
    case 4: 
    bp ++;
    score -= lcentral[i] << 1;
    tmp___8 = l_knight_mobility(i);
    score -= tmp___8 << 2;
    break;
    case 9: 
    wp ++;
    tmp___9 = l_bishop_mobility(i);
    score += tmp___9 << 1;
    tmp___10 = l_rook_mobility(i);
    score += tmp___10 << 1;
    score += lcentral[i];
    break;
    case 10: 
    bp ++;
    tmp___11 = l_bishop_mobility(i);
    score -= tmp___11 << 1;
    tmp___12 = l_rook_mobility(i);
    score -= tmp___12 << 1;
    score -= lcentral[i];
    break;
    case 5: 
    wks = lcentral[i] << 1;
    tmp___13 = l_king_mobility(i);
    score += tmp___13;
    break;
    case 6: 
    bks = lcentral[i] << 1;
    tmp___14 = l_king_mobility(i);
    score -= tmp___14;
    break;
    }
    __Cont___0: /* CIL Label */ 
    j ++;
  }
  if (wp + bp > 10) {
    score -= wks - bks;
  }
  tmp___15 = abs(Material);
  if (tmp___15 <= 900) {
    score += Material;
  } else
  if (Material > 0) {
    if (comp_color == 1) {
      if (! wpassp) {
        score += 1800 - Material;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (Material < 0) {
    if (comp_color == 0) {
      if (! bpassp) {
        score += - (1800 + Material);
      } else {
        score += Material;
      }
    } else {
      score += Material;
    }
  } else {
    score += Material;
  }
  if (! wpawns) {
    score += 200;
  } else
  if (! bpawns) {
    score -= 200;
  }
  if (! wp) {
    score = 1000000;
  } else
  if (! bp) {
    score = -1000000;
  }
  storeECache(score);
  if (white_to_move == 1) {
    return (score);
  } else {
    return (- score);
  }
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-jUsHED6T.i","-O3")
int squares[144] ;
xbool captures ;
move_x path_x[300] ;
int is_promoted[62] ;
unsigned int total_moves  ;
unsigned int total_movegens  ;
int Giveaway ;
int numb_moves  ;
int kingcap  ;
xbool check_legal(move_s *moves , int m , int incheck ) ;
void gen(move_s *moves ) ;
xbool in_check(void) ;
xbool f_in_check(move_s *moves , int m ) ;
int extended_in_check(void) ;
void make(move_s *moves , int i ) ;
void push_pawn(int target , xbool is_ep ) ;
void push_king_castle(int Ptarget , int Pcastle_type ) ;
void push_pawn_simple(int target ) ;
void push_king(int target ) ;
void push_knighT(int target ) ;
void try_drop(int ptype ) ;
void push_slidE(int target ) ;
void unmake(move_s *moves , int i ) ;
static move_s *genfor  ;
xbool fcaptures  ;
int gfrom  ;
xbool check_legal(move_s *moves , int m , int incheck ) 
{ 
  int castled ;
  int from ;
  int target ;
  int l ;
  xbool tmp ;
  xbool tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  xbool tmp___3 ;
  xbool tmp___4 ;
  xbool tmp___5 ;
  xbool tmp___6 ;
  xbool tmp___7 ;
  xbool tmp___8 ;
  xbool tmp___9 ;
  xbool tmp___10 ;
  int tmp___11 ;
  xbool tmp___12 ;
  int tmp___13 ;
  xbool tmp___14 ;

  {
  castled = (moves + m)->castled;
  from = (moves + m)->from;
  target = (moves + m)->target;
  if (Variant == 3) {
    return ((xbool )1);
  }
  if (castled) {
    if (castled == 1) {
      tmp = is_attacked(30, 0);
      if (tmp) {
        return ((xbool )0);
      }
      tmp___0 = is_attacked(31, 0);
      if (tmp___0) {
        return ((xbool )0);
      }
      tmp___1 = is_attacked(32, 0);
      if (tmp___1) {
        return ((xbool )0);
      }
      return ((xbool )1);
    }
    if (castled == 2) {
      tmp___2 = is_attacked(30, 0);
      if (tmp___2) {
        return ((xbool )0);
      }
      tmp___3 = is_attacked(29, 0);
      if (tmp___3) {
        return ((xbool )0);
      }
      tmp___4 = is_attacked(28, 0);
      if (tmp___4) {
        return ((xbool )0);
      }
      return ((xbool )1);
    }
    if (castled == 3) {
      tmp___5 = is_attacked(114, 1);
      if (tmp___5) {
        return ((xbool )0);
      }
      tmp___6 = is_attacked(115, 1);
      if (tmp___6) {
        return ((xbool )0);
      }
      tmp___7 = is_attacked(116, 1);
      if (tmp___7) {
        return ((xbool )0);
      }
      return ((xbool )1);
    }
    if (castled == 4) {
      tmp___8 = is_attacked(114, 1);
      if (tmp___8) {
        return ((xbool )0);
      }
      tmp___9 = is_attacked(113, 1);
      if (tmp___9) {
        return ((xbool )0);
      }
      tmp___10 = is_attacked(112, 1);
      if (tmp___10) {
        return ((xbool )0);
      }
      return ((xbool )1);
    }
  } else
  if (white_to_move & 1) {
    if (! incheck) {
      if ((moves + m)->from == 0) {
        return ((xbool )1);
      }
      if ((moves + m)->promoted) {
        tmp___11 = 2;
      } else {
        tmp___11 = board[target];
      }
      switch (tmp___11) {
      case 2: 
      if ((moves + m)->captured != 13) {
        if (Xfile[from] != Xfile[bking_loc]) {
          if (Xrank[from] != Xrank[bking_loc]) {
            if (Xdiagl[from] != Xdiagl[bking_loc]) {
              if (Xdiagr[from] != Xdiagr[bking_loc]) {
                return ((xbool )1);
              }
            }
          }
        }
      } else
      if (Xrank[from] != Xrank[bking_loc]) {
        if (Xdiagl[from] != Xdiagl[bking_loc]) {
          if (Xdiagr[from] != Xdiagr[bking_loc]) {
            return ((xbool )1);
          }
        }
      }
      break;
      case 4: 
      if (Xfile[from] != Xfile[bking_loc]) {
        if (Xrank[from] != Xrank[bking_loc]) {
          if (Xdiagl[from] != Xdiagl[bking_loc]) {
            if (Xdiagr[from] != Xdiagr[bking_loc]) {
              return ((xbool )1);
            }
          }
        }
      }
      break;
      case 12: 
      if (Xfile[from] != Xfile[bking_loc]) {
        if (Xrank[from] != Xrank[bking_loc]) {
          if (Xdiagl[from] == Xdiagl[target]) {
            if (Xdiagr[from] != Xdiagr[bking_loc]) {
              return ((xbool )1);
            }
          } else
          if (Xdiagl[from] != Xdiagl[bking_loc]) {
            return ((xbool )1);
          }
        }
      }
      break;
      case 8: 
      if (Xdiagr[from] != Xdiagr[bking_loc]) {
        if (Xdiagl[from] != Xdiagl[bking_loc]) {
          if (Xrank[from] == Xrank[target]) {
            if (Xfile[from] != Xfile[bking_loc]) {
              return ((xbool )1);
            }
          } else
          if (Xrank[from] != Xrank[bking_loc]) {
            return ((xbool )1);
          }
        }
      }
      break;
      case 10: 
      if (Xfile[from] == Xfile[target]) {
        if (Xdiagr[from] != Xdiagr[bking_loc]) {
          if (Xdiagl[from] != Xdiagl[bking_loc]) {
            if (Xrank[from] != Xrank[bking_loc]) {
              return ((xbool )1);
            }
          }
        }
      } else
      if (Xrank[from] == Xrank[target]) {
        if (Xdiagr[from] != Xdiagr[bking_loc]) {
          if (Xfile[from] != Xfile[bking_loc]) {
            if (Xdiagl[from] != Xdiagl[bking_loc]) {
              return ((xbool )1);
            }
          }
        }
      } else
      if (Xdiagl[from] == Xdiagl[target]) {
        if (Xdiagr[from] != Xdiagr[bking_loc]) {
          if (Xfile[from] != Xfile[bking_loc]) {
            if (Xrank[from] != Xrank[bking_loc]) {
              return ((xbool )1);
            }
          }
        }
      } else
      if (Xdiagr[from] == Xdiagr[target]) {
        if (Xdiagl[from] != Xdiagl[bking_loc]) {
          if (Xfile[from] != Xfile[bking_loc]) {
            if (Xrank[from] != Xrank[bking_loc]) {
              return ((xbool )1);
            }
          }
        }
      }
      break;
      default: 
      break;
      }
      if (board[target] != 6) {
        if (Xfile[from] == Xfile[bking_loc]) {
          if (bking_loc > from) {
            l = bking_loc - 12;
            while (board[l] == 13) {
              l -= 12;
            }
            if (board[l] == 7) {
              return ((xbool )0);
            } else
            if (board[l] == 9) {
              return ((xbool )0);
            }
          } else {
            l = bking_loc + 12;
            while (board[l] == 13) {
              l += 12;
            }
            if (board[l] == 7) {
              return ((xbool )0);
            } else
            if (board[l] == 9) {
              return ((xbool )0);
            }
          }
        } else
        if (Xrank[from] == Xrank[bking_loc]) {
          if (bking_loc > from) {
            l = bking_loc - 1;
            while (board[l] == 13) {
              l --;
            }
            if (board[l] == 7) {
              return ((xbool )0);
            } else
            if (board[l] == 9) {
              return ((xbool )0);
            }
          } else {
            l = bking_loc + 1;
            while (board[l] == 13) {
              l ++;
            }
            if (board[l] == 7) {
              return ((xbool )0);
            } else
            if (board[l] == 9) {
              return ((xbool )0);
            }
          }
        } else
        if (Xdiagl[from] == Xdiagl[bking_loc]) {
          if (bking_loc > from) {
            l = bking_loc - 13;
            while (board[l] == 13) {
              l -= 13;
            }
            if (board[l] == 11) {
              return ((xbool )0);
            } else
            if (board[l] == 9) {
              return ((xbool )0);
            }
          } else {
            l = bking_loc + 13;
            while (board[l] == 13) {
              l += 13;
            }
            if (board[l] == 11) {
              return ((xbool )0);
            } else
            if (board[l] == 9) {
              return ((xbool )0);
            }
          }
        } else
        if (Xdiagr[from] == Xdiagr[bking_loc]) {
          if (bking_loc > from) {
            l = bking_loc - 11;
            while (board[l] == 13) {
              l -= 11;
            }
            if (board[l] == 11) {
              return ((xbool )0);
            } else
            if (board[l] == 9) {
              return ((xbool )0);
            }
          } else {
            l = bking_loc + 11;
            while (board[l] == 13) {
              l += 11;
            }
            if (board[l] == 11) {
              return ((xbool )0);
            } else
            if (board[l] == 9) {
              return ((xbool )0);
            }
          }
        }
        return ((xbool )1);
      }
    }
    tmp___12 = is_attacked(bking_loc, 1);
    if (tmp___12) {
      return ((xbool )0);
    } else {
      return ((xbool )1);
    }
  } else {
    if (! incheck) {
      if ((moves + m)->from == 0) {
        return ((xbool )1);
      }
      if ((moves + m)->promoted) {
        tmp___13 = 1;
      } else {
        tmp___13 = board[target];
      }
      switch (tmp___13) {
      case 1: 
      if ((moves + m)->captured != 13) {
        if (Xfile[from] != Xfile[wking_loc]) {
          if (Xrank[from] != Xrank[wking_loc]) {
            if (Xdiagl[from] != Xdiagl[wking_loc]) {
              if (Xdiagr[from] != Xdiagr[wking_loc]) {
                return ((xbool )1);
              }
            }
          }
        }
      } else
      if (Xrank[from] != Xrank[wking_loc]) {
        if (Xdiagl[from] != Xdiagl[wking_loc]) {
          if (Xdiagr[from] != Xdiagr[wking_loc]) {
            return ((xbool )1);
          }
        }
      }
      break;
      case 3: 
      if (Xfile[from] != Xfile[wking_loc]) {
        if (Xrank[from] != Xrank[wking_loc]) {
          if (Xdiagl[from] != Xdiagl[wking_loc]) {
            if (Xdiagr[from] != Xdiagr[wking_loc]) {
              return ((xbool )1);
            }
          }
        }
      }
      break;
      case 11: 
      if (Xfile[from] != Xfile[wking_loc]) {
        if (Xrank[from] != Xrank[wking_loc]) {
          if (Xdiagl[from] == Xdiagl[target]) {
            if (Xdiagr[from] != Xdiagr[wking_loc]) {
              return ((xbool )1);
            }
          } else
          if (Xdiagl[from] != Xdiagl[wking_loc]) {
            return ((xbool )1);
          }
        }
      }
      break;
      case 7: 
      if (Xdiagr[from] != Xdiagr[wking_loc]) {
        if (Xdiagl[from] != Xdiagl[wking_loc]) {
          if (Xrank[from] == Xrank[target]) {
            if (Xfile[from] != Xfile[wking_loc]) {
              return ((xbool )1);
            }
          } else
          if (Xrank[from] != Xrank[wking_loc]) {
            return ((xbool )1);
          }
        }
      }
      break;
      case 9: 
      if (Xfile[from] == Xfile[(moves + m)->target]) {
        if (Xdiagr[from] != Xdiagr[wking_loc]) {
          if (Xdiagl[from] != Xdiagl[wking_loc]) {
            if (Xrank[from] != Xrank[wking_loc]) {
              return ((xbool )1);
            }
          }
        }
      } else
      if (Xrank[from] == Xrank[target]) {
        if (Xdiagr[from] != Xdiagr[wking_loc]) {
          if (Xfile[from] != Xfile[wking_loc]) {
            if (Xdiagl[from] != Xdiagl[wking_loc]) {
              return ((xbool )1);
            }
          }
        }
      } else
      if (Xdiagl[from] == Xdiagl[target]) {
        if (Xdiagr[from] != Xdiagr[wking_loc]) {
          if (Xfile[from] != Xfile[wking_loc]) {
            if (Xrank[from] != Xrank[wking_loc]) {
              return ((xbool )1);
            }
          }
        }
      } else
      if (Xdiagr[from] == Xdiagr[target]) {
        if (Xdiagl[from] != Xdiagl[wking_loc]) {
          if (Xfile[from] != Xfile[wking_loc]) {
            if (Xrank[from] != Xrank[wking_loc]) {
              return ((xbool )1);
            }
          }
        }
      }
      break;
      default: 
      break;
      }
      if (board[target] != 5) {
        if (Xfile[from] == Xfile[wking_loc]) {
          if (wking_loc > from) {
            l = wking_loc - 12;
            while (board[l] == 13) {
              l -= 12;
            }
            if (board[l] == 8) {
              return ((xbool )0);
            } else
            if (board[l] == 10) {
              return ((xbool )0);
            }
          } else {
            l = wking_loc + 12;
            while (board[l] == 13) {
              l += 12;
            }
            if (board[l] == 8) {
              return ((xbool )0);
            } else
            if (board[l] == 10) {
              return ((xbool )0);
            }
          }
        } else
        if (Xrank[from] == Xrank[wking_loc]) {
          if (wking_loc > from) {
            l = wking_loc - 1;
            while (board[l] == 13) {
              l --;
            }
            if (board[l] == 8) {
              return ((xbool )0);
            } else
            if (board[l] == 10) {
              return ((xbool )0);
            }
          } else {
            l = wking_loc + 1;
            while (board[l] == 13) {
              l ++;
            }
            if (board[l] == 8) {
              return ((xbool )0);
            } else
            if (board[l] == 10) {
              return ((xbool )0);
            }
          }
        } else
        if (Xdiagl[from] == Xdiagl[wking_loc]) {
          if (wking_loc > from) {
            l = wking_loc - 13;
            while (board[l] == 13) {
              l -= 13;
            }
            if (board[l] == 12) {
              return ((xbool )0);
            } else
            if (board[l] == 10) {
              return ((xbool )0);
            }
          } else {
            l = wking_loc + 13;
            while (board[l] == 13) {
              l += 13;
            }
            if (board[l] == 12) {
              return ((xbool )0);
            } else
            if (board[l] == 10) {
              return ((xbool )0);
            }
          }
        } else
        if (Xdiagr[from] == Xdiagr[wking_loc]) {
          if (wking_loc > from) {
            l = wking_loc - 11;
            while (board[l] == 13) {
              l -= 11;
            }
            if (board[l] == 12) {
              return ((xbool )0);
            } else
            if (board[l] == 10) {
              return ((xbool )0);
            }
          } else {
            l = wking_loc + 11;
            while (board[l] == 13) {
              l += 11;
            }
            if (board[l] == 12) {
              return ((xbool )0);
            } else
            if (board[l] == 10) {
              return ((xbool )0);
            }
          }
        }
        return ((xbool )1);
      }
    }
    tmp___14 = is_attacked(wking_loc, 0);
    if (tmp___14) {
      return ((xbool )0);
    } else {
      return ((xbool )1);
    }
  }
  return ((xbool )0);
}
}
void gen(move_s *moves ) 
{ 
  int from ;
  int a ;
  int j ;
  int i ;

  {
  kingcap = 0;
  numb_moves = 0;
  genfor = moves + 0;
  if (Variant == 3) {
    captures = (xbool )0;
    fcaptures = (xbool )0;
  }
  restart: 
  if (white_to_move) {
    a = 1;
    j = 1;
    while (1) {
      if (a <= piece_count) {
        if (Variant != 3) {
          if (! (! kingcap)) {
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
        if (Variant == 3) {
          if (! ((unsigned int )fcaptures == (unsigned int )captures)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      i = pieces[j];
      if (! i) {
        goto __Cont;
      } else {
        a ++;
      }
      from = i;
      gfrom = i;
      switch (board[from]) {
      case 1: 
      if (board[from + 12] == 13) {
        if (Xrank[from] == 7) {
          if (Variant != 3) {
            if (Variant != 4) {
              push_pawn(from + 12, (xbool )0);
            } else {
              goto _L;
            }
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (! captures) {
          push_pawn(from + 12, (xbool )0);
          if (Xrank[from] == 2) {
            if (board[from + 24] == 13) {
              push_pawn_simple(from + 24);
            }
          }
        }
      }
      if ((board[from + 13] & 1) == 0) {
        if (board[from + 13] != 0) {
          push_pawn(from + 13, (xbool )0);
        }
      }
      if ((board[from + 11] & 1) == 0) {
        if (board[from + 11] != 0) {
          push_pawn(from + 11, (xbool )0);
        }
      }
      if (ep_square == from + 13) {
        push_pawn(from + 13, (xbool )1);
      } else
      if (ep_square == from + 11) {
        push_pawn(from + 11, (xbool )1);
      }
      break;
      case 3: 
      if (board[from - 25] != 0) {
        push_knighT(from - 25);
      }
      if (board[from - 23] != 0) {
        push_knighT(from - 23);
      }
      if (board[from - 14] != 0) {
        push_knighT(from - 14);
      }
      if (board[from - 10] != 0) {
        push_knighT(from - 10);
      }
      if (board[from + 10] != 0) {
        push_knighT(from + 10);
      }
      if (board[from + 14] != 0) {
        push_knighT(from + 14);
      }
      if (board[from + 23] != 0) {
        push_knighT(from + 23);
      }
      if (board[from + 25] != 0) {
        push_knighT(from + 25);
      }
      break;
      case 11: 
      if (board[from - 13] != 0) {
        push_slidE(from - 13);
      }
      if (board[from - 11] != 0) {
        push_slidE(from - 11);
      }
      if (board[from + 11] != 0) {
        push_slidE(from + 11);
      }
      if (board[from + 13] != 0) {
        push_slidE(from + 13);
      }
      break;
      case 7: 
      if (board[from - 12] != 0) {
        push_slidE(from - 12);
      }
      if (board[from - 1] != 0) {
        push_slidE(from - 1);
      }
      if (board[from + 1] != 0) {
        push_slidE(from + 1);
      }
      if (board[from + 12] != 0) {
        push_slidE(from + 12);
      }
      break;
      case 9: 
      if (board[from - 13] != 0) {
        push_slidE(from - 13);
      }
      if (board[from - 12] != 0) {
        push_slidE(from - 12);
      }
      if (board[from - 11] != 0) {
        push_slidE(from - 11);
      }
      if (board[from - 1] != 0) {
        push_slidE(from - 1);
      }
      if (board[from + 1] != 0) {
        push_slidE(from + 1);
      }
      if (board[from + 11] != 0) {
        push_slidE(from + 11);
      }
      if (board[from + 12] != 0) {
        push_slidE(from + 12);
      }
      if (board[from + 13] != 0) {
        push_slidE(from + 13);
      }
      break;
      case 5: 
      push_king(from - 13);
      push_king(from - 12);
      push_king(from - 11);
      push_king(from - 1);
      push_king(from + 1);
      push_king(from + 11);
      push_king(from + 12);
      push_king(from + 13);
      if (from == 30) {
        if (! moved[30]) {
          if (! captures) {
            if (Variant != 3) {
              goto _L___0;
            } else
            if (Giveaway == 1) {
              _L___0: /* CIL Label */ 
              if (! moved[33]) {
                if (board[33] == 7) {
                  if (board[31] == 13) {
                    if (board[32] == 13) {
                      push_king_castle(from + 2, 1);
                    }
                  }
                }
              }
              if (! moved[26]) {
                if (board[26] == 7) {
                  if (board[27] == 13) {
                    if (board[28] == 13) {
                      if (board[29] == 13) {
                        push_king_castle(from - 2, 2);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      break;
      default: 
      break;
      }
      __Cont: /* CIL Label */ 
      j ++;
    }
  } else {
    a = 1;
    j = 1;
    while (1) {
      if (a <= piece_count) {
        if (Variant != 3) {
          if (! (! kingcap)) {
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
        if (Variant == 3) {
          if (! ((unsigned int )fcaptures == (unsigned int )captures)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      i = pieces[j];
      if (! i) {
        goto __Cont___0;
      } else {
        a ++;
      }
      from = i;
      gfrom = i;
      switch (board[from]) {
      case 2: 
      if (board[from - 12] == 13) {
        if (Xrank[from] == 2) {
          if (Variant != 3) {
            if (Variant != 4) {
              push_pawn(from - 12, (xbool )0);
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
        if (! captures) {
          push_pawn(from - 12, (xbool )0);
          if (Xrank[from] == 7) {
            if (board[from - 24] == 13) {
              push_pawn_simple(from - 24);
            }
          }
        }
      }
      if ((board[from - 13] & 1) == 1) {
        if (board[from - 13] != 13) {
          push_pawn(from - 13, (xbool )0);
        }
      }
      if ((board[from - 11] & 1) == 1) {
        if (board[from - 11] != 13) {
          push_pawn(from - 11, (xbool )0);
        }
      }
      if (ep_square == from - 13) {
        push_pawn(from - 13, (xbool )1);
      } else
      if (ep_square == from - 11) {
        push_pawn(from - 11, (xbool )1);
      }
      break;
      case 4: 
      if (board[from - 25] != 0) {
        push_knighT(from - 25);
      }
      if (board[from - 23] != 0) {
        push_knighT(from - 23);
      }
      if (board[from - 14] != 0) {
        push_knighT(from - 14);
      }
      if (board[from - 10] != 0) {
        push_knighT(from - 10);
      }
      if (board[from + 10] != 0) {
        push_knighT(from + 10);
      }
      if (board[from + 14] != 0) {
        push_knighT(from + 14);
      }
      if (board[from + 23] != 0) {
        push_knighT(from + 23);
      }
      if (board[from + 25] != 0) {
        push_knighT(from + 25);
      }
      break;
      case 12: 
      if (board[from - 13] != 0) {
        push_slidE(from - 13);
      }
      if (board[from - 11] != 0) {
        push_slidE(from - 11);
      }
      if (board[from + 11] != 0) {
        push_slidE(from + 11);
      }
      if (board[from + 13] != 0) {
        push_slidE(from + 13);
      }
      break;
      case 8: 
      if (board[from - 12] != 0) {
        push_slidE(from - 12);
      }
      if (board[from - 1] != 0) {
        push_slidE(from - 1);
      }
      if (board[from + 1] != 0) {
        push_slidE(from + 1);
      }
      if (board[from + 12] != 0) {
        push_slidE(from + 12);
      }
      break;
      case 10: 
      if (board[from - 13] != 0) {
        push_slidE(from - 13);
      }
      if (board[from - 12] != 0) {
        push_slidE(from - 12);
      }
      if (board[from - 11] != 0) {
        push_slidE(from - 11);
      }
      if (board[from - 1] != 0) {
        push_slidE(from - 1);
      }
      if (board[from + 1] != 0) {
        push_slidE(from + 1);
      }
      if (board[from + 11] != 0) {
        push_slidE(from + 11);
      }
      if (board[from + 12] != 0) {
        push_slidE(from + 12);
      }
      if (board[from + 13] != 0) {
        push_slidE(from + 13);
      }
      break;
      case 6: 
      push_king(from - 13);
      push_king(from - 12);
      push_king(from - 11);
      push_king(from - 1);
      push_king(from + 1);
      push_king(from + 11);
      push_king(from + 12);
      push_king(from + 13);
      if (from == 114) {
        if (! moved[114]) {
          if (! captures) {
            if (Variant != 3) {
              goto _L___3;
            } else
            if (Giveaway == 1) {
              _L___3: /* CIL Label */ 
              if (! moved[117]) {
                if (board[117] == 8) {
                  if (board[115] == 13) {
                    if (board[116] == 13) {
                      push_king_castle(from + 2, 3);
                    }
                  }
                }
              }
              if (! moved[110]) {
                if (board[110] == 8) {
                  if (board[111] == 13) {
                    if (board[112] == 13) {
                      if (board[113] == 13) {
                        push_king_castle(from - 2, 4);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      break;
      default: 
      break;
      }
      __Cont___0: /* CIL Label */ 
      j ++;
    }
  }
  if (Variant == 0) {
    goto _L___8;
  } else
  if (Variant == 1) {
    _L___8: /* CIL Label */ 
    if (! captures) {
      if (! kingcap) {
        if (white_to_move) {
          if (holding[0][1]) {
            goto _L___7;
          } else
          if (holding[0][3]) {
            goto _L___7;
          } else
          if (holding[0][11]) {
            goto _L___7;
          } else
          if (holding[0][9]) {
            goto _L___7;
          } else
          if (holding[0][7]) {
            _L___7: /* CIL Label */ 
            from = 26;
            while (from < 118) {
              gfrom = from;
              switch (board[from]) {
              case 0: 
              from += 3;
              goto __Cont___1;
              case 13: 
              if (holding[0][1]) {
                if (Xrank[from] != 8) {
                  if (Xrank[from] != 1) {
                    try_drop(1);
                  }
                }
              }
              if (holding[0][3]) {
                try_drop(3);
              }
              if (holding[0][11]) {
                try_drop(11);
              }
              if (holding[0][7]) {
                try_drop(7);
              }
              if (holding[0][9]) {
                try_drop(9);
              }
              }
              __Cont___1: /* CIL Label */ 
              from ++;
            }
          } else {
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
        if (! white_to_move) {
          if (holding[1][2]) {
            goto _L___5;
          } else
          if (holding[1][4]) {
            goto _L___5;
          } else
          if (holding[1][12]) {
            goto _L___5;
          } else
          if (holding[1][10]) {
            goto _L___5;
          } else
          if (holding[1][8]) {
            _L___5: /* CIL Label */ 
            from = 26;
            while (from < 118) {
              gfrom = from;
              switch (board[from]) {
              case 0: 
              from += 3;
              goto __Cont___2;
              case 13: 
              if (holding[1][2]) {
                if (Xrank[from] != 8) {
                  if (Xrank[from] != 1) {
                    try_drop(2);
                  }
                }
              }
              if (holding[1][4]) {
                try_drop(4);
              }
              if (holding[1][12]) {
                try_drop(12);
              }
              if (holding[1][8]) {
                try_drop(8);
              }
              if (holding[1][10]) {
                try_drop(10);
              }
              }
              __Cont___2: /* CIL Label */ 
              from ++;
            }
          }
        }
      }
    }
  }
  if (Variant == 3) {
    if ((unsigned int )fcaptures == 1U) {
      if ((unsigned int )captures == 0U) {
        captures = (xbool )1;
        numb_moves = 0;
        goto restart;
      }
    }
  }
  if (Variant == 3) {
    kingcap = 0;
  }
  return;
}
}
xbool in_check(void) 
{ 
  xbool tmp ;
  xbool tmp___0 ;

  {
  if (Variant == 3) {
    return ((xbool )0);
  }
  if (white_to_move == 1) {
    tmp = is_attacked(wking_loc, 0);
    if (tmp) {
      return ((xbool )1);
    }
  } else {
    tmp___0 = is_attacked(bking_loc, 1);
    if (tmp___0) {
      return ((xbool )1);
    }
  }
  return ((xbool )0);
}
}
static int const   knight_o___3[8]  = 
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
xbool f_in_check(move_s *moves , int m ) 
{ 
  int target ;
  int from ;
  int l ;
  xbool tmp ;
  xbool tmp___0 ;

  {
  target = (moves + m)->target;
  from = (moves + m)->from;
  if (Variant == 3) {
    return ((xbool )0);
  }
  if (white_to_move == 1) {
    switch (board[target]) {
    case 2: 
    if (board[target - 11] == 5) {
      return ((xbool )1);
    } else
    if (board[target - 13] == 5) {
      return ((xbool )1);
    }
    break;
    case 12: 
    if (Xdiagl[target] == Xdiagl[wking_loc]) {
      if (wking_loc < target) {
        l = wking_loc + 13;
        while (board[l] == 13) {
          l += 13;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc - 13;
        while (board[l] == 13) {
          l -= 13;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    } else
    if (Xdiagr[target] == Xdiagr[wking_loc]) {
      if (wking_loc < target) {
        l = wking_loc + 11;
        while (board[l] == 13) {
          l += 11;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc - 11;
        while (board[l] == 13) {
          l -= 11;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    }
    break;
    case 8: 
    if (Xfile[target] == Xfile[wking_loc]) {
      if (wking_loc < target) {
        l = wking_loc + 12;
        while (board[l] == 13) {
          l += 12;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc - 12;
        while (board[l] == 13) {
          l -= 12;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    } else
    if (Xrank[target] == Xrank[wking_loc]) {
      if (wking_loc < target) {
        l = wking_loc + 1;
        while (board[l] == 13) {
          l ++;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc - 1;
        while (board[l] == 13) {
          l --;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    }
    break;
    case 4: 
    l = 0;
    while (l < 8) {
      if (wking_loc + (int )knight_o___3[l] == target) {
        return ((xbool )1);
      }
      l ++;
    }
    break;
    case 10: 
    if (Xfile[target] == Xfile[wking_loc]) {
      if (wking_loc < target) {
        l = wking_loc + 12;
        while (board[l] == 13) {
          l += 12;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc - 12;
        while (board[l] == 13) {
          l -= 12;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    } else
    if (Xrank[target] == Xrank[wking_loc]) {
      if (wking_loc < target) {
        l = wking_loc + 1;
        while (board[l] == 13) {
          l ++;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc - 1;
        while (board[l] == 13) {
          l --;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    } else
    if (Xdiagl[target] == Xdiagl[wking_loc]) {
      if (wking_loc < target) {
        l = wking_loc + 13;
        while (board[l] == 13) {
          l += 13;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc - 13;
        while (board[l] == 13) {
          l -= 13;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    } else
    if (Xdiagr[target] == Xdiagr[wking_loc]) {
      if (wking_loc < target) {
        l = wking_loc + 11;
        while (board[l] == 13) {
          l += 11;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc - 11;
        while (board[l] == 13) {
          l -= 11;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    }
    break;
    case 6: 
    if ((moves + m)->castled) {
      tmp = is_attacked(wking_loc, 0);
      if (tmp) {
        return ((xbool )1);
      } else {
        return ((xbool )0);
      }
    }
    break;
    }
    if (from == 0) {
      return ((xbool )0);
    }
    if (Xrank[from] == Xrank[wking_loc]) {
      if (wking_loc > from) {
        l = wking_loc - 1;
        while (board[l] == 13) {
          l --;
        }
        if (board[l] == 8) {
          return ((xbool )1);
        } else
        if (board[l] == 10) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc + 1;
        while (board[l] == 13) {
          l ++;
        }
        if (board[l] == 8) {
          return ((xbool )1);
        } else
        if (board[l] == 10) {
          return ((xbool )1);
        }
      }
    } else
    if (Xfile[from] == Xfile[wking_loc]) {
      if (wking_loc > from) {
        l = wking_loc - 12;
        while (board[l] == 13) {
          l -= 12;
        }
        if (board[l] == 8) {
          return ((xbool )1);
        } else
        if (board[l] == 10) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc + 12;
        while (board[l] == 13) {
          l += 12;
        }
        if (board[l] == 8) {
          return ((xbool )1);
        } else
        if (board[l] == 10) {
          return ((xbool )1);
        }
      }
    } else
    if (Xdiagl[from] == Xdiagl[wking_loc]) {
      if (wking_loc > from) {
        l = wking_loc - 13;
        while (board[l] == 13) {
          l -= 13;
        }
        if (board[l] == 12) {
          return ((xbool )1);
        } else
        if (board[l] == 10) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc + 13;
        while (board[l] == 13) {
          l += 13;
        }
        if (board[l] == 12) {
          return ((xbool )1);
        } else
        if (board[l] == 10) {
          return ((xbool )1);
        }
      }
    } else
    if (Xdiagr[from] == Xdiagr[wking_loc]) {
      if (wking_loc > from) {
        l = wking_loc - 11;
        while (board[l] == 13) {
          l -= 11;
        }
        if (board[l] == 12) {
          return ((xbool )1);
        } else
        if (board[l] == 10) {
          return ((xbool )1);
        }
      } else {
        l = wking_loc + 11;
        while (board[l] == 13) {
          l += 11;
        }
        if (board[l] == 12) {
          return ((xbool )1);
        } else
        if (board[l] == 10) {
          return ((xbool )1);
        }
      }
    }
    return ((xbool )0);
  } else {
    switch (board[target]) {
    case 1: 
    if (board[target + 11] == 6) {
      return ((xbool )1);
    } else
    if (board[target + 13] == 6) {
      return ((xbool )1);
    }
    break;
    case 11: 
    if (Xdiagl[target] == Xdiagl[bking_loc]) {
      if (bking_loc < target) {
        l = bking_loc + 13;
        while (board[l] == 13) {
          l += 13;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc - 13;
        while (board[l] == 13) {
          l -= 13;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    } else
    if (Xdiagr[target] == Xdiagr[bking_loc]) {
      if (bking_loc < target) {
        l = bking_loc + 11;
        while (board[l] == 13) {
          l += 11;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc - 11;
        while (board[l] == 13) {
          l -= 11;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    }
    break;
    case 7: 
    if (Xfile[target] == Xfile[bking_loc]) {
      if (bking_loc < target) {
        l = bking_loc + 12;
        while (board[l] == 13) {
          l += 12;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc - 12;
        while (board[l] == 13) {
          l -= 12;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    } else
    if (Xrank[target] == Xrank[bking_loc]) {
      if (bking_loc < target) {
        l = bking_loc + 1;
        while (board[l] == 13) {
          l ++;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc - 1;
        while (board[l] == 13) {
          l --;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    }
    break;
    case 3: 
    l = 0;
    while (l < 8) {
      if (bking_loc + (int )knight_o___3[l] == target) {
        return ((xbool )1);
      }
      l ++;
    }
    break;
    case 9: 
    if (Xfile[target] == Xfile[bking_loc]) {
      if (bking_loc < target) {
        l = bking_loc + 12;
        while (board[l] == 13) {
          l += 12;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc - 12;
        while (board[l] == 13) {
          l -= 12;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    } else
    if (Xrank[target] == Xrank[bking_loc]) {
      if (bking_loc < target) {
        l = bking_loc + 1;
        while (board[l] == 13) {
          l ++;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc - 1;
        while (board[l] == 13) {
          l --;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    } else
    if (Xdiagl[target] == Xdiagl[bking_loc]) {
      if (bking_loc < target) {
        l = bking_loc + 13;
        while (board[l] == 13) {
          l += 13;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc - 13;
        while (board[l] == 13) {
          l -= 13;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    } else
    if (Xdiagr[target] == Xdiagr[bking_loc]) {
      if (bking_loc < target) {
        l = bking_loc + 11;
        while (board[l] == 13) {
          l += 11;
        }
        if (l == target) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc - 11;
        while (board[l] == 13) {
          l -= 11;
        }
        if (l == target) {
          return ((xbool )1);
        }
      }
    }
    break;
    case 5: 
    if ((moves + m)->castled) {
      tmp___0 = is_attacked(bking_loc, 1);
      if (tmp___0) {
        return ((xbool )1);
      } else {
        return ((xbool )0);
      }
    }
    break;
    }
    if (from == 0) {
      return ((xbool )0);
    }
    if (Xrank[from] == Xrank[bking_loc]) {
      if (bking_loc > from) {
        l = bking_loc - 1;
        while (board[l] == 13) {
          l --;
        }
        if (board[l] == 7) {
          return ((xbool )1);
        } else
        if (board[l] == 9) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc + 1;
        while (board[l] == 13) {
          l ++;
        }
        if (board[l] == 7) {
          return ((xbool )1);
        } else
        if (board[l] == 9) {
          return ((xbool )1);
        }
      }
    } else
    if (Xfile[from] == Xfile[bking_loc]) {
      if (bking_loc > from) {
        l = bking_loc - 12;
        while (board[l] == 13) {
          l -= 12;
        }
        if (board[l] == 7) {
          return ((xbool )1);
        } else
        if (board[l] == 9) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc + 12;
        while (board[l] == 13) {
          l += 12;
        }
        if (board[l] == 7) {
          return ((xbool )1);
        } else
        if (board[l] == 9) {
          return ((xbool )1);
        }
      }
    } else
    if (Xdiagl[from] == Xdiagl[bking_loc]) {
      if (bking_loc > from) {
        l = bking_loc - 13;
        while (board[l] == 13) {
          l -= 13;
        }
        if (board[l] == 11) {
          return ((xbool )1);
        } else
        if (board[l] == 9) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc + 13;
        while (board[l] == 13) {
          l += 13;
        }
        if (board[l] == 11) {
          return ((xbool )1);
        } else
        if (board[l] == 9) {
          return ((xbool )1);
        }
      }
    } else
    if (Xdiagr[from] == Xdiagr[bking_loc]) {
      if (bking_loc > from) {
        l = bking_loc - 11;
        while (board[l] == 13) {
          l -= 11;
        }
        if (board[l] == 11) {
          return ((xbool )1);
        } else
        if (board[l] == 9) {
          return ((xbool )1);
        }
      } else {
        l = bking_loc + 11;
        while (board[l] == 13) {
          l += 11;
        }
        if (board[l] == 11) {
          return ((xbool )1);
        } else
        if (board[l] == 9) {
          return ((xbool )1);
        }
      }
    }
    return ((xbool )0);
  }
}
}
static int const   knight_o___4[8]  = 
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
int extended_in_check(void) 
{ 
  register int sq ;
  xbool tmp ;
  xbool tmp___0 ;

  {
  if (Variant == 3) {
    return (0);
  }
  if (white_to_move == 1) {
    sq = board[wking_loc - 12];
    if (sq == 8) {
      return (2);
    } else
    if (sq == 10) {
      return (2);
    }
    sq = board[wking_loc - 1];
    if (sq == 8) {
      return (2);
    } else
    if (sq == 10) {
      return (2);
    }
    sq = board[wking_loc + 1];
    if (sq == 8) {
      return (2);
    } else
    if (sq == 10) {
      return (2);
    }
    sq = board[wking_loc + 12];
    if (sq == 8) {
      return (2);
    } else
    if (sq == 10) {
      return (2);
    }
    sq = board[wking_loc + 13];
    if (sq == 12) {
      return (2);
    } else
    if (sq == 10) {
      return (2);
    } else
    if (sq == 2) {
      return (2);
    }
    sq = board[wking_loc + 11];
    if (sq == 12) {
      return (2);
    } else
    if (sq == 10) {
      return (2);
    } else
    if (sq == 2) {
      return (2);
    }
    sq = board[wking_loc - 11];
    if (sq == 12) {
      return (2);
    } else
    if (sq == 10) {
      return (2);
    }
    sq = board[wking_loc - 13];
    if (sq == 12) {
      return (2);
    } else
    if (sq == 10) {
      return (2);
    }
    sq = 0;
    while (sq < 8) {
      if (board[wking_loc + (int )knight_o___4[sq]] == 4) {
        return (2);
      }
      sq ++;
    }
    tmp = is_attacked(wking_loc, 0);
    if (tmp) {
      if (Variant == 2) {
        return (2);
      } else
      if (Variant == 4) {
        return (2);
      } else {
        return (1);
      }
    }
  } else {
    sq = board[bking_loc - 12];
    if (sq == 7) {
      return (2);
    } else
    if (sq == 9) {
      return (2);
    }
    sq = board[bking_loc - 1];
    if (sq == 7) {
      return (2);
    } else
    if (sq == 9) {
      return (2);
    }
    sq = board[bking_loc + 1];
    if (sq == 7) {
      return (2);
    } else
    if (sq == 9) {
      return (2);
    }
    sq = board[bking_loc + 12];
    if (sq == 7) {
      return (2);
    } else
    if (sq == 9) {
      return (2);
    }
    sq = board[bking_loc - 13];
    if (sq == 11) {
      return (2);
    } else
    if (sq == 9) {
      return (2);
    } else
    if (sq == 1) {
      return (2);
    }
    sq = board[bking_loc - 11];
    if (sq == 11) {
      return (2);
    } else
    if (sq == 9) {
      return (2);
    } else
    if (sq == 1) {
      return (2);
    }
    sq = board[bking_loc + 11];
    if (sq == 11) {
      return (2);
    } else
    if (sq == 9) {
      return (2);
    }
    sq = board[bking_loc + 13];
    if (sq == 11) {
      return (2);
    } else
    if (sq == 9) {
      return (2);
    }
    sq = 0;
    while (sq < 8) {
      if (board[bking_loc + (int )knight_o___4[sq]] == 3) {
        return (2);
      }
      sq ++;
    }
    tmp___0 = is_attacked(bking_loc, 1);
    if (tmp___0) {
      if (Variant == 2) {
        return (2);
      } else
      if (Variant == 4) {
        return (2);
      } else {
        return (1);
      }
    }
  }
  return (0);
}
}
void make(move_s *moves , int i ) 
{ 
  int ep ;
  int from ;
  int target ;
  int captured ;
  int promoted ;
  int castled ;
  int find_slot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  ep = (moves + i)->ep;
  from = (moves + i)->from;
  target = (moves + i)->target;
  captured = (moves + i)->captured;
  promoted = (moves + i)->promoted;
  castled = (moves + i)->castled;
  path_x[ply].epsq = ep_square;
  ep_square = 0;
  path_x[ply].fifty = fifty;
  if (board[from] == 1) {
    fifty = 0;
  } else
  if (board[from] == 2) {
    fifty = 0;
  } else
  if (board[target] != 13) {
    fifty = 0;
  } else {
    fifty ++;
  }
  if (from == 0) {
    piece_count ++;
    find_slot = 1;
    while (pieces[find_slot] != 0) {
      find_slot ++;
    }
    pieces[find_slot] = target;
    path_x[ply].was_promoted = is_promoted[find_slot];
    is_promoted[find_slot] = 0;
    squares[target] = find_slot;
    if (white_to_move) {
      tmp = 0;
    } else {
      tmp = 1;
    }
    DropremoveHolding(promoted, tmp);
    Material += material[promoted];
    board[target] = promoted;
    hash ^= zobrist[promoted][target];
    white_to_move ^= 1;
    ply ++;
    return;
  } else {
    path_x[ply].was_promoted = is_promoted[squares[target]];
    path_x[ply].cap_num = squares[target];
    pieces[squares[target]] = 0;
    pieces[squares[from]] = target;
    squares[target] = squares[from];
    squares[from] = 0;
    if (! ep) {
      switch (board[target]) {
      case 13: 
      break;
      default: 
      if (Variant == 1) {
        goto _L;
      } else
      if (Variant == 0) {
        _L: /* CIL Label */ 
        if (path_x[ply].was_promoted) {
          if (white_to_move) {
            tmp___0 = 0;
          } else {
            tmp___0 = 1;
          }
          tmp___1 = SwitchPromoted(board[target]);
          addHolding(tmp___1, tmp___0);
        } else {
          if (white_to_move) {
            tmp___2 = 0;
          } else {
            tmp___2 = 1;
          }
          tmp___3 = SwitchColor(board[target]);
          addHolding(tmp___3, tmp___2);
        }
      }
      Material -= material[board[target]];
      hash ^= zobrist[board[target]][target];
      piece_count --;
      break;
      }
    }
    if (board[from] == 1) {
      if (promoted) {
        board[target] = promoted;
        board[from] = 13;
        (moved[target]) ++;
        (moved[from]) ++;
        white_to_move ^= 1;
        is_promoted[squares[target]] = 1;
        hash ^= zobrist[1][from];
        hash ^= zobrist[promoted][target];
        Material -= material[1];
        Material += material[promoted];
        ply ++;
        return;
      }
      if (ep) {
        hash ^= zobrist[1][from];
        hash ^= zobrist[2][target - 12];
        hash ^= zobrist[1][target];
        Material -= material[2];
        board[target] = 1;
        board[from] = 13;
        addHolding(1, 0);
        piece_count --;
        board[target - 12] = 13;
        (moved[target]) ++;
        (moved[from]) ++;
        (moved[target - 12]) ++;
        white_to_move ^= 1;
        path_x[ply].cap_num = squares[target - 12];
        pieces[squares[target - 12]] = 0;
        squares[target - 12] = 0;
        ply ++;
        return;
      }
      if (target == from + 24) {
        ep_square = from + 12;
      }
      hash ^= zobrist[1][from];
      hash ^= zobrist[1][target];
      board[target] = 1;
      board[from] = 13;
      (moved[target]) ++;
      (moved[from]) ++;
      white_to_move ^= 1;
      ply ++;
      return;
    }
    if (board[from] == 2) {
      if (promoted) {
        board[target] = promoted;
        board[from] = 13;
        (moved[target]) ++;
        (moved[from]) ++;
        white_to_move ^= 1;
        is_promoted[squares[target]] = 1;
        hash ^= zobrist[2][from];
        hash ^= zobrist[promoted][target];
        Material -= material[2];
        Material += material[promoted];
        ply ++;
        return;
      }
      if (ep) {
        hash ^= zobrist[2][from];
        hash ^= zobrist[1][target + 12];
        hash ^= zobrist[2][target];
        Material -= material[1];
        board[target] = 2;
        board[from] = 13;
        addHolding(2, 1);
        piece_count --;
        board[target + 12] = 13;
        (moved[target]) ++;
        (moved[from]) ++;
        (moved[target + 12]) ++;
        white_to_move ^= 1;
        path_x[ply].cap_num = squares[target + 12];
        pieces[squares[target + 12]] = 0;
        squares[target + 12] = 0;
        ply ++;
        return;
      }
      if (target == from - 24) {
        ep_square = from - 12;
      }
      board[target] = 2;
      board[from] = 13;
      (moved[target]) ++;
      (moved[from]) ++;
      white_to_move ^= 1;
      hash ^= zobrist[2][from];
      hash ^= zobrist[2][target];
      ply ++;
      return;
    }
    if (board[from] != 5) {
      if (board[from] != 6) {
        hash ^= zobrist[board[from]][from];
        hash ^= zobrist[board[from]][target];
        board[target] = board[from];
        board[from] = 13;
        (moved[target]) ++;
        (moved[from]) ++;
        white_to_move ^= 1;
        ply ++;
        return;
      }
    }
    if (board[from] == 5) {
      wking_loc = target;
      board[target] = 5;
      board[from] = 13;
      (moved[target]) ++;
      (moved[from]) ++;
      white_to_move ^= 1;
      hash ^= zobrist[5][from];
      hash ^= zobrist[5][target];
      if (castled == 1) {
        board[33] = 13;
        board[31] = 7;
        (moved[33]) ++;
        (moved[31]) ++;
        white_castled = 1;
        pieces[squares[33]] = 31;
        squares[31] = squares[33];
        squares[33] = 0;
        hash ^= zobrist[7][33];
        hash ^= zobrist[7][31];
        ply ++;
        return;
      } else
      if (castled == 2) {
        board[26] = 13;
        board[29] = 7;
        (moved[26]) ++;
        (moved[29]) ++;
        white_castled = 2;
        pieces[squares[26]] = 29;
        squares[29] = squares[26];
        squares[26] = 0;
        hash ^= zobrist[7][26];
        hash ^= zobrist[7][29];
        ply ++;
        return;
      }
      ply ++;
      return;
    } else {
      bking_loc = target;
      board[target] = 6;
      board[from] = 13;
      (moved[target]) ++;
      (moved[from]) ++;
      white_to_move ^= 1;
      hash ^= zobrist[6][from];
      hash ^= zobrist[6][target];
      if (castled == 3) {
        board[117] = 13;
        board[115] = 8;
        (moved[117]) ++;
        (moved[115]) ++;
        black_castled = 3;
        pieces[squares[117]] = 115;
        squares[115] = squares[117];
        squares[117] = 0;
        hash ^= zobrist[8][117];
        hash ^= zobrist[8][115];
        ply ++;
        return;
      } else
      if (castled == 4) {
        board[110] = 13;
        board[113] = 8;
        (moved[110]) ++;
        (moved[113]) ++;
        black_castled = 4;
        pieces[squares[110]] = 113;
        squares[113] = squares[110];
        squares[110] = 0;
        hash ^= zobrist[8][110];
        hash ^= zobrist[8][113];
        ply ++;
        return;
      }
    }
    ply ++;
    return;
  }
}
}
void add_move(int Ptarget , int Ppromoted ) 
{ 


  {
  (genfor + numb_moves)->from = gfrom;
  (genfor + numb_moves)->target = Ptarget;
  (genfor + numb_moves)->captured = 13;
  (genfor + numb_moves)->castled = 0;
  (genfor + numb_moves)->promoted = Ppromoted;
  (genfor + numb_moves)->ep = 0;
  numb_moves ++;
  return;
}
}
void add_capture(int Ptarget , int Pcaptured , int Ppromoted , int Pep ) 
{ 


  {
  if (Variant != 3) {
    if (Pcaptured == 5) {
      kingcap = 1;
      return;
    } else
    if (Pcaptured == 6) {
      kingcap = 1;
      return;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (Pcaptured != 13) {
    fcaptures = (xbool )1;
  }
  (genfor + numb_moves)->from = gfrom;
  (genfor + numb_moves)->target = Ptarget;
  (genfor + numb_moves)->captured = Pcaptured;
  (genfor + numb_moves)->castled = 0;
  (genfor + numb_moves)->promoted = Ppromoted;
  (genfor + numb_moves)->ep = Pep;
  numb_moves ++;
  return;
}
}
void try_drop(int ptype ) 
{ 


  {
  (genfor + numb_moves)->from = 0;
  (genfor + numb_moves)->target = gfrom;
  (genfor + numb_moves)->captured = 13;
  (genfor + numb_moves)->castled = 0;
  (genfor + numb_moves)->promoted = ptype;
  (genfor + numb_moves)->ep = 0;
  numb_moves ++;
  return;
}
}
void push_king_castle(int Ptarget , int Pcastle_type ) 
{ 


  {
  (genfor + numb_moves)->from = gfrom;
  (genfor + numb_moves)->target = Ptarget;
  (genfor + numb_moves)->captured = 13;
  (genfor + numb_moves)->castled = Pcastle_type;
  (genfor + numb_moves)->promoted = 0;
  (genfor + numb_moves)->ep = 0;
  numb_moves ++;
  return;
}
}
void push_king(int target ) 
{ 


  {
  if (board[target] == 0) {
    return;
  }
  if (board[target] == 13) {
    if (captures) {
      return;
    }
  }
  if (board[target] == 13) {
    add_move(target, 0);
    return;
  } else
  if ((board[target] & 1) != (board[gfrom] & 1)) {
    add_capture(target, board[target], 0, 0);
    return;
  }
  return;
}
}
void push_knighT(int target ) 
{ 


  {
  if (board[target] == 13) {
    if (captures) {
      return;
    }
  }
  if (board[target] == 13) {
    add_move(target, 0);
    return;
  } else
  if ((board[target] & 1) != (board[gfrom] & 1)) {
    add_capture(target, board[target], 0, 0);
    return;
  }
  return;
}
}
void push_pawn(int target , xbool is_ep ) 
{ 
  int captured_piece ;

  {
  if (is_ep) {
    if (board[gfrom] == 1) {
      add_capture(target, 2, 0, 1);
      return;
    } else {
      add_capture(target, 1, 0, 1);
      return;
    }
  }
  captured_piece = board[target];
  if (board[gfrom] == 1) {
    if (Xrank[gfrom] == 7) {
      add_capture(target, captured_piece, 9, 0);
      add_capture(target, captured_piece, 7, 0);
      add_capture(target, captured_piece, 11, 0);
      add_capture(target, captured_piece, 3, 0);
      if (Variant == 3) {
        add_capture(target, captured_piece, 5, 0);
      }
      return;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (board[gfrom] == 2) {
    if (Xrank[gfrom] == 2) {
      add_capture(target, captured_piece, 10, 0);
      add_capture(target, captured_piece, 8, 0);
      add_capture(target, captured_piece, 12, 0);
      add_capture(target, captured_piece, 4, 0);
      if (Variant == 3) {
        add_capture(target, captured_piece, 6, 0);
      }
      return;
    } else {
      add_capture(target, captured_piece, 0, 0);
      return;
    }
  } else {
    add_capture(target, captured_piece, 0, 0);
    return;
  }
}
}
void push_pawn_simple(int target ) 
{ 


  {
  add_move(target, 0);
  return;
}
}
void push_slidE(int target ) 
{ 
  int offset ;
  int mycolor ;

  {
  offset = target - gfrom;
  mycolor = board[gfrom] & 1;
  while (1) {
    if (board[target] == 13) {
      if (! captures) {
        add_move(target, 0);
      }
      target += offset;
    } else
    if ((board[target] & 1) != mycolor) {
      add_capture(target, board[target], 0, 0);
      break;
    } else {
      break;
    }
    if (! (board[target] != 0)) {
      break;
    }
  }
  return;
}
}
void unmake(move_s *moves , int i ) 
{ 
  int ep ;
  int from ;
  int target ;
  int captured ;
  int promoted ;
  int castled ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  ep = (moves + i)->ep;
  from = (moves + i)->from;
  target = (moves + i)->target;
  captured = (moves + i)->captured;
  promoted = (moves + i)->promoted;
  castled = (moves + i)->castled;
  ply --;
  ep_square = path_x[ply].epsq;
  fifty = path_x[ply].fifty;
  if (from == 0) {
    pieces[squares[target]] = 0;
    is_promoted[squares[target]] = path_x[ply].was_promoted;
    squares[target] = 0;
    piece_count --;
    if (white_to_move) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    DropaddHolding(promoted, tmp);
    Material -= material[promoted];
    board[target] = captured;
    hash ^= zobrist[promoted][target];
    white_to_move ^= 1;
    return;
  } else {
    squares[from] = squares[target];
    squares[target] = path_x[ply].cap_num;
    pieces[squares[target]] = target;
    pieces[squares[from]] = from;
    is_promoted[squares[target]] = path_x[ply].was_promoted;
    if (! ep) {
      switch (captured) {
      case 13: 
      break;
      default: 
      if (Variant == 1) {
        goto _L;
      } else
      if (Variant == 0) {
        _L: /* CIL Label */ 
        if (is_promoted[squares[target]]) {
          if (white_to_move) {
            tmp___0 = 1;
          } else {
            tmp___0 = 0;
          }
          tmp___1 = SwitchPromoted(captured);
          removeHolding(tmp___1, tmp___0);
        } else {
          if (white_to_move) {
            tmp___2 = 1;
          } else {
            tmp___2 = 0;
          }
          tmp___3 = SwitchColor(captured);
          removeHolding(tmp___3, tmp___2);
        }
      }
      hash ^= zobrist[captured][target];
      Material += material[captured];
      piece_count ++;
      break;
      }
    }
    if (board[target] == 1) {
      if (ep) {
        hash ^= zobrist[1][target];
        hash ^= zobrist[1][from];
        hash ^= zobrist[2][target - 12];
        board[target] = 13;
        board[from] = 1;
        Material += material[2];
        removeHolding(1, 0);
        piece_count ++;
        board[target - 12] = 2;
        (moved[target]) --;
        (moved[from]) --;
        (moved[target - 12]) --;
        white_to_move ^= 1;
        squares[target - 12] = path_x[ply].cap_num;
        pieces[path_x[ply].cap_num] = target - 12;
        squares[target] = 0;
        return;
      }
      hash ^= zobrist[1][from];
      hash ^= zobrist[1][target];
      board[target] = captured;
      board[from] = 1;
      (moved[target]) --;
      (moved[from]) --;
      white_to_move ^= 1;
      return;
    }
    if (board[target] == 2) {
      if (ep) {
        hash ^= zobrist[2][target];
        hash ^= zobrist[2][from];
        hash ^= zobrist[1][target + 12];
        board[target] = 13;
        board[from] = 2;
        Material += material[1];
        removeHolding(2, 1);
        piece_count ++;
        board[target + 12] = 1;
        (moved[target]) --;
        (moved[from]) --;
        (moved[target + 12]) --;
        white_to_move ^= 1;
        squares[target + 12] = path_x[ply].cap_num;
        pieces[path_x[ply].cap_num] = target + 12;
        squares[target] = 0;
        return;
      }
      hash ^= zobrist[2][from];
      hash ^= zobrist[2][target];
      board[target] = captured;
      board[from] = 2;
      (moved[target]) --;
      (moved[from]) --;
      white_to_move ^= 1;
      return;
    }
    if (board[target] != 5) {
      if (board[target] != 6) {
        if (! promoted) {
          board[from] = board[target];
          board[target] = captured;
          (moved[target]) --;
          (moved[from]) --;
          white_to_move ^= 1;
          hash ^= zobrist[board[from]][target];
          hash ^= zobrist[board[from]][from];
          return;
        }
      }
    }
    if (promoted) {
      if (board[target] % 2) {
        board[target] = captured;
        board[from] = 1;
        (moved[target]) --;
        (moved[from]) --;
        white_to_move ^= 1;
        hash ^= zobrist[1][from];
        hash ^= zobrist[promoted][target];
        Material -= material[promoted];
        Material += material[1];
        return;
      }
      board[target] = captured;
      board[from] = 2;
      (moved[target]) --;
      (moved[from]) --;
      white_to_move ^= 1;
      hash ^= zobrist[2][from];
      hash ^= zobrist[promoted][target];
      Material -= material[promoted];
      Material += material[2];
      return;
    }
    if (board[target] == 5) {
      wking_loc = from;
      board[target] = captured;
      board[from] = 5;
      (moved[target]) --;
      (moved[from]) --;
      white_to_move ^= 1;
      hash ^= zobrist[5][from];
      hash ^= zobrist[5][target];
      if (castled == 1) {
        board[33] = 7;
        board[31] = 13;
        (moved[33]) --;
        (moved[31]) --;
        white_castled = 0;
        squares[33] = squares[31];
        squares[31] = 0;
        pieces[squares[33]] = 33;
        hash ^= zobrist[7][33];
        hash ^= zobrist[7][31];
        return;
      } else
      if (castled == 2) {
        board[26] = 7;
        board[29] = 13;
        (moved[26]) --;
        (moved[29]) --;
        white_castled = 0;
        squares[26] = squares[29];
        squares[29] = 0;
        pieces[squares[26]] = 26;
        hash ^= zobrist[7][29];
        hash ^= zobrist[7][26];
        return;
      }
      return;
    } else {
      bking_loc = from;
      board[target] = captured;
      board[from] = 6;
      (moved[target]) --;
      (moved[from]) --;
      white_to_move ^= 1;
      hash ^= zobrist[6][from];
      hash ^= zobrist[6][target];
      if (castled == 3) {
        board[117] = 8;
        board[115] = 13;
        (moved[117]) --;
        (moved[115]) --;
        black_castled = 0;
        squares[117] = squares[115];
        squares[115] = 0;
        pieces[squares[117]] = 117;
        hash ^= zobrist[8][117];
        hash ^= zobrist[8][115];
        return;
      } else
      if (castled == 4) {
        board[110] = 8;
        board[113] = 13;
        (moved[110]) --;
        (moved[113]) --;
        black_castled = 0;
        squares[110] = squares[113];
        squares[113] = 0;
        pieces[squares[110]] = 110;
        hash ^= zobrist[8][110];
        hash ^= zobrist[8][113];
        return;
      }
    }
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-kXa8OeOK.i","-O3")
int maxposdiff  ;
int distance[144][144]  ;
int rookdistance[144][144]  ;
int phase ;
void check_phase(void) ;
int King(int sq , int c ) ;
int Queen(int sq , int c ) ;
int Rook(int sq , int c ) ;
int Bishop(int sq , int c ) ;
int Knight(int sq , int c ) ;
int Pawn(int sq , int c ) ;
int ErrorIt(int sq , int c ) ;
static EVALFUNC evalRoutines[7]  = {      & ErrorIt,      & Pawn,      & Knight,      & King, 
        & Rook,      & Queen,      & Bishop};
int king_locs[2]  ;
int wmat  ;
int bmat  ;
static int sbishop[144]  = 
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -2,      -2, 
        -2,      -2,      -2,      -2, 
        -2,      -2,      0,      0, 
        0,      0,      -2,      8, 
        5,      5,      5,      5, 
        8,      -2,      0,      0, 
        0,      0,      -2,      3, 
        3,      5,      5,      3, 
        3,      -2,      0,      0, 
        0,      0,      -2,      2, 
        5,      4,      4,      5, 
        2,      -2,      0,      0, 
        0,      0,      -2,      2, 
        5,      4,      4,      5, 
        2,      -2,      0,      0, 
        0,      0,      -2,      3, 
        3,      5,      5,      3, 
        3,      -2,      0,      0, 
        0,      0,      -2,      8, 
        5,      5,      5,      5, 
        8,      -2,      0,      0, 
        0,      0,      -2,      -2, 
        -2,      -2,      -2,      -2, 
        -2,      -2,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
static int sknight[144]  = 
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -20,      -10, 
        -10,      -10,      -10,      -10, 
        -10,      -20,      0,      0, 
        0,      0,      -10,      0, 
        0,      3,      3,      0, 
        0,      -10,      0,      0, 
        0,      0,      -10,      0, 
        5,      5,      5,      5, 
        0,      -10,      0,      0, 
        0,      0,      -10,      0, 
        5,      10,      10,      5, 
        0,      -10,      0,      0, 
        0,      0,      -10,      0, 
        5,      10,      10,      5, 
        0,      -10,      0,      0, 
        0,      0,      -10,      0, 
        5,      5,      5,      5, 
        0,      -10,      0,      0, 
        0,      0,      -10,      0, 
        0,      3,      3,      0, 
        0,      -10,      0,      0, 
        0,      0,      -20,      -10, 
        -10,      -10,      -10,      -10, 
        -10,      -20,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
static int swhite_pawn[144]  = 
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      1,      2, 
        3,      10,      10,      3, 
        2,      1,      0,      0, 
        0,      0,      2,      4, 
        6,      12,      12,      6, 
        4,      2,      0,      0, 
        0,      0,      3,      6, 
        9,      14,      14,      9, 
        6,      3,      0,      0, 
        0,      0,      10,      12, 
        14,      16,      16,      14, 
        12,      10,      0,      0, 
        0,      0,      20,      22, 
        24,      26,      26,      24, 
        22,      20,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
static int sblack_pawn[144]  = 
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      20,      22, 
        24,      26,      26,      24, 
        22,      20,      0,      0, 
        0,      0,      10,      12, 
        14,      16,      16,      14, 
        12,      10,      0,      0, 
        0,      0,      3,      6, 
        9,      14,      14,      9, 
        6,      3,      0,      0, 
        0,      0,      2,      4, 
        6,      12,      12,      6, 
        4,      2,      0,      0, 
        0,      0,      1,      2, 
        3,      10,      10,      3, 
        2,      1,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
static int swhite_king[144]  = 
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      2,      14, 
        0,      0,      0,      9, 
        14,      2,      0,      0, 
        0,      0,      -3,      -5, 
        -6,      -6,      -6,      -6, 
        -5,      -3,      0,      0, 
        0,      0,      -5,      -5, 
        -8,      -8,      -8,      -8, 
        -5,      -5,      0,      0, 
        0,      0,      -8,      -8, 
        -13,      -13,      -13,      -13, 
        -8,      -8,      0,      0, 
        0,      0,      -13,      -13, 
        -21,      -21,      -21,      -21, 
        -13,      -13,      0,      0, 
        0,      0,      -21,      -21, 
        -34,      -34,      -34,      -34, 
        -21,      -21,      0,      0, 
        0,      0,      -34,      -34, 
        -55,      -55,      -55,      -55, 
        -34,      -34,      0,      0, 
        0,      0,      -55,      -55, 
        -89,      -89,      -89,      -89, 
        -55,      -55,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
static int sblack_king[144]  = 
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -55,      -55, 
        -89,      -89,      -89,      -89, 
        -55,      -55,      0,      0, 
        0,      0,      -34,      -34, 
        -55,      -55,      -55,      -55, 
        -34,      -34,      0,      0, 
        0,      0,      -21,      -21, 
        -34,      -34,      -34,      -34, 
        -21,      -21,      0,      0, 
        0,      0,      -13,      -13, 
        -21,      -21,      -21,      -21, 
        -13,      -13,      0,      0, 
        0,      0,      -8,      -8, 
        -13,      -13,      -13,      -13, 
        -8,      -8,      0,      0, 
        0,      0,      -5,      -5, 
        -8,      -8,      -8,      -8, 
        -5,      -5,      0,      0, 
        0,      0,      -3,      -5, 
        -6,      -6,      -6,      -6, 
        -5,      -3,      0,      0, 
        0,      0,      2,      14, 
        0,      0,      0,      9, 
        14,      2,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
static int send_king[144]  = 
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -5,      -3, 
        -1,      0,      0,      -1, 
        -3,      -5,      0,      0, 
        0,      0,      -3,      10, 
        10,      10,      10,      10, 
        10,      -3,      0,      0, 
        0,      0,      -1,      10, 
        25,      25,      25,      25, 
        10,      -1,      0,      0, 
        0,      0,      0,      10, 
        25,      50,      50,      25, 
        10,      0,      0,      0, 
        0,      0,      0,      10, 
        25,      50,      50,      25, 
        10,      0,      0,      0, 
        0,      0,      -1,      10, 
        25,      25,      25,      25, 
        10,      -1,      0,      0, 
        0,      0,      -3,      10, 
        10,      10,      10,      10, 
        10,      -3,      0,      0, 
        0,      0,      -5,      -3, 
        -1,      0,      0,      -1, 
        -3,      -5,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
static int const   srev_rank[9]  = 
  {      (int const   )0,      (int const   )8,      (int const   )7,      (int const   )6, 
        (int const   )5,      (int const   )4,      (int const   )3,      (int const   )2, 
        (int const   )1};
int const   std_p_tropism[8]  = 
  {      (int const   )9999,      (int const   )15,      (int const   )10,      (int const   )7, 
        (int const   )2,      (int const   )0,      (int const   )0,      (int const   )0};
int const   std_own_p_tropism[8]  = 
  {      (int const   )9999,      (int const   )30,      (int const   )10,      (int const   )2, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   std_r_tropism[16]  = 
  {      (int const   )9999,      (int const   )0,      (int const   )15,      (int const   )5, 
        (int const   )2,      (int const   )1,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
int const   std_n_tropism[8]  = 
  {      (int const   )9999,      (int const   )14,      (int const   )9,      (int const   )6, 
        (int const   )1,      (int const   )0,      (int const   )0,      (int const   )0};
int const   std_q_tropism[8]  = 
  {      (int const   )9999,      (int const   )200,      (int const   )50,      (int const   )15, 
        (int const   )3,      (int const   )2,      (int const   )1,      (int const   )0};
int const   std_b_tropism[8]  = 
  {      (int const   )9999,      (int const   )12,      (int const   )7,      (int const   )5, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
void check_phase(void) 
{ 
  int xnum_pieces ;
  int j ;
  int a ;
  int i ;

  {
  xnum_pieces = 0;
  j = 1;
  a = 1;
  while (a <= piece_count) {
    i = pieces[j];
    if (! i) {
      goto __Cont;
    } else {
      a ++;
    }
    if (board[i] != 1) {
      if (board[i] != 2) {
        if (board[i] != 13) {
          if (board[i] != 0) {
            xnum_pieces ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  if (xnum_pieces >= 12) {
    if (! white_castled) {
      goto _L___1;
    } else
    if (! black_castled) {
      _L___1: /* CIL Label */ 
      if (board[30] == 5) {
        phase = 0;
      } else
      if (board[114] == 6) {
        phase = 0;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (xnum_pieces <= 6) {
    phase = 2;
  } else {
    phase = 1;
  }
  return;
}
}
static int bishop_mobility(int square ) ;
static int const   dir[4]  = {      (int const   )-13,      (int const   )-11,      (int const   )11,      (int const   )13};
static int bishop_mobility(int square ) 
{ 
  register int l ;
  register int m ;
  register int diridx ;

  {
  m = 0;
  diridx = 0;
  while (diridx < 4) {
    l = square + (int )dir[diridx];
    while (board[l] == 13) {
      m ++;
      l += (int )dir[diridx];
    }
    diridx ++;
  }
  return (m);
}
}
static int rook_mobility(int square ) ;
static int const   dir___0[4]  = {      (int const   )-1,      (int const   )1,      (int const   )12,      (int const   )-12};
static int rook_mobility(int square ) 
{ 
  register int l ;
  register int m ;
  register int diridx ;

  {
  m = 0;
  diridx = 0;
  while (diridx < 4) {
    l = square + (int )dir___0[diridx];
    while (board[l] == 13) {
      m ++;
      l += (int )dir___0[diridx];
    }
    diridx ++;
  }
  return (m);
}
}
int King(int sq , int c ) 
{ 
  int s ;

  {
  s = 0;
  if (Xfile[sq] >= 6) {
    if ((board[sq - 1] + 1) >> 1 == 4) {
      if (((board[sq - 1] + 1) & 1) == c) {
        s += 2;
      }
    }
  }
  if (Xfile[sq] >= 6) {
    if ((board[sq + 1] + 1) >> 1 == 4) {
      if (((board[sq + 1] + 1) & 1) == c) {
        s += 2;
      }
    }
  }
  if (c == 1) {
    s = - s;
  }
  return (s);
}
}
int Queen(int sq , int c ) 
{ 
  int s ;
  int mob ;
  int xside ;
  int tmp ;
  int tmp___0 ;

  {
  s = 0;
  xside = c ^ 1;
  s += 900;
  s += (int )std_q_tropism[distance[sq][king_locs[xside]]];
  tmp = rook_mobility(sq);
  mob = tmp << 1;
  tmp___0 = bishop_mobility(sq);
  mob += tmp___0 << 1;
  if (mob <= 4) {
    if (mob == 0) {
      mob -= 15;
    } else
    if (mob == 2) {
      mob -= 10;
    } else {
      mob -= 5;
    }
  }
  s += mob;
  if (c == 1) {
    s = - s;
  }
  return (s);
}
}
static int const   square_d1[2]  = {      (int const   )29,      (int const   )113};
int Rook(int sq , int c ) 
{ 
  int s ;
  int mob ;
  int xside ;
  int tmp ;

  {
  s = 0;
  xside = c ^ 1;
  s += 500;
  s += (int )std_r_tropism[rookdistance[sq][king_locs[xside]]];
  tmp = rook_mobility(sq);
  mob = tmp << 1;
  if (mob <= 2) {
    mob -= 5;
  }
  s += mob;
  if (board[sq - 1] != 13) {
    if (board[sq + 1] != 13) {
      s -= 5;
    }
  }
  if (wmat != 1300) {
    goto _L;
  } else
  if (bmat != 1300) {
    _L: /* CIL Label */ 
    if (sq == (int )square_d1[c]) {
      s += 10;
      if ((board[square_d1[c] + 1] + 1) >> 1 == 4) {
        if (((board[square_d1[c] + 1] + 1) & 1) == c) {
          s += 5;
        }
      }
    }
    if (sq == (int )(square_d1[c] + 1)) {
      s += 10;
    }
  }
  if (c == 1) {
    s = - s;
  }
  return (s);
}
}
int Bishop(int sq , int c ) 
{ 
  int s ;
  int mob ;
  int xside ;
  int tmp ;

  {
  s = 0;
  xside = c ^ 1;
  s += 325;
  s += sbishop[sq];
  s += (int )std_b_tropism[distance[sq][king_locs[xside]]];
  tmp = bishop_mobility(sq);
  mob = tmp << 1;
  if (mob <= 2) {
    mob -= 5;
  }
  s += mob;
  if (c == 0) {
    if (sq == 39) {
      if (board[52] == 1) {
        s -= 5;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (c == 1) {
    if (sq == 99) {
      if (board[88] == 2) {
        s -= 5;
      }
    }
  }
  if (c == 1) {
    s = - s;
  }
  return (s);
}
}
int Knight(int sq , int c ) 
{ 
  int s ;
  int xside ;

  {
  s = 0;
  xside = c ^ 1;
  s += 310;
  s += sknight[sq];
  s += (int )std_n_tropism[distance[sq][king_locs[xside]]];
  if (c == 1) {
    s = - s;
  }
  return (s);
}
}
int Pawn(int sq , int c ) 
{ 
  int s ;
  int xside ;

  {
  s = 0;
  xside = c ^ 1;
  s += 100;
  s += (int )std_p_tropism[distance[sq][king_locs[xside]]];
  s += (int )std_own_p_tropism[distance[sq][king_locs[c]]];
  if ((board[sq + 1] + 1) >> 1 == 1) {
    if (((board[sq + 1] + 1) & 1) == c) {
      s += 5;
    }
  }
  if ((board[sq + 11] + 1) >> 1 == 1) {
    if (((board[sq + 11] + 1) & 1) == c) {
      s ++;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((board[sq + 13] + 1) >> 1 == 1) {
    if (((board[sq + 13] + 1) & 1) == c) {
      s ++;
    }
  }
  if (c == 1) {
    s = - s;
  }
  return (s);
}
}
int ErrorIt(int sq , int c ) 
{ 


  {
  printf("Illegal piece detected sq=%i c=%i\n", sq, c);
  return (0);
}
}
int std_eval(int alpha , int beta ) 
{ 
  int i ;
  int a ;
  int pawn_file ;
  int pawns[2][11] ;
  int white_back_pawn[11] ;
  int black_back_pawn[11] ;
  int srank ;
  int wking_pawn_file ;
  int bking_pawn_file ;
  int j ;
  int score ;
  xbool isolated ;
  xbool backwards ;
  int in_cache ;
  int wp ;
  int bp ;
  int wn ;
  int bn ;
  int wb ;
  int bb ;
  int wq ;
  int bq ;
  int wr ;
  int br ;
  int rbrook ;
  int fbrook ;
  int rwrook ;
  int fwrook ;
  int wpotential ;
  int bpotential ;
  int tmp ;
  int wksafety ;
  int bksafety ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;

  {
  score = 0;
  if (white_to_move) {
    tmp___1 = Material;
  } else {
    tmp___1 = - Material;
  }
  if (tmp___1 - maxposdiff >= beta) {
    if (white_to_move) {
      tmp___0 = Material;
    } else {
      tmp___0 = - Material;
    }
    return (tmp___0 - maxposdiff);
  }
  if (white_to_move) {
    tmp___3 = Material;
  } else {
    tmp___3 = - Material;
  }
  if (tmp___3 + maxposdiff <= alpha) {
    if (white_to_move) {
      tmp___2 = Material;
    } else {
      tmp___2 = - Material;
    }
    return (tmp___2 + maxposdiff);
  }
  in_cache = 0;
  checkECache(& score, & in_cache);
  if (in_cache) {
    if (white_to_move == 1) {
      return (score);
    }
    return (- score);
  }
  tmp___5 = __builtin_object_size((void *)(pawns), 0);
  if (tmp___5 != 0xffffffffffffffffUL) {
    tmp___4 = __builtin_object_size((void *)(pawns), 0);
    __builtin___memset_chk((void *)(pawns), 0, sizeof(pawns), tmp___4);
  } else {
    __inline_memset_chk((void *)(pawns), 0, sizeof(pawns));
  }
  i = 0;
  while (i < 11) {
    white_back_pawn[i] = 7;
    black_back_pawn[i] = 2;
    i ++;
  }
  wmat = 0;
  bmat = 0;
  king_locs[0] = wking_loc;
  king_locs[1] = bking_loc;
  j = 1;
  a = 1;
  while (a <= piece_count) {
    i = pieces[j];
    if (! i) {
      goto __Cont;
    } else {
      a ++;
    }
    if ((board[i] + 1) >> 1 != 1) {
      if ((board[i] + 1) >> 1 != 3) {
        if (((board[i] + 1) & 1) == 0) {
          wmat += material[board[i]];
        } else {
          tmp___6 = abs(material[board[i]]);
          bmat += tmp___6;
        }
      }
    }
    if ((board[i] + 1) >> 1 == 1) {
      pawn_file = (int )(Xfile[i] + 1);
      srank = (int )Xrank[i];
      if (((board[i] + 1) & 1) == 0) {
        (pawns[1][pawn_file]) ++;
        if (srank < white_back_pawn[pawn_file]) {
          white_back_pawn[pawn_file] = srank;
        }
      } else {
        (pawns[0][pawn_file]) ++;
        if (srank > black_back_pawn[pawn_file]) {
          black_back_pawn[pawn_file] = srank;
        }
      }
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  wpotential = 0;
  bpotential = 0;
  wksafety = 0;
  bksafety = 0;
  rbrook = 0;
  fbrook = 0;
  rwrook = 0;
  fwrook = 0;
  wp = 0;
  bp = 0;
  wb = 0;
  bb = 0;
  wn = 0;
  bn = 0;
  wr = 0;
  br = 0;
  wq = 0;
  bq = 0;
  j = 1;
  a = 1;
  while (a <= piece_count) {
    i = pieces[j];
    if (! i) {
      goto __Cont___0;
    } else {
      a ++;
    }
    tmp___7 = (*(evalRoutines[(board[i] + 1) >> 1]))(i, (board[i] + 1) & 1);
    score += tmp___7;
    pawn_file = (int )(Xfile[i] + 1);
    srank = (int )Xrank[i];
    switch (board[i]) {
    case 1: 
    isolated = (xbool )0;
    backwards = (xbool )0;
    score += swhite_pawn[i];
    wp ++;
    if (white_back_pawn[pawn_file + 1] > srank) {
      if (white_back_pawn[pawn_file - 1] > srank) {
        score -= 8;
        backwards = (xbool )1;
        if (! pawns[1][pawn_file + 1]) {
          if (! pawns[1][pawn_file - 1]) {
            score -= 5;
            isolated = (xbool )1;
          }
        }
      }
    }
    if (! pawns[0][pawn_file]) {
      if (backwards) {
        score -= 3;
      }
      if (isolated) {
        score -= 5;
      }
    }
    if (pawns[1][pawn_file] > 1) {
      score -= 3 * (pawns[1][pawn_file] - 1);
    }
    if (! pawns[0][pawn_file]) {
      if (srank >= black_back_pawn[pawn_file - 1]) {
        if (srank >= black_back_pawn[pawn_file + 1]) {
          score += 30 + 3 * swhite_pawn[i];
          if (white_to_move) {
            tmp = (110 + (int )Xfile[i]) - 1;
            tmp___13 = abs((int )(Xfile[bking_loc] - Xfile[tmp]));
            tmp___14 = abs((int )(Xrank[bking_loc] - Xrank[tmp]));
            if (tmp___13 > tmp___14) {
              tmp___10 = abs((int )(Xfile[bking_loc] - Xfile[tmp]));
              tmp___12 = tmp___10;
            } else {
              tmp___11 = abs((int )(Xrank[bking_loc] - Xrank[tmp]));
              tmp___12 = tmp___11;
            }
            tmp___15 = abs((int )(Xrank[tmp] - Xrank[i]));
            if (tmp___12 > tmp___15) {
              wpotential += 800;
            }
          } else {
            tmp = (110 + (int )Xfile[i]) - 1;
            tmp___21 = abs((int )(Xfile[bking_loc] - Xfile[tmp]));
            tmp___22 = abs((int )(Xrank[bking_loc] - Xrank[tmp]));
            if (tmp___21 > tmp___22) {
              tmp___18 = abs((int )(Xfile[bking_loc] - Xfile[tmp]));
              tmp___20 = tmp___18;
            } else {
              tmp___19 = abs((int )(Xrank[bking_loc] - Xrank[tmp]));
              tmp___20 = tmp___19;
            }
            tmp___23 = abs((int )(Xrank[tmp] - Xrank[i]));
            if (tmp___20 - 1 > tmp___23) {
              wpotential += 800;
            }
          }
          if (Xfile[i] == 1) {
            score += 12 + 2 * swhite_pawn[i];
          } else
          if (Xfile[i] == 8) {
            score += 12 + 2 * swhite_pawn[i];
          }
          if (! isolated) {
            score += 12;
            if (pawns[1][pawn_file + 1]) {
              if (! pawns[0][pawn_file + 1]) {
                if (white_back_pawn[pawn_file + 1] >= black_back_pawn[pawn_file + 2]) {
                  score += 7 * (int )Xrank[i];
                  if (Xrank[i] == 7) {
                    if (white_back_pawn[pawn_file + 1] >= 6) {
                      score += 50;
                    }
                  }
                }
              }
            }
            if (pawns[1][pawn_file - 1]) {
              if (! pawns[0][pawn_file - 1]) {
                if (white_back_pawn[pawn_file + 1] >= black_back_pawn[pawn_file - 2]) {
                  score += 7 * (int )Xrank[i];
                  if (Xrank[i] == 7) {
                    if (white_back_pawn[pawn_file - 1] >= 6) {
                      score += 50;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (! pawns[1][pawn_file - 1]) {
      score -= 7;
    }
    break;
    case 2: 
    isolated = (xbool )0;
    backwards = (xbool )0;
    score -= sblack_pawn[i];
    bp ++;
    if (black_back_pawn[pawn_file + 1] < srank) {
      if (black_back_pawn[pawn_file - 1] < srank) {
        score += 8;
        backwards = (xbool )1;
        if (! pawns[0][pawn_file + 1]) {
          if (! pawns[0][pawn_file - 1]) {
            score += 5;
            isolated = (xbool )1;
          }
        }
      }
    }
    if (! pawns[1][pawn_file]) {
      if (backwards) {
        score += 3;
      }
      if (isolated) {
        score += 5;
      }
    }
    if (pawns[0][pawn_file] > 1) {
      score += 3 * (pawns[0][pawn_file] - 1);
    }
    if (! pawns[1][pawn_file]) {
      if (srank <= white_back_pawn[pawn_file - 1]) {
        if (srank <= white_back_pawn[pawn_file + 1]) {
          score -= 30 + 3 * sblack_pawn[i];
          if (! white_to_move) {
            tmp = (26 + (int )Xfile[i]) - 1;
            tmp___29 = abs((int )(Xfile[wking_loc] - Xfile[tmp]));
            tmp___30 = abs((int )(Xrank[wking_loc] - Xrank[tmp]));
            if (tmp___29 > tmp___30) {
              tmp___26 = abs((int )(Xfile[wking_loc] - Xfile[tmp]));
              tmp___28 = tmp___26;
            } else {
              tmp___27 = abs((int )(Xrank[wking_loc] - Xrank[tmp]));
              tmp___28 = tmp___27;
            }
            tmp___31 = abs((int )(Xrank[tmp] - Xrank[i]));
            if (tmp___28 > tmp___31) {
              bpotential -= 800;
            }
          } else {
            tmp = (26 + (int )Xfile[i]) - 1;
            tmp___37 = abs((int )(Xfile[wking_loc] - Xfile[tmp]));
            tmp___38 = abs((int )(Xrank[wking_loc] - Xrank[tmp]));
            if (tmp___37 > tmp___38) {
              tmp___34 = abs((int )(Xfile[wking_loc] - Xfile[tmp]));
              tmp___36 = tmp___34;
            } else {
              tmp___35 = abs((int )(Xrank[wking_loc] - Xrank[tmp]));
              tmp___36 = tmp___35;
            }
            tmp___39 = abs((int )(Xrank[tmp] - Xrank[i]));
            if (tmp___36 - 1 > tmp___39) {
              bpotential -= 800;
            }
          }
          if (Xfile[i] == 1) {
            score -= 12 + 2 * sblack_pawn[i];
          } else
          if (Xfile[i] == 8) {
            score -= 12 + 2 * sblack_pawn[i];
          }
          if (! isolated) {
            score -= 12;
            if (pawns[0][pawn_file + 1]) {
              if (! pawns[1][pawn_file + 1]) {
                if (black_back_pawn[pawn_file + 1] <= white_back_pawn[pawn_file + 2]) {
                  score -= 7 * (9 - (int )Xrank[i]);
                  if (Xrank[i] == 2) {
                    if (black_back_pawn[pawn_file + 1] <= 3) {
                      score -= 50;
                    }
                  }
                }
              }
            }
            if (pawns[0][pawn_file - 1]) {
              if (! pawns[1][pawn_file - 1]) {
                if (black_back_pawn[pawn_file - 1] <= white_back_pawn[pawn_file - 2]) {
                  score -= 7 * (9 - (int )Xrank[i]);
                  if (Xrank[i] == 2) {
                    if (black_back_pawn[pawn_file - 1] <= 3) {
                      score -= 50;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (! pawns[0][pawn_file - 1]) {
      score += 7;
    }
    break;
    case 7: 
    wr ++;
    if (wr == 1) {
      fwrook = (int )Xfile[i];
      rwrook = (int )Xrank[i];
    }
    if (srank == 7) {
      score += 25;
      if (wr == 2) {
        if (rwrook == 7) {
          score += 10;
        }
      }
    }
    if (! pawns[1][pawn_file]) {
      score += 5;
      if (wr == 2) {
        if (Xfile[i] == (int const   )fwrook) {
          score += 12;
        }
      }
      if (! pawns[0][pawn_file]) {
        score += 3;
      }
    }
    break;
    case 8: 
    br ++;
    if (br == 1) {
      fbrook = (int )Xfile[i];
      rbrook = (int )Xrank[i];
    }
    if (srank == 2) {
      score -= 25;
      if (wr == 2) {
        if (rbrook == 2) {
          score -= 10;
        }
      }
    }
    if (! pawns[0][pawn_file]) {
      score -= 5;
      if (br == 2) {
        if (Xfile[i] == (int const   )fbrook) {
          score -= 12;
        }
      }
      if (! pawns[1][pawn_file]) {
        score -= 3;
      }
    }
    break;
    case 11: 
    wb ++;
    break;
    case 12: 
    bb ++;
    break;
    case 3: 
    wn ++;
    break;
    case 4: 
    bn ++;
    break;
    case 9: 
    wq ++;
    break;
    case 10: 
    bq ++;
    break;
    case 5: 
    if (wmat > 1300) {
      score += swhite_king[i];
      if (white_castled == 2) {
        score += 15;
      } else
      if (white_castled == 1) {
        score += 25;
      } else
      if (moved[30]) {
        score -= 10;
        if (! pawns[1][pawn_file]) {
          score -= 15;
        }
      }
      if (Xfile[wking_loc] != 4) {
        if (Xfile[wking_loc] != 5) {
          if (srank < white_back_pawn[pawn_file]) {
            if (pawns[1][pawn_file]) {
              score -= 9 * ((white_back_pawn[pawn_file] - srank) - 1);
            } else {
              score -= 22;
            }
          } else {
            score -= 22;
          }
          if (srank < white_back_pawn[pawn_file + 1]) {
            if (pawns[1][pawn_file + 1]) {
              score -= 8 * ((white_back_pawn[pawn_file + 1] - srank) - 1);
            } else {
              score -= 16;
            }
          } else {
            score -= 16;
          }
          if (srank < white_back_pawn[pawn_file - 1]) {
            if (pawns[1][pawn_file - 1]) {
              score -= 8 * ((white_back_pawn[pawn_file - 1] - srank) - 1);
            } else {
              score -= 16;
            }
          } else {
            score -= 16;
          }
        } else {
          score -= 10;
        }
      } else {
        score -= 10;
      }
    } else {
      score += send_king[i];
    }
    break;
    case 6: 
    if (bmat > 1300) {
      score -= sblack_king[i];
      if (black_castled == 4) {
        score -= 15;
      } else
      if (black_castled == 3) {
        score -= 25;
      } else
      if (moved[114]) {
        score += 10;
        if (! pawns[0][pawn_file]) {
          score += 15;
        }
      }
      if (Xfile[bking_loc] != 4) {
        if (Xfile[bking_loc] != 5) {
          if (srank > black_back_pawn[pawn_file]) {
            if (pawns[0][pawn_file]) {
              score += 9 * (int )srev_rank[(srank - black_back_pawn[pawn_file]) - 1];
            } else {
              score += 22;
            }
          } else {
            score += 22;
          }
          if (srank > black_back_pawn[pawn_file + 1]) {
            if (pawns[0][pawn_file + 1]) {
              score += 8 * (int )srev_rank[(srank - black_back_pawn[pawn_file + 1]) - 1];
            } else {
              score += 16;
            }
          } else {
            score += 16;
          }
          if (srank > black_back_pawn[pawn_file - 1]) {
            if (pawns[0][pawn_file - 1]) {
              score += 8 * (int )srev_rank[(srank - black_back_pawn[pawn_file - 1]) - 1];
            } else {
              score += 16;
            }
          } else {
            score += 16;
          }
        } else {
          score += 10;
        }
      } else {
        score += 10;
      }
    } else {
      score -= send_king[i];
    }
    break;
    }
    __Cont___0: /* CIL Label */ 
    j ++;
  }
  if (wmat > 2200) {
    goto _L;
  } else
  if (bmat > 2200) {
    _L: /* CIL Label */ 
    if (! moved[41]) {
      if (board[53] != 13) {
        score -= 5;
      }
    }
    if (! moved[42]) {
      if (board[54] != 13) {
        score -= 5;
      }
    }
    if (! moved[101]) {
      if (board[89] != 13) {
        score += 5;
      }
    }
    if (! moved[102]) {
      if (board[90] != 13) {
        score += 5;
      }
    }
  }
  if (wmat > 1300) {
    goto _L___0;
  } else
  if (bmat > 1300) {
    _L___0: /* CIL Label */ 
    wking_pawn_file = (int )(Xfile[wking_loc] + 1);
    bking_pawn_file = (int )(Xfile[bking_loc] + 1);
    tmp___40 = abs(wking_pawn_file - bking_pawn_file);
    if (tmp___40 > 2) {
      wksafety += 3 * (int )(srev_rank[black_back_pawn[wking_pawn_file]] - 2);
      wksafety += 3 * (int )(srev_rank[black_back_pawn[wking_pawn_file + 1]] - 2);
      wksafety += 3 * (int )(srev_rank[black_back_pawn[wking_pawn_file - 1]] - 2);
      bksafety += 3 * (white_back_pawn[bking_pawn_file] - 2);
      bksafety += 3 * (white_back_pawn[bking_pawn_file + 1] - 2);
      bksafety += 3 * (white_back_pawn[bking_pawn_file - 1] - 2);
      if (! pawns[0][wking_pawn_file]) {
        wksafety += 8;
      }
      if (! pawns[0][wking_pawn_file + 1]) {
        wksafety += 6;
      }
      if (! pawns[0][wking_pawn_file - 1]) {
        wksafety += 6;
      }
      if (! pawns[1][bking_pawn_file]) {
        bksafety += 8;
      }
      if (! pawns[1][bking_pawn_file + 1]) {
        bksafety += 6;
      }
      if (! pawns[1][bking_pawn_file - 1]) {
        bksafety += 6;
      }
    }
  }
  if (bmat > 1300) {
    if (bq) {
      score -= wksafety;
    }
  }
  if (wmat > 1300) {
    if (wq) {
      score += bksafety;
    }
  }
  if (! wr) {
    if (! wq) {
      if (! wb) {
        if (! wn) {
          score += bpotential;
        }
      }
    }
  }
  if (! br) {
    if (! bq) {
      if (! bb) {
        if (! bn) {
          score += wpotential;
        }
      }
    }
  }
  if (! wp) {
    if (! bp) {
      if (! wr) {
        if (! br) {
          if (! wq) {
            if (! bq) {
              if (! bb) {
                if (! wb) {
                  if (wn < 3) {
                    if (bn < 3) {
                      score = 0;
                    }
                  }
                } else {
                  goto _L___5;
                }
              } else
              _L___5: /* CIL Label */ 
              if (! wn) {
                if (! bn) {
                  tmp___41 = abs(wb - bb);
                  if (tmp___41 < 2) {
                    score = 0;
                  }
                } else {
                  goto _L___4;
                }
              } else
              _L___4: /* CIL Label */ 
              if (wn < 3) {
                if (! wb) {
                  goto _L___2;
                } else {
                  goto _L___3;
                }
              } else
              _L___3: /* CIL Label */ 
              if (wb == 1) {
                if (! wn) {
                  _L___2: /* CIL Label */ 
                  if (bn < 3) {
                    if (! bb) {
                      score = 0;
                    } else {
                      goto _L___1;
                    }
                  } else
                  _L___1: /* CIL Label */ 
                  if (bb == 1) {
                    if (! bn) {
                      score = 0;
                    }
                  }
                }
              }
            } else {
              goto _L___10;
            }
          } else {
            goto _L___10;
          }
        } else {
          goto _L___10;
        }
      } else
      _L___10: /* CIL Label */ 
      if (! wq) {
        if (! bq) {
          if (wr == 1) {
            if (br == 1) {
              if (wn + wb < 2) {
                if (bn + bb < 2) {
                  score = 0;
                }
              }
            } else {
              goto _L___7;
            }
          } else
          _L___7: /* CIL Label */ 
          if (wr == 1) {
            if (! br) {
              if (wn + wb == 0) {
                if (bn + bb == 1) {
                  score = 0;
                } else
                if (bn + bb == 2) {
                  score = 0;
                }
              }
            } else {
              goto _L___6;
            }
          } else
          _L___6: /* CIL Label */ 
          if (br == 1) {
            if (! wr) {
              if (bn + bb == 0) {
                if (wn + wb == 1) {
                  score = 0;
                } else
                if (wn + wb == 2) {
                  score = 0;
                }
              }
            }
          }
        }
      }
    } else {
      goto _L___12;
    }
  } else
  _L___12: /* CIL Label */ 
  if (wn + wb != bn + bb) {
    if (wq + wr == bq + br) {
      if (wn + wb > bn + bb) {
        score += 120;
      } else {
        score -= 120;
      }
    } else {
      tmp___43 = abs((wr + wq) - (br + bq));
      if (tmp___43 == 1) {
        if (wb + wn > (bb + bn) + 1) {
          score += 120;
        } else
        if (bb + bn > (wb + wn) + 1) {
          score -= 120;
        }
      } else {
        tmp___42 = abs((wr + wq) - (br + bq));
        if (tmp___42 == 2) {
          if (wb + wn > (bb + bn) + 2) {
            score += 120;
          } else
          if (bb + bn > (wb + wn) + 2) {
            score -= 120;
          }
        }
      }
    }
  } else
  if (wq + wr == bq + br) {
    if (wq) {
      if (! bq) {
        score += 120;
      } else {
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
    if (! wq) {
      if (bq) {
        score -= 120;
      }
    }
  }
  storeECache(score);
  tmp___47 = abs(Material - score);
  if (tmp___47 > maxposdiff) {
    tmp___46 = abs(Material - score);
    if (1000 < tmp___46) {
      maxposdiff = 1000;
    } else {
      tmp___45 = abs(Material - score);
      maxposdiff = tmp___45;
    }
  }
  if (white_to_move == 1) {
    return (score);
  } else {
    return (- score);
  }
}
}
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-CaEgfzDT.i","-O3")
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
extern int strncmp(char const   * , char const   * , size_t  ) ;
__inline static void *__inline_memcpy_chk(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memcpy_chk(__dest, __src, __len, tmp);
  return (tmp___0);
}
}
__inline static char *__inline_strcpy_chk(char *__dest , char const   *__src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcpy_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
void HandlePartner(char *input ) ;
void HandlePtell(char *input ) ;
void BegForPartner(void) ;
void CheckBadFlow(xbool reset ) ;
void ResetHandValue(void) ;
char my_partner[256] ;
xbool have_partner ;
xbool must_sit ;
int must_go  ;
xbool go_fast ;
xbool piecedead  ;
xbool partnerdead  ;
int hand_value[13]  = 
  {      0,      100,      -100,      210, 
        -210,      0,      0,      250, 
        -250,      450,      -450,      230, 
        -230};
int std_hand_value[13]  = 
  {      0,      100,      -100,      210, 
        -210,      0,      0,      250, 
        -250,      450,      -450,      230, 
        -230};
void ResetHandValue(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size((void *)(hand_value), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(hand_value), 0);
    __builtin___memcpy_chk((void *)(hand_value), (void const   *)(std_hand_value),
                           sizeof(hand_value), tmp);
  } else {
    __inline_memcpy_chk((void *)(hand_value), (void const   *)(std_hand_value), sizeof(hand_value));
  }
  return;
}
}
void BegForPartner(void) 
{ 


  {
  return;
}
}
void GreetPartner(void) 
{ 


  {
  printf("tellics ptell Hello! I am Sjeng and hope you enjoy playing with me.\n");
  printf("tellics ptell For help on some commands that I understand, ptell me \'help\'\n");
  return;
}
}
void HandlePartner(char *input ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if ((int )*(input + 0) == 32) {
    if (! have_partner) {
      sscanf((char const   *)(input + 1), "%s", my_partner);
      have_partner = (xbool )1;
      GreetPartner();
      printf("tellics set f5 bughouse\n");
      printf("tellics unseek\n");
    }
  } else {
    tmp___0 = __builtin_object_size((void *)(my_partner), 0);
    if (tmp___0 != 0xffffffffffffffffUL) {
      tmp = __builtin_object_size((void *)(my_partner), 0);
      __builtin___memset_chk((void *)(my_partner), 0, sizeof(my_partner), tmp);
    } else {
      __inline_memset_chk((void *)(my_partner), 0, sizeof(my_partner));
    }
    have_partner = (xbool )0;
    BegForPartner();
    printf("tellics set f5 1=1\n");
  }
  return;
}
}
void HandlePtell(char *input ) 
{ 
  int change ;
  char howmuch[80] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  unsigned long tmp___26 ;
  unsigned long tmp___27 ;
  unsigned long tmp___28 ;
  unsigned long tmp___29 ;
  unsigned long tmp___30 ;
  unsigned long tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;

  {
  change = 0;
  howmuch[0] = (char )'i';
  howmuch[1] = (char )'s';
  howmuch[2] = (char )'.';
  howmuch[3] = (char )'.';
  howmuch[4] = (char )'.';
  howmuch[5] = (char )'u';
  howmuch[6] = (char )'h';
  howmuch[7] = (char )'.';
  howmuch[8] = (char )'.';
  howmuch[9] = (char )'.';
  howmuch[10] = (char )'w';
  howmuch[11] = (char )'h';
  howmuch[12] = (char )'a';
  howmuch[13] = (char )'t';
  howmuch[14] = (char )' ';
  howmuch[15] = (char )'d';
  howmuch[16] = (char )'i';
  howmuch[17] = (char )'d';
  howmuch[18] = (char )' ';
  howmuch[19] = (char )'y';
  howmuch[20] = (char )'o';
  howmuch[21] = (char )'u';
  howmuch[22] = (char )' ';
  howmuch[23] = (char )'s';
  howmuch[24] = (char )'a';
  howmuch[25] = (char )'y';
  howmuch[26] = (char )'?';
  howmuch[27] = (char )'\n';
  howmuch[28] = (char )'\000';
  tmp = 29U;
  while (! (tmp >= 80U)) {
    howmuch[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = strncmp((char const   *)(input + 6), "help", (size_t )4);
  if (! tmp___0) {
    printf("tellics ptell Commands that I understand are : sit, go, fast, slow, abort, flag, +/++/+++/-/--/---{p,n,b,r,q,d,h,trades}, x, dead, formula, help.\n");
    return;
  }
  if (Variant != 1) {
    tmp___1 = strncmp((char const   *)(input + 6), "sorry", (size_t )5);
    if (tmp___1) {
      printf("tellics ptell Sorry, but I\'m not playing a bughouse game.\n");
      return;
    }
  }
  tmp___73 = strncmp((char const   *)(input + 6), "sit", (size_t )3);
  if (tmp___73) {
    tmp___71 = strncmp((char const   *)(input + 6), "go", (size_t )2);
    if (tmp___71) {
      tmp___72 = strncmp((char const   *)(input + 6), "move", (size_t )4);
      if (tmp___72) {
        tmp___69 = strncmp((char const   *)(input + 6), "fast", (size_t )4);
        if (tmp___69) {
          tmp___70 = strncmp((char const   *)(input + 6), "time", (size_t )4);
          if (tmp___70) {
            tmp___68 = strncmp((char const   *)(input + 6), "slow", (size_t )4);
            if (tmp___68) {
              tmp___67 = strncmp((char const   *)(input + 6), "abort", (size_t )5);
              if (tmp___67) {
                tmp___66 = strncmp((char const   *)(input + 6), "flag", (size_t )4);
                if (tmp___66) {
                  tmp___65 = strncmp((char const   *)(input + 6), "+", (size_t )1);
                  if (tmp___65) {
                    tmp___64 = strncmp((char const   *)(input + 6), "-", (size_t )1);
                    if (tmp___64) {
                      tmp___58 = strncmp((char const   *)(input + 6), "x", (size_t )1);
                      if (tmp___58) {
                        tmp___59 = strstr((char const   *)(input + 6), "mate me anymore");
                        if ((unsigned long )tmp___59 != (unsigned long )((void *)0)) {
                          goto _L___14;
                        } else {
                          tmp___60 = strstr((char const   *)(input + 6), "never");
                          if ((unsigned long )tmp___60 != (unsigned long )((void *)0)) {
                            tmp___61 = strstr((char const   *)(input + 6), "mind");
                            if ((unsigned long )tmp___61 != (unsigned long )((void *)0)) {
                              goto _L___14;
                            } else {
                              goto _L___15;
                            }
                          } else {
                            _L___15: /* CIL Label */ 
                            tmp___62 = strncmp((char const   *)(input + 6), "=", (size_t )1);
                            if (tmp___62) {
                              _L___13: /* CIL Label */ 
                              tmp___56 = strncmp((char const   *)(input + 6), "i\'ll have to sit...(dead)",
                                                 (size_t )25);
                              if (tmp___56) {
                                tmp___57 = strncmp((char const   *)(input + 6), "dead",
                                                   (size_t )4);
                                if (tmp___57) {
                                  tmp___55 = strncmp((char const   *)(input + 6),
                                                     "i\'ll have to sit...(piece)",
                                                     (size_t )26);
                                  if (tmp___55) {
                                    tmp___54 = strncmp((char const   *)(input + 6),
                                                       "sorry", (size_t )5);
                                    if (tmp___54) {
                                      tmp___53 = strncmp((char const   *)(input + 6),
                                                         "ok", (size_t )2);
                                      if (tmp___53) {
                                        tmp___51 = strncmp((char const   *)(input + 6),
                                                           "hi", (size_t )2);
                                        if (tmp___51) {
                                          tmp___52 = strncmp((char const   *)(input + 6),
                                                             "hello", (size_t )5);
                                          if (tmp___52) {
                                            tmp___50 = strstr((char const   *)(input + 6),
                                                              "formula");
                                            if ((unsigned long )tmp___50 != (unsigned long )((void *)0)) {
                                              printf("tellics ptell Setting formula, if you are still interrupted, complain to my operator.\n");
                                              printf("tellics set f5 bughouse\n");
                                            } else {
                                              printf("tellics ptell Sorry, but I don\'t understand that command.\n");
                                            }
                                          } else {
                                            printf("tellics ptell Greetings.\n");
                                          }
                                        } else {
                                          printf("tellics ptell Greetings.\n");
                                        }
                                      } else {
                                        return;
                                      }
                                    } else {
                                      return;
                                    }
                                  } else {
                                    go_fast = (xbool )1;
                                    must_sit = (xbool )0;
                                    piecedead = (xbool )1;
                                  }
                                } else {
                                  go_fast = (xbool )1;
                                  must_sit = (xbool )0;
                                  partnerdead = (xbool )1;
                                }
                              } else {
                                go_fast = (xbool )1;
                                must_sit = (xbool )0;
                                partnerdead = (xbool )1;
                              }
                            } else {
                              _L___14: /* CIL Label */ 
                              tmp___63 = strstr((char const   *)(input + 6), "ptell me");
                              if ((unsigned long )tmp___63 == (unsigned long )((void *)0)) {
                                printf("tellics ptell Ok, reverting to STANDARD piece values!\n");
                                ResetHandValue();
                                must_sit = (xbool )0;
                                partnerdead = (xbool )0;
                                piecedead = (xbool )0;
                              } else {
                                goto _L___13;
                              }
                            }
                          }
                        }
                      } else {
                        goto _L___14;
                      }
                    } else {
                      tmp___35 = strstr((char const   *)(input + 6), "trade");
                      if ((unsigned long )tmp___35 != (unsigned long )((void *)0)) {
                        goto _L___6;
                      } else {
                        tmp___36 = strstr((char const   *)(input + 6), "n");
                        if ((unsigned long )tmp___36 == (unsigned long )((void *)0)) {
                          tmp___37 = strstr((char const   *)(input + 6), "b");
                          if ((unsigned long )tmp___37 == (unsigned long )((void *)0)) {
                            tmp___38 = strstr((char const   *)(input + 6), "p");
                            if ((unsigned long )tmp___38 == (unsigned long )((void *)0)) {
                              tmp___39 = strstr((char const   *)(input + 6), "r");
                              if ((unsigned long )tmp___39 == (unsigned long )((void *)0)) {
                                tmp___40 = strstr((char const   *)(input + 6), "q");
                                if ((unsigned long )tmp___40 == (unsigned long )((void *)0)) {
                                  tmp___41 = strstr((char const   *)(input + 6), "d");
                                  if ((unsigned long )tmp___41 == (unsigned long )((void *)0)) {
                                    tmp___42 = strstr((char const   *)(input + 6),
                                                      "h");
                                    if ((unsigned long )tmp___42 == (unsigned long )((void *)0)) {
                                      _L___6: /* CIL Label */ 
                                      if (comp_color == 1) {
                                        hand_value[2] -= 20;
                                        hand_value[4] -= 50;
                                        hand_value[12] -= 50;
                                        hand_value[8] -= 50;
                                        hand_value[10] -= 100;
                                      } else {
                                        hand_value[1] += 20;
                                        hand_value[3] += 50;
                                        hand_value[11] += 50;
                                        hand_value[7] += 50;
                                        hand_value[9] += 100;
                                      }
                                      printf("tellics ptell Ok, trading is BAD\n");
                                    } else {
                                      goto _L___12;
                                    }
                                  } else {
                                    goto _L___12;
                                  }
                                } else {
                                  goto _L___12;
                                }
                              } else {
                                goto _L___12;
                              }
                            } else {
                              goto _L___12;
                            }
                          } else {
                            goto _L___12;
                          }
                        } else {
                          _L___12: /* CIL Label */ 
                          tmp___34 = strstr((char const   *)(input + 6), "---");
                          if ((unsigned long )tmp___34 != (unsigned long )((void *)0)) {
                            change = 50000;
                            tmp___27 = __builtin_object_size((void *)(howmuch), 0);
                            if (tmp___27 != 0xffffffffffffffffUL) {
                              tmp___26 = __builtin_object_size((void *)(howmuch),
                                                               1);
                              __builtin___strcpy_chk(howmuch, "mates you (ptell me \'x\' when it no longer mates you)",
                                                     tmp___26);
                            } else {
                              __inline_strcpy_chk(howmuch, "mates you (ptell me \'x\' when it no longer mates you)");
                            }
                          } else {
                            tmp___33 = strstr((char const   *)(input + 6), "--");
                            if ((unsigned long )tmp___33 != (unsigned long )((void *)0)) {
                              change = 1000;
                              tmp___29 = __builtin_object_size((void *)(howmuch),
                                                               0);
                              if (tmp___29 != 0xffffffffffffffffUL) {
                                tmp___28 = __builtin_object_size((void *)(howmuch),
                                                                 1);
                                __builtin___strcpy_chk(howmuch, "is VERY bad (ptell me \'x\' when it is no longer bad)",
                                                       tmp___28);
                              } else {
                                __inline_strcpy_chk(howmuch, "is VERY bad (ptell me \'x\' when it is no longer bad)");
                              }
                            } else {
                              tmp___32 = strstr((char const   *)(input + 6), "-");
                              if ((unsigned long )tmp___32 != (unsigned long )((void *)0)) {
                                change = 150;
                                tmp___31 = __builtin_object_size((void *)(howmuch),
                                                                 0);
                                if (tmp___31 != 0xffffffffffffffffUL) {
                                  tmp___30 = __builtin_object_size((void *)(howmuch),
                                                                   1);
                                  __builtin___strcpy_chk(howmuch, "is bad (ptell me \'x\' when it is no longer bad)",
                                                         tmp___30);
                                } else {
                                  __inline_strcpy_chk(howmuch, "is bad (ptell me \'x\' when it is no longer bad)");
                                }
                              } else {
                                *((int *)((void *)0)) = 0;
                              }
                            }
                          }
                        }
                      }
                      tmp___43 = strstr((char const   *)(input + 6), "n");
                      if ((unsigned long )tmp___43 != (unsigned long )((void *)0)) {
                        if (comp_color == 1) {
                          hand_value[4] = std_hand_value[4] - change;
                        } else {
                          hand_value[3] = std_hand_value[3] + change;
                        }
                        printf("tellics ptell Ok, Knight %s\n", howmuch);
                      }
                      tmp___44 = strstr((char const   *)(input + 6), "b");
                      if ((unsigned long )tmp___44 != (unsigned long )((void *)0)) {
                        if (comp_color == 1) {
                          hand_value[12] = std_hand_value[12] - change;
                        } else {
                          hand_value[11] = std_hand_value[11] + change;
                        }
                        if (comp_color == 1) {
                          hand_value[10] = std_hand_value[10] - change;
                        } else {
                          hand_value[9] = std_hand_value[9] + change;
                        }
                        printf("tellics ptell Ok, Bishop %s\n", howmuch);
                      }
                      tmp___45 = strstr((char const   *)(input + 6), "r");
                      if ((unsigned long )tmp___45 != (unsigned long )((void *)0)) {
                        if (comp_color == 1) {
                          hand_value[8] = std_hand_value[8] - change;
                        } else {
                          hand_value[7] = std_hand_value[7] + change;
                        }
                        if (comp_color == 1) {
                          hand_value[10] = std_hand_value[10] - change;
                        } else {
                          hand_value[9] = std_hand_value[9] + change;
                        }
                        printf("tellics ptell Ok, Rook %s\n", howmuch);
                      }
                      tmp___46 = strstr((char const   *)(input + 6), "q");
                      if ((unsigned long )tmp___46 != (unsigned long )((void *)0)) {
                        if (comp_color == 1) {
                          hand_value[10] = std_hand_value[10] - change;
                        } else {
                          hand_value[9] = std_hand_value[9] + change;
                        }
                        printf("tellics ptell Ok, Queen %s\n", howmuch);
                      }
                      tmp___47 = strstr((char const   *)(input + 6), "p");
                      if ((unsigned long )tmp___47 != (unsigned long )((void *)0)) {
                        if (comp_color == 1) {
                          hand_value[2] = std_hand_value[2] - change;
                        } else {
                          hand_value[1] = std_hand_value[1] + change;
                        }
                        if (comp_color == 1) {
                          hand_value[10] = std_hand_value[10] - change;
                          hand_value[12] = std_hand_value[12] - change;
                        } else {
                          hand_value[9] = std_hand_value[9] + change;
                          hand_value[11] = std_hand_value[11] + change;
                        }
                        printf("tellics ptell Ok, Pawn %s\n", howmuch);
                      }
                      tmp___48 = strstr((char const   *)(input + 6), "d");
                      if ((unsigned long )tmp___48 != (unsigned long )((void *)0)) {
                        if (comp_color == 1) {
                          hand_value[2] = std_hand_value[2] - change;
                          hand_value[12] = std_hand_value[12] - change;
                          hand_value[10] = std_hand_value[10] - change;
                        } else {
                          hand_value[1] = std_hand_value[1] + change;
                          hand_value[11] = std_hand_value[11] + change;
                          hand_value[9] = std_hand_value[9] + change;
                        }
                        printf("tellics ptell Ok, Diagonal %s\n", howmuch);
                      }
                      tmp___49 = strstr((char const   *)(input + 6), "h");
                      if ((unsigned long )tmp___49 != (unsigned long )((void *)0)) {
                        if (comp_color == 1) {
                          hand_value[8] = std_hand_value[8] - change;
                          hand_value[10] = std_hand_value[10] - change;
                        } else {
                          hand_value[7] = std_hand_value[7] + change;
                          hand_value[9] = std_hand_value[9] + change;
                        }
                        printf("tellics ptell Ok, Heavy %s\n", howmuch);
                      }
                    }
                  } else {
                    tmp___11 = strstr((char const   *)(input + 6), "trade");
                    if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
                      goto _L;
                    } else {
                      tmp___12 = strstr((char const   *)(input + 6), "n");
                      if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
                        tmp___13 = strstr((char const   *)(input + 6), "b");
                        if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
                          tmp___14 = strstr((char const   *)(input + 6), "p");
                          if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
                            tmp___15 = strstr((char const   *)(input + 6), "r");
                            if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
                              tmp___16 = strstr((char const   *)(input + 6), "q");
                              if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
                                tmp___17 = strstr((char const   *)(input + 6), "d");
                                if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
                                  tmp___18 = strstr((char const   *)(input + 6), "h");
                                  if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
                                    _L: /* CIL Label */ 
                                    if (comp_color == 1) {
                                      hand_value[1] += 25;
                                      hand_value[3] += 50;
                                      hand_value[11] += 50;
                                      hand_value[7] += 50;
                                      hand_value[9] += 100;
                                    } else {
                                      hand_value[2] -= 25;
                                      hand_value[4] -= 50;
                                      hand_value[12] -= 50;
                                      hand_value[8] -= 50;
                                      hand_value[10] -= 100;
                                    }
                                    printf("tellics ptell Ok, trading is GOOD\n");
                                  } else {
                                    goto _L___5;
                                  }
                                } else {
                                  goto _L___5;
                                }
                              } else {
                                goto _L___5;
                              }
                            } else {
                              goto _L___5;
                            }
                          } else {
                            goto _L___5;
                          }
                        } else {
                          goto _L___5;
                        }
                      } else {
                        _L___5: /* CIL Label */ 
                        tmp___10 = strstr((char const   *)(input + 6), "+++");
                        if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
                          change = 50000;
                          tmp___3 = __builtin_object_size((void *)(howmuch), 0);
                          if (tmp___3 != 0xffffffffffffffffUL) {
                            tmp___2 = __builtin_object_size((void *)(howmuch), 1);
                            __builtin___strcpy_chk(howmuch, "mates", tmp___2);
                          } else {
                            __inline_strcpy_chk(howmuch, "mates");
                          }
                        } else {
                          tmp___9 = strstr((char const   *)(input + 6), "++");
                          if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
                            change = 1000;
                            tmp___5 = __builtin_object_size((void *)(howmuch), 0);
                            if (tmp___5 != 0xffffffffffffffffUL) {
                              tmp___4 = __builtin_object_size((void *)(howmuch), 1);
                              __builtin___strcpy_chk(howmuch, "is VERY good (ptell me \'x\' to play normal again)",
                                                     tmp___4);
                            } else {
                              __inline_strcpy_chk(howmuch, "is VERY good (ptell me \'x\' to play normal again)");
                            }
                          } else {
                            tmp___8 = strstr((char const   *)(input + 6), "+");
                            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
                              change = 150;
                              tmp___7 = __builtin_object_size((void *)(howmuch), 0);
                              if (tmp___7 != 0xffffffffffffffffUL) {
                                tmp___6 = __builtin_object_size((void *)(howmuch),
                                                                1);
                                __builtin___strcpy_chk(howmuch, "is good (ptell me \'x\' to play normal again)",
                                                       tmp___6);
                              } else {
                                __inline_strcpy_chk(howmuch, "is good (ptell me \'x\' to play normal again)");
                              }
                            } else {
                              *((int *)((void *)0)) = 0;
                            }
                          }
                        }
                      }
                    }
                    tmp___19 = strstr((char const   *)(input + 6), "n");
                    if ((unsigned long )tmp___19 != (unsigned long )((void *)0)) {
                      if (comp_color == 1) {
                        hand_value[3] = std_hand_value[3] + change;
                      } else {
                        hand_value[4] = std_hand_value[4] - change;
                      }
                      printf("tellics ptell Ok, Knight %s\n", howmuch);
                    }
                    tmp___20 = strstr((char const   *)(input + 6), "b");
                    if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
                      if (comp_color == 1) {
                        hand_value[11] = std_hand_value[11] + change;
                      } else {
                        hand_value[12] = std_hand_value[12] - change;
                      }
                      if (comp_color == 1) {
                        hand_value[9] = std_hand_value[9] + change;
                      } else {
                        hand_value[10] = std_hand_value[10] - change;
                      }
                      printf("tellics ptell Ok, Bishop %s\n", howmuch);
                    }
                    tmp___21 = strstr((char const   *)(input + 6), "r");
                    if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
                      if (comp_color == 1) {
                        hand_value[7] = std_hand_value[7] + change;
                      } else {
                        hand_value[8] = std_hand_value[8] - change;
                      }
                      if (comp_color == 1) {
                        hand_value[9] = std_hand_value[9] + change;
                      } else {
                        hand_value[10] = std_hand_value[10] - change;
                      }
                      printf("tellics ptell Ok, Rook %s\n", howmuch);
                    }
                    tmp___22 = strstr((char const   *)(input + 6), "q");
                    if ((unsigned long )tmp___22 != (unsigned long )((void *)0)) {
                      if (comp_color == 1) {
                        hand_value[9] = std_hand_value[9] + change;
                      } else {
                        hand_value[10] = std_hand_value[10] - change;
                      }
                      printf("tellics ptell Ok, Queen %s\n", howmuch);
                    }
                    tmp___23 = strstr((char const   *)(input + 6), "p");
                    if ((unsigned long )tmp___23 != (unsigned long )((void *)0)) {
                      if (comp_color == 1) {
                        hand_value[1] = std_hand_value[1] + change;
                      } else {
                        hand_value[2] = std_hand_value[2] - change;
                      }
                      if (comp_color == 1) {
                        hand_value[9] = std_hand_value[9] + change;
                        hand_value[11] = std_hand_value[11] + change;
                      } else {
                        hand_value[10] = std_hand_value[10] - change;
                        hand_value[12] = std_hand_value[12] - change;
                      }
                      printf("tellics ptell Ok, Pawn %s\n", howmuch);
                    }
                    tmp___24 = strstr((char const   *)(input + 6), "d");
                    if ((unsigned long )tmp___24 != (unsigned long )((void *)0)) {
                      if (comp_color == 1) {
                        hand_value[1] = std_hand_value[1] + change;
                        hand_value[11] = std_hand_value[11] + change;
                        hand_value[9] = std_hand_value[9] + change;
                      } else {
                        hand_value[2] = std_hand_value[2] - change;
                        hand_value[12] = std_hand_value[12] - change;
                        hand_value[10] = std_hand_value[10] - change;
                      }
                      printf("tellics ptell Ok, Diagonal %s\n", howmuch);
                    }
                    tmp___25 = strstr((char const   *)(input + 6), "h");
                    if ((unsigned long )tmp___25 != (unsigned long )((void *)0)) {
                      if (comp_color == 1) {
                        hand_value[7] = std_hand_value[7] + change;
                        hand_value[9] = std_hand_value[9] + change;
                      } else {
                        hand_value[8] = std_hand_value[8] - change;
                        hand_value[10] = std_hand_value[10] - change;
                      }
                      printf("tellics ptell Ok, Heavy %s\n", howmuch);
                    }
                  }
                } else {
                  printf("tellics ptell Flagging...\n");
                  printf("tellics flag\n");
                }
              } else {
                printf("tellics ptell Requesting abort...\n");
                printf("tellics abort\n");
              }
            } else {
              printf("tellics ptell Ok, moving normally.\n");
              go_fast = (xbool )0;
              must_sit = (xbool )0;
            }
          } else {
            printf("tellics ptell Ok, I\'m going FAST!\n");
            go_fast = (xbool )1;
            must_sit = (xbool )0;
          }
        } else {
          printf("tellics ptell Ok, I\'m going FAST!\n");
          go_fast = (xbool )1;
          must_sit = (xbool )0;
        }
      } else {
        printf("tellics ptell Ok, I\'m moving.\n");
        must_sit = (xbool )0;
        must_go = 4;
      }
    } else {
      printf("tellics ptell Ok, I\'m moving.\n");
      must_sit = (xbool )0;
      must_go = 4;
    }
  } else {
    printf("tellics ptell Ok, I sit next move. Tell me when to go.\n");
    must_sit = (xbool )1;
    must_go = 0;
  }
  return;
}
}
static int pawnmated  =    0;
static int knightmated  =    0;
static int bishopmated  =    0;
static int rookmated  =    0;
static int queenmated  =    0;
void CheckBadFlow(xbool reset ) 
{ 
  move_s hismoves[512] ;
  move_s ourmoves[512] ;
  int his_num_moves ;
  int our_num_moves ;
  int j ;
  int i ;
  int ic ;
  int icc ;
  xbool othermove ;
  int pawnmates ;
  int knightmates ;
  int bishopmates ;
  int rookmates ;
  int queenmates ;
  xbool pawnwarn ;
  xbool knightwarn ;
  xbool bishopwarn ;
  xbool rookwarn ;
  xbool queenwarn ;
  xbool tmp ;
  int tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  xbool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  xbool tmp___7 ;
  xbool tmp___8 ;
  xbool tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  xbool tmp___13 ;
  xbool tmp___14 ;
  xbool tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  xbool tmp___19 ;
  xbool tmp___20 ;
  xbool tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  xbool tmp___25 ;
  xbool tmp___26 ;
  xbool tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
  othermove = (xbool )0;
  pawnmates = 0;
  knightmates = 0;
  bishopmates = 0;
  rookmates = 0;
  queenmates = 0;
  pawnwarn = (xbool )0;
  knightwarn = (xbool )0;
  bishopwarn = (xbool )0;
  rookwarn = (xbool )0;
  queenwarn = (xbool )0;
  if (reset) {
    pawnmated = 0;
    knightmated = 0;
    bishopmated = 0;
    rookmated = 0;
    queenmated = 0;
    return;
  }
  tmp = in_check();
  ic = (int )tmp;
  if (white_to_move) {
    tmp___5 = 1;
  } else {
    tmp___5 = 2;
  }
  if (! holding[! white_to_move][tmp___5]) {
    if (white_to_move) {
      tmp___0 = 1;
    } else {
      tmp___0 = 2;
    }
    DropaddHolding(tmp___0, ! white_to_move);
    gen(& hismoves[0]);
    his_num_moves = numb_moves;
    i = 0;
    while (1) {
      if (i < his_num_moves) {
        if (! (pawnmates == 0)) {
          break;
        }
      } else {
        break;
      }
      make(& hismoves[0], i);
      tmp___3 = check_legal(& hismoves[0], i, ic);
      if (tmp___3) {
        pawnmates = 3;
        tmp___1 = in_check();
        icc = (int )tmp___1;
        gen(& ourmoves[0]);
        our_num_moves = numb_moves;
        j = 0;
        while (1) {
          if (j < our_num_moves) {
            if (! (pawnmates != 0)) {
              break;
            }
          } else {
            break;
          }
          make(& ourmoves[0], j);
          tmp___2 = check_legal(& ourmoves[0], j, icc);
          if (tmp___2) {
            pawnmates = 0;
          }
          unmake(& ourmoves[0], j);
          j ++;
        }
      }
      unmake(& hismoves[0], i);
      i ++;
    }
    if (white_to_move) {
      tmp___4 = 1;
    } else {
      tmp___4 = 2;
    }
    DropremoveHolding(tmp___4, ! white_to_move);
  }
  if (white_to_move) {
    tmp___11 = 3;
  } else {
    tmp___11 = 4;
  }
  if (! holding[! white_to_move][tmp___11]) {
    if (white_to_move) {
      tmp___6 = 3;
    } else {
      tmp___6 = 4;
    }
    DropaddHolding(tmp___6, ! white_to_move);
    gen(& hismoves[0]);
    his_num_moves = numb_moves;
    i = 0;
    while (1) {
      if (i < his_num_moves) {
        if (! (knightmates == 0)) {
          break;
        }
      } else {
        break;
      }
      make(& hismoves[0], i);
      tmp___9 = check_legal(& hismoves[0], i, ic);
      if (tmp___9) {
        knightmates = 3;
        tmp___7 = in_check();
        icc = (int )tmp___7;
        gen(& ourmoves[0]);
        our_num_moves = numb_moves;
        j = 0;
        while (1) {
          if (j < our_num_moves) {
            if (! (knightmates != 0)) {
              break;
            }
          } else {
            break;
          }
          make(& ourmoves[0], j);
          tmp___8 = check_legal(& ourmoves[0], j, icc);
          if (tmp___8) {
            knightmates = 0;
          }
          unmake(& ourmoves[0], j);
          j ++;
        }
      }
      unmake(& hismoves[0], i);
      i ++;
    }
    if (white_to_move) {
      tmp___10 = 3;
    } else {
      tmp___10 = 4;
    }
    DropremoveHolding(tmp___10, ! white_to_move);
  }
  if (white_to_move) {
    tmp___17 = 11;
  } else {
    tmp___17 = 12;
  }
  if (! holding[! white_to_move][tmp___17]) {
    if (white_to_move) {
      tmp___12 = 11;
    } else {
      tmp___12 = 12;
    }
    DropaddHolding(tmp___12, ! white_to_move);
    gen(& hismoves[0]);
    his_num_moves = numb_moves;
    i = 0;
    while (1) {
      if (i < his_num_moves) {
        if (! (bishopmates == 0)) {
          break;
        }
      } else {
        break;
      }
      make(& hismoves[0], i);
      tmp___15 = check_legal(& hismoves[0], i, ic);
      if (tmp___15) {
        bishopmates = 3;
        tmp___13 = in_check();
        icc = (int )tmp___13;
        gen(& ourmoves[0]);
        our_num_moves = numb_moves;
        j = 0;
        while (1) {
          if (j < our_num_moves) {
            if (! (bishopmates != 0)) {
              break;
            }
          } else {
            break;
          }
          make(& ourmoves[0], j);
          tmp___14 = check_legal(& ourmoves[0], j, icc);
          if (tmp___14) {
            bishopmates = 0;
          }
          unmake(& ourmoves[0], j);
          j ++;
        }
      }
      unmake(& hismoves[0], i);
      i ++;
    }
    if (white_to_move) {
      tmp___16 = 11;
    } else {
      tmp___16 = 12;
    }
    DropremoveHolding(tmp___16, ! white_to_move);
  }
  if (white_to_move) {
    tmp___23 = 7;
  } else {
    tmp___23 = 8;
  }
  if (! holding[! white_to_move][tmp___23]) {
    if (white_to_move) {
      tmp___18 = 7;
    } else {
      tmp___18 = 8;
    }
    DropaddHolding(tmp___18, ! white_to_move);
    gen(& hismoves[0]);
    his_num_moves = numb_moves;
    i = 0;
    while (1) {
      if (i < his_num_moves) {
        if (! (rookmates == 0)) {
          break;
        }
      } else {
        break;
      }
      make(& hismoves[0], i);
      tmp___21 = check_legal(& hismoves[0], i, ic);
      if (tmp___21) {
        rookmates = 3;
        tmp___19 = in_check();
        icc = (int )tmp___19;
        gen(& ourmoves[0]);
        our_num_moves = numb_moves;
        j = 0;
        while (1) {
          if (j < our_num_moves) {
            if (! (rookmates != 0)) {
              break;
            }
          } else {
            break;
          }
          make(& ourmoves[0], j);
          tmp___20 = check_legal(& ourmoves[0], j, icc);
          if (tmp___20) {
            rookmates = 0;
          }
          unmake(& ourmoves[0], j);
          j ++;
        }
      }
      unmake(& hismoves[0], i);
      i ++;
    }
    if (white_to_move) {
      tmp___22 = 7;
    } else {
      tmp___22 = 8;
    }
    DropremoveHolding(tmp___22, ! white_to_move);
  }
  if (white_to_move) {
    tmp___29 = 9;
  } else {
    tmp___29 = 10;
  }
  if (! holding[! white_to_move][tmp___29]) {
    if (white_to_move) {
      tmp___24 = 9;
    } else {
      tmp___24 = 10;
    }
    DropaddHolding(tmp___24, ! white_to_move);
    gen(& hismoves[0]);
    his_num_moves = numb_moves;
    i = 0;
    while (1) {
      if (i < his_num_moves) {
        if (! (queenmates == 0)) {
          break;
        }
      } else {
        break;
      }
      make(& hismoves[0], i);
      tmp___27 = check_legal(& hismoves[0], i, ic);
      if (tmp___27) {
        queenmates = 3;
        tmp___25 = in_check();
        icc = (int )tmp___25;
        gen(& ourmoves[0]);
        our_num_moves = numb_moves;
        j = 0;
        while (1) {
          if (j < our_num_moves) {
            if (! (queenmates != 0)) {
              break;
            }
          } else {
            break;
          }
          make(& ourmoves[0], j);
          tmp___26 = check_legal(& ourmoves[0], j, icc);
          if (tmp___26) {
            queenmates = 0;
          }
          unmake(& ourmoves[0], j);
          j ++;
        }
      }
      unmake(& hismoves[0], i);
      i ++;
    }
    if (white_to_move) {
      tmp___28 = 9;
    } else {
      tmp___28 = 10;
    }
    DropremoveHolding(tmp___28, ! white_to_move);
  }
  if (pawnmates != pawnmated) {
    if (pawnmates == 3) {
      pawnwarn = (xbool )1;
    } else
    if (pawnmates == 0) {
      if (pawnmated == 0) {
        printf("tellics ptell p doesn\'t mate me anymore\n");
        othermove = (xbool )1;
      }
    }
  }
  if (knightmates != knightmated) {
    if (knightmates == 3) {
      knightwarn = (xbool )1;
    } else
    if (knightmates == 0) {
      if (knightmated == 0) {
        printf("tellics ptell n doesn\'t mate me anymore\n");
        othermove = (xbool )1;
      }
    }
  }
  if (bishopmates != bishopmated) {
    if (bishopmates == 3) {
      bishopwarn = (xbool )1;
    } else
    if (bishopmates == 0) {
      if (bishopmated == 0) {
        printf("tellics ptell b doesn\'t mate me anymore\n");
        othermove = (xbool )1;
      }
    }
  }
  if (rookmates != rookmated) {
    if (rookmates == 3) {
      rookwarn = (xbool )1;
    } else
    if (rookmates == 0) {
      if (rookmated == 0) {
        printf("tellics ptell r doesn\'t mate me anymore\n");
        othermove = (xbool )1;
      }
    }
  }
  if (queenmates != queenmated) {
    if (queenmates == 3) {
      queenwarn = (xbool )1;
    } else
    if (queenmates == 0) {
      if (queenmated == 0) {
        printf("tellics ptell q doesn\'t mate me anymore\n");
        othermove = (xbool )1;
      }
    }
  }
  if (pawnwarn) {
    printf("tellics ptell ---p\n");
  }
  if (knightwarn) {
    printf("tellics ptell ---n\n");
  }
  if (bishopwarn) {
    printf("tellics ptell ---b\n");
  }
  if (rookwarn) {
    printf("tellics ptell ---r\n");
  }
  if (queenwarn) {
    printf("tellics ptell ---q\n");
  }
  if (piecedead) {
    if (othermove) {
      piecedead = (xbool )0;
      printf("tellics ptell x\n");
      printf("tellics ptell go\n");
      go_fast = (xbool )0;
    }
  }
  if (pawnmates) {
    pawnmated = pawnmates;
  } else {
    pawnmated --;
  }
  if (bishopmates) {
    bishopmated = bishopmates;
  } else {
    bishopmated --;
  }
  if (rookmates) {
    rookmated = rookmates;
  } else {
    rookmated --;
  }
  if (queenmates) {
    queenmated = queenmates;
  } else {
    queenmated --;
  }
  if (knightmates) {
    knightmated = knightmates;
  } else {
    knightmated --;
  }
  return;
}
}
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-Vxh0HOHP.i","-O3")
extern void *calloc(size_t  , size_t  ) ;
__inline static char *__inline_strcat_chk(char *__dest , char const   *__src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcat_chk(__dest, __src, tmp);
  return (tmp___0);
}
}
int result ;
xbool post ;
int xb_mode ;
int forcedwin  ;
int pn_time  ;
move_s pn_move  ;
move_s pn_saver  ;
xbool kibitzed  ;
int rootlosers[300]  ;
int alllosers  ;
int s_threat ;
int PBSize ;
void comp_to_coord(move_s move , char *str ) ;
int rdifftime(rtime_t end , rtime_t start ) ;
void StoreTT(int score , int alpha , int beta , int best , int threat , int depth ) ;
move_s proofnumbercheck(move_s compmove ) ;
void proofnumbersearch(void) ;
void proofnumberscan(void) ;
int nodecount  ;
int nodecount2  ;
int pn2  ;
int frees  ;
int iters  ;
int forwards  ;
int maxply  ;
void pn2_eval(node_t *root ) ;
void suicide_pn_eval(node_t *this ) ;
void std_pn_eval(node_t *this ) ;
void losers_pn_eval(node_t *this ) ;
unsigned char *membuff  ;
int bufftop  =    0;
void *Xmalloc(int size ) 
{ 
  int oldtop ;

  {
  oldtop = bufftop;
  bufftop += size;
  return ((void *)(membuff + oldtop));
}
}
void Xfree(void) 
{ 


  {
  bufftop = 0;
  return;
}
}
void freenodes(node_t *node ) 
{ 
  int i ;

  {
  if (! node) {
    return;
  }
  if (node->children) {
    if ((int )node->num_children > 0) {
      i = 0;
      while (i < (int )node->num_children) {
        if ((unsigned long )*(node->children + i) != (unsigned long )((struct node *)0)) {
          freenodes(*(node->children + i));
        }
        i ++;
      }
      free((void *)node->children);
    }
  }
  free((void *)node);
  return;
}
}
void pn_eval(node_t *this ) 
{ 


  {
  if (Variant == 3) {
    suicide_pn_eval(this);
  } else
  if (Variant == 4) {
    losers_pn_eval(this);
  } else {
    std_pn_eval(this);
  }
  return;
}
}
void std_pn_eval(node_t *this ) 
{ 
  int num_moves ;
  move_s moves[512] ;
  int mate ;
  int i ;
  xbool tmp ;
  int tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;

  {
  this->evaluated = (unsigned char)1;
  if (white_to_move) {
    tmp___1 = is_attacked(wking_loc, 0);
    if (tmp___1) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (! white_to_move) {
    tmp___2 = is_attacked(bking_loc, 1);
    if (tmp___2) {
      _L: /* CIL Label */ 
      num_moves = 0;
      gen(& moves[0]);
      num_moves = numb_moves;
      mate = 1;
      i = 0;
      while (i < num_moves) {
        make(& moves[0], i);
        tmp = check_legal(& moves[0], i, 1);
        if (tmp) {
          mate = 0;
          unmake(& moves[0], i);
          break;
        }
        unmake(& moves[0], i);
        i ++;
      }
      if (mate == 1) {
        if (white_to_move) {
          tmp___0 = 0;
        } else {
          tmp___0 = 1;
        }
        if (tmp___0 == root_to_move) {
          this->value = (unsigned char)0;
        } else {
          this->value = (unsigned char)1;
        }
      } else {
        this->value = (unsigned char)2;
      }
    } else {
      this->value = (unsigned char)2;
    }
  } else {
    this->value = (unsigned char)2;
  }
  return;
}
}
void suicide_pn_eval(node_t *this ) 
{ 
  int j ;
  int a ;
  int i ;
  int wp ;
  int bp ;

  {
  wp = 0;
  bp = 0;
  this->evaluated = (unsigned char)1;
  j = 1;
  a = 1;
  while (a <= piece_count) {
    i = pieces[j];
    if (! i) {
      goto __Cont;
    } else {
      a ++;
    }
    switch (board[i]) {
    case 3: 
    case 9: 
    case 5: 
    case 7: 
    case 11: 
    case 1: 
    wp ++;
    break;
    case 4: 
    case 10: 
    case 6: 
    case 8: 
    case 12: 
    case 2: 
    bp ++;
    break;
    }
    if (wp) {
      if (bp) {
        break;
      }
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  if (! wp) {
    if (! root_to_move) {
      this->value = (unsigned char)1;
    } else {
      this->value = (unsigned char)0;
    }
  } else
  if (! bp) {
    if (! root_to_move) {
      this->value = (unsigned char)0;
    } else {
      this->value = (unsigned char)1;
    }
  } else {
    this->value = (unsigned char)2;
  }
  return;
}
}
void losers_pn_eval(node_t *this ) 
{ 
  int num_moves ;
  move_s moves[512] ;
  int mate ;
  int i ;
  int j ;
  int a ;
  int wp ;
  int bp ;
  xbool tmp ;
  xbool tmp___0 ;
  int tmp___1 ;
  xbool tmp___2 ;
  xbool tmp___3 ;

  {
  wp = 0;
  bp = 0;
  this->evaluated = (unsigned char)1;
  j = 1;
  a = 1;
  while (a <= piece_count) {
    i = pieces[j];
    if (! i) {
      goto __Cont;
    } else {
      a ++;
    }
    switch (board[i]) {
    case 3: 
    case 9: 
    case 7: 
    case 11: 
    case 1: 
    wp ++;
    break;
    case 4: 
    case 10: 
    case 8: 
    case 12: 
    case 2: 
    bp ++;
    break;
    }
    if (wp) {
      if (bp) {
        break;
      }
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  if (! wp) {
    if (! root_to_move) {
      this->value = (unsigned char)1;
    } else {
      this->value = (unsigned char)0;
    }
    return;
  } else
  if (! bp) {
    if (root_to_move) {
      this->value = (unsigned char)1;
    } else {
      this->value = (unsigned char)0;
    }
    return;
  }
  if (white_to_move) {
    tmp___2 = is_attacked(wking_loc, 0);
    if (tmp___2) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (! white_to_move) {
    tmp___3 = is_attacked(bking_loc, 1);
    if (tmp___3) {
      _L: /* CIL Label */ 
      captures = (xbool )1;
      num_moves = 0;
      gen(& moves[0]);
      num_moves = numb_moves;
      captures = (xbool )0;
      mate = 1;
      i = 0;
      while (i < num_moves) {
        make(& moves[0], i);
        tmp = check_legal(& moves[0], i, 1);
        if (tmp) {
          mate = 0;
          unmake(& moves[0], i);
          break;
        }
        unmake(& moves[0], i);
        i ++;
      }
      if (mate == 1) {
        captures = (xbool )0;
        num_moves = 0;
        gen(& moves[0]);
        num_moves = numb_moves;
        i = 0;
        while (i < num_moves) {
          make(& moves[0], i);
          tmp___0 = check_legal(& moves[0], i, 1);
          if (tmp___0) {
            mate = 0;
            unmake(& moves[0], i);
            break;
          }
          unmake(& moves[0], i);
          i ++;
        }
      }
      if (mate == 1) {
        if (white_to_move) {
          tmp___1 = 0;
        } else {
          tmp___1 = 1;
        }
        if (tmp___1 == root_to_move) {
          this->value = (unsigned char)1;
        } else {
          this->value = (unsigned char)0;
        }
      } else {
        this->value = (unsigned char)2;
      }
    } else {
      this->value = (unsigned char)2;
    }
  } else {
    this->value = (unsigned char)2;
  }
  return;
}
}
node_t *select_most_proving(node_t *node ) 
{ 
  int i ;
  node_t *tnode ;
  int tmp ;

  {
  tnode = node;
  while (tnode->expanded) {
    if (white_to_move) {
      tmp = 0;
    } else {
      tmp = 1;
    }
    if (tmp == root_to_move) {
      i = 0;
      while ((*(tnode->children + i))->proof != tnode->proof) {
        i ++;
      }
    } else {
      i = 0;
      while ((*(tnode->children + i))->disproof != tnode->disproof) {
        i ++;
      }
    }
    tnode = *(tnode->children + i);
    hash_history[(move_number + ply) - 1] = hash;
    make(& tnode->move, 0);
    if (ply > maxply) {
      maxply = ply;
    }
  }
  return (tnode);
}
}
void set_proof_and_disproof_numbers(node_t *node ) 
{ 
  int proof ;
  int disproof ;
  int i ;
  move_s moves[512] ;
  int l ;
  int num_moves ;
  int ic ;
  int tmp ;
  xbool tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  xbool tmp___3 ;
  xbool tmp___4 ;
  xbool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  if (node->expanded) {
    if (white_to_move) {
      tmp = 0;
    } else {
      tmp = 1;
    }
    if (tmp != root_to_move) {
      proof = 0;
      disproof = 100000000;
      i = 0;
      while (i < (int )node->num_children) {
        proof += (*(node->children + i))->proof;
        if (proof > 100000000) {
          proof = 100000000;
        }
        if ((*(node->children + i))->disproof < disproof) {
          disproof = (*(node->children + i))->disproof;
        }
        i ++;
      }
      if (proof == 0) {
        forwards ++;
        StoreTT(999500, 1000000, -1000000, -1, 0, 200);
      } else
      if (disproof == 100000000) {
        forwards ++;
        StoreTT(999500, 1000000, -1000000, -1, 0, 200);
      } else
      if (disproof == 0) {
        forwards ++;
        StoreTT(-999500, 1000000, -1000000, -1, 0, 200);
      } else
      if (proof == 100000000) {
        forwards ++;
        StoreTT(-999500, 1000000, -1000000, -1, 0, 200);
      }
    } else {
      disproof = 0;
      proof = 100000000;
      i = 0;
      while (i < (int )node->num_children) {
        disproof += (*(node->children + i))->disproof;
        if (disproof > 100000000) {
          disproof = 100000000;
        }
        if ((*(node->children + i))->proof < proof) {
          proof = (*(node->children + i))->proof;
        }
        i ++;
      }
      if (proof == 0) {
        forwards ++;
        StoreTT(999500, 1000000, -1000000, -1, 0, 200);
      } else
      if (disproof == 100000000) {
        forwards ++;
        StoreTT(999500, 1000000, -1000000, -1, 0, 200);
      } else
      if (disproof == 0) {
        forwards ++;
        StoreTT(-999500, 1000000, -1000000, -1, 0, 200);
      } else
      if (proof == 100000000) {
        forwards ++;
        StoreTT(-999500, 1000000, -1000000, -1, 0, 200);
      }
    }
    hash_history[(move_number + ply) - 1] = hash;
    node->proof = proof;
    node->disproof = disproof;
  } else
  if (node->evaluated) {
    if ((int )node->value == 2) {
      hash_history[(move_number + ply) - 1] = hash;
      tmp___0 = is_draw();
      if (tmp___0) {
        node->proof = 50000;
        node->disproof = 50000;
        return;
      } else
      if (ply > 200) {
        node->proof = 50000;
        node->disproof = 50000;
        return;
      }
      if (Variant != 4) {
        num_moves = 0;
        gen(& moves[0]);
        num_moves = numb_moves;
        tmp___1 = in_check();
        ic = (int )tmp___1;
        if (Variant != 3) {
          l = 0;
          i = 0;
          while (i < num_moves) {
            make(& moves[0], i);
            tmp___2 = check_legal(& moves[0], i, ic);
            if (tmp___2) {
              l ++;
            }
            unmake(& moves[0], i);
            i ++;
          }
        } else {
          l = numb_moves;
        }
      } else {
        l = 0;
        captures = (xbool )1;
        num_moves = 0;
        gen(& moves[0]);
        num_moves = numb_moves;
        captures = (xbool )0;
        tmp___3 = in_check();
        ic = (int )tmp___3;
        if (num_moves) {
          i = 0;
          while (i < num_moves) {
            make(& moves[0], i);
            tmp___4 = check_legal(& moves[0], i, ic);
            if (tmp___4) {
              l ++;
            }
            unmake(& moves[0], i);
            i ++;
          }
        }
        if (! l) {
          captures = (xbool )0;
          num_moves = 0;
          gen(& moves[0]);
          num_moves = numb_moves;
          i = 0;
          while (i < num_moves) {
            make(& moves[0], i);
            tmp___5 = check_legal(& moves[0], i, ic);
            if (tmp___5) {
              l ++;
            }
            unmake(& moves[0], i);
            i ++;
          }
        }
      }
      if (l == 0) {
        node->proof = 1;
        node->disproof = 1;
      } else {
        if (white_to_move) {
          tmp___6 = 0;
        } else {
          tmp___6 = 1;
        }
        if (tmp___6 == root_to_move) {
          if (Variant != 3) {
            if (Variant != 4) {
              node->proof = 1 + ply / 50;
              node->disproof = l + ply / 50;
            } else {
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
          if (Variant == 4) {
            if (phase == 2) {
              node->proof = 1 + ply / 30;
              node->disproof = l + ply / 30;
            } else {
              node->proof = 1 + ply / 80;
              node->disproof = l + ply / 80;
            }
          } else {
            node->proof = 1 + ply / 150;
            node->disproof = l + ply / 150;
          }
        } else
        if (Variant != 3) {
          if (Variant != 4) {
            node->proof = l + ply / 50;
            node->disproof = 1 + ply / 50;
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (Variant == 4) {
          if (phase == 2) {
            node->proof = l + ply / 30;
            node->disproof = 1 + ply / 30;
          } else {
            node->proof = l + ply / 80;
            node->disproof = 1 + ply / 80;
          }
        } else {
          node->proof = l + ply / 150;
          node->disproof = 1 + ply / 150;
        }
      }
    } else
    if ((int )node->value == 0) {
      node->proof = 100000000;
      node->disproof = 0;
    } else
    if ((int )node->value == 1) {
      node->proof = 0;
      node->disproof = 100000000;
    } else
    if ((int )node->value == 3) {
      node->proof = 50000;
      node->disproof = 50000;
    }
  } else {
    tmp___7 = 1;
    node->disproof = tmp___7;
    node->proof = tmp___7;
  }
  return;
}
}
void develop_node(node_t *node ) 
{ 
  int num_moves ;
  move_s moves[512] ;
  int i ;
  int l ;
  node_t *newnode ;
  int leg ;
  int ic ;
  xbool tmp ;
  xbool tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  xbool tmp___4 ;
  int tmp___5 ;

  {
  tmp = in_check();
  ic = (int )tmp;
  if (Variant != 4) {
    num_moves = 0;
    gen(& moves[0]);
    num_moves = numb_moves;
  } else {
    captures = (xbool )1;
    leg = 0;
    num_moves = 0;
    gen(& moves[0]);
    num_moves = numb_moves;
    captures = (xbool )0;
    i = 0;
    while (i < num_moves) {
      make(& moves[0], i);
      tmp___0 = check_legal(& moves[0], i, ic);
      if (tmp___0) {
        leg = 1;
        unmake(& moves[0], i);
        break;
      }
      unmake(& moves[0], i);
      i ++;
    }
    if (leg == 0) {
      captures = (xbool )0;
      num_moves = 0;
      gen(& moves[0]);
      num_moves = numb_moves;
    }
  }
  tmp___1 = Xmalloc((int )((unsigned long )num_moves * sizeof(node_t **)));
  node->children = (node_t **)tmp___1;
  l = 0;
  i = 0;
  while (i < num_moves) {
    hash_history[(move_number + ply) - 1] = hash;
    make(& moves[0], i);
    tmp___4 = check_legal(& moves[0], i, ic);
    if (tmp___4) {
      tmp___2 = Xmalloc((int )sizeof(node_t ));
      newnode = (node_t *)tmp___2;
      newnode->value = (unsigned char)0;
      tmp___3 = 1;
      newnode->disproof = tmp___3;
      newnode->proof = tmp___3;
      newnode->num_children = (unsigned char)0;
      newnode->parent = node;
      newnode->evaluated = (unsigned char)0;
      newnode->expanded = (unsigned char)0;
      newnode->move = moves[i];
      *(node->children + l) = newnode;
      l ++;
      pn_eval(newnode);
      set_proof_and_disproof_numbers(newnode);
      unmake(& moves[0], i);
    } else {
      unmake(& moves[0], i);
    }
    i ++;
  }
  node->expanded = (unsigned char)1;
  node->num_children = (unsigned char )l;
  if ((int )node->num_children == 0) {
    node->expanded = (unsigned char)0;
    node->evaluated = (unsigned char)1;
    if (Variant != 3) {
      if (Variant != 4) {
        node->value = (unsigned char)3;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (white_to_move) {
        tmp___5 = 0;
      } else {
        tmp___5 = 1;
      }
      if (tmp___5 == root_to_move) {
        node->value = (unsigned char)1;
      } else {
        node->value = (unsigned char)0;
      }
    }
  }
  nodecount += num_moves;
  frees += num_moves;
  return;
}
}
void update_ancestors(node_t *node ) 
{ 
  node_t *tnode ;
  node_t *prevnode ;

  {
  tnode = node;
  prevnode = node;
  while ((unsigned long )tnode != (unsigned long )((node_t *)0)) {
    set_proof_and_disproof_numbers(tnode);
    prevnode = tnode;
    if (tnode->move.target != 0) {
      unmake(& tnode->move, 0);
    }
    tnode = tnode->parent;
  }
  if (prevnode->move.target != 0) {
    make(& prevnode->move, 0);
  }
  return;
}
}
void pn2_eval(node_t *root ) 
{ 
  node_t *mostproving ;
  node_t *currentnode ;
  node_t *oldparent ;

  {
  nodecount2 = 0;
  pn2 = 1;
  oldparent = root->parent;
  root->parent = (struct node *)0;
  pn_eval(root);
  set_proof_and_disproof_numbers(root);
  currentnode = root;
  while (1) {
    if (root->proof != 0) {
      if (root->disproof != 0) {
        if (! (nodecount2 < nodecount)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    mostproving = select_most_proving(root);
    develop_node(mostproving);
    update_ancestors(mostproving);
  }
  root->expanded = (unsigned char)0;
  root->num_children = (unsigned char)0;
  root->parent = oldparent;
  pn2 = 0;
  return;
}
}
void proofnumberscan(void) 
{ 
  move_s moves[512] ;
  int islegal[512] ;
  int nodesspent[512] ;
  int i ;
  int l ;
  int legal ;
  int num_moves ;
  rtime_t xstart_time ;
  node_t *root ;
  node_t *mostproving ;
  node_t *currentnode ;
  int leastlooked ;
  int leastlooked_l ;
  int leastlooked_i ;
  int losers ;
  int xnodecount ;
  int firsts ;
  int alternates ;
  char output[8] ;
  int ic ;
  float bdp ;
  int altlosers ;
  void *tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  xbool tmp___5 ;
  xbool tmp___6 ;
  rtime_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  leastlooked_l = 0;
  leastlooked_i = 0;
  xstart_time = rtime();
  tmp = calloc((size_t )PBSize, sizeof(node_t ));
  membuff = (unsigned char *)tmp;
  tmp___0 = calloc((size_t )1, sizeof(node_t ));
  root = (node_t *)tmp___0;
  gen(& moves[0]);
  num_moves = numb_moves;
  alllosers = 0;
  tmp___2 = __builtin_object_size((void *)(rootlosers), 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)(rootlosers), 0);
    __builtin___memset_chk((void *)(rootlosers), 0, sizeof(rootlosers), tmp___1);
  } else {
    __inline_memset_chk((void *)(rootlosers), 0, sizeof(rootlosers));
  }
  tmp___4 = __builtin_object_size((void *)(nodesspent), 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)(nodesspent), 0);
    __builtin___memset_chk((void *)(nodesspent), 0, sizeof(nodesspent), tmp___3);
  } else {
    __inline_memset_chk((void *)(nodesspent), 0, sizeof(nodesspent));
  }
  pn_move = dummy;
  legal = 0;
  tmp___5 = in_check();
  ic = (int )tmp___5;
  i = 0;
  while (i < num_moves) {
    make(& moves[0], i);
    tmp___6 = check_legal(& moves[0], i, ic);
    if (tmp___6) {
      legal ++;
      islegal[i] = 1;
    } else {
      islegal[i] = 0;
    }
    unmake(& moves[0], i);
    i ++;
  }
  if (legal == 0) {
    Xfree();
    free((void *)membuff);
    free((void *)root);
    return;
  }
  losers = 0;
  nodecount = 1;
  iters = 0;
  maxply = 0;
  forwards = 0;
  firsts = 0;
  alternates = 0;
  hash_history[(move_number + ply) - 1] = hash;
  if (white_to_move) {
    root_to_move = 0;
  } else {
    root_to_move = 1;
  }
  pn_eval(root);
  if ((int )root->value == 1) {
    Xfree();
    free((void *)membuff);
    free((void *)root);
    pn_move = dummy;
    return;
  } else
  if ((int )root->value == 0) {
    Xfree();
    free((void *)membuff);
    free((void *)root);
    pn_move = dummy;
    return;
  }
  set_proof_and_disproof_numbers(root);
  while (1) {
    tmp___7 = rtime();
    tmp___8 = rdifftime(tmp___7, xstart_time);
    if (tmp___8 < pn_time) {
      tmp___9 = interrupt();
      if (tmp___9) {
        break;
      } else
      if ((unsigned long )((unsigned int )bufftop) < (unsigned long )(PBSize - 10000) * sizeof(node_t )) {
        if (root->proof != 0) {
          if (! (root->disproof != 0)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    iters ++;
    xnodecount = nodecount;
    if (nodecount % 100 < 66) {
      firsts ++;
      currentnode = root;
      mostproving = select_most_proving(currentnode);
      develop_node(mostproving);
      update_ancestors(mostproving);
      i = 0;
      while ((*(root->children + i))->proof != root->proof) {
        i ++;
      }
      nodesspent[i] += nodecount - xnodecount;
      if (root->proof == 0) {
        if (root->disproof == 100000000) {
          forcedwin = 1;
          if (! kibitzed) {
            kibitzed = (xbool )1;
            printf("tellics kibitz Forced win!\n");
          }
          pn_move = (*(root->children + i))->move;
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (root->disproof == 0) {
        if (root->proof == 100000000) {
          pn_move = dummy;
          losers ++;
        }
      }
    } else {
      alternates ++;
      leastlooked = 100000000;
      l = 0;
      i = 0;
      while (i < num_moves) {
        if (nodesspent[i] < leastlooked) {
          if (islegal[i]) {
            if (! rootlosers[i]) {
              leastlooked = nodesspent[i];
              leastlooked_i = i;
              leastlooked_l = l;
            }
          }
        }
        if (islegal[i]) {
          l ++;
        }
        i ++;
      }
      if (leastlooked == 100000000) {
        nodecount += 30;
        continue;
      }
      make(& moves[0], leastlooked_i);
      currentnode = *(root->children + leastlooked_l);
      mostproving = select_most_proving(currentnode);
      develop_node(mostproving);
      update_ancestors(mostproving);
      nodesspent[leastlooked_i] += nodecount - xnodecount;
      if ((*(root->children + leastlooked_l))->proof == 0) {
        if ((*(root->children + leastlooked_l))->disproof == 100000000) {
          forcedwin = 1;
          if (! kibitzed) {
            kibitzed = (xbool )1;
            printf("tellics kibitz Forced win! (alt)\n");
          }
          pn_move = (*(root->children + leastlooked_l))->move;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if ((*(root->children + leastlooked_l))->disproof == 0) {
        if ((*(root->children + leastlooked_l))->proof == 100000000) {
          rootlosers[leastlooked_i] = 1;
          losers ++;
        }
      }
    }
  }
  l = 0;
  bdp = (float )-1;
  altlosers = 0;
  if (root->expanded) {
    i = 0;
    while (i < num_moves) {
      if (islegal[i]) {
        comp_to_san(moves[i], output);
        if ((*(root->children + l))->proof != 0) {
          if ((float )(*(root->children + l))->disproof / (float )(*(root->children + l))->proof > bdp) {
            bdp = (float )(*(root->children + l))->disproof / (float )(*(root->children + l))->proof;
            pn_move = (*(root->children + l))->move;
          }
          if ((*(root->children + l))->disproof == 0) {
            if ((*(root->children + l))->proof == 100000000) {
              altlosers ++;
            }
          }
        } else {
          forcedwin = 1;
          pn_move = (*(root->children + l))->move;
          bdp = (float )100000000;
        }
        l ++;
      }
      i ++;
    }
  }
  comp_to_san(pn_move, output);
  if (xb_mode) {
    if (post) {
      printf("tellics whisper proof %d, disproof %d, %d losers, highest depth %d, primary %d, secondary %d\n",
             root->proof, root->disproof, altlosers, maxply, firsts, alternates);
    }
  }
  if (altlosers == legal - 1) {
    printf("tellics whisper Forced reply\n");
    i = 0;
    while (i < num_moves) {
      if (! rootlosers[i]) {
        if (islegal[i]) {
          forcedwin = 1;
          pn_move = moves[i];
          break;
        }
      }
      i ++;
    }
  }
  if (altlosers == legal) {
    alllosers = 1;
  }
  Xfree();
  free((void *)membuff);
  free((void *)root);
  return;
}
}
void proofnumbersearch(void) 
{ 
  node_t *root ;
  node_t *mostproving ;
  node_t *currentnode ;
  rtime_t xstart_time ;
  char output[8192] ;
  char PV[8192] ;
  int i ;
  float bdp ;
  int oldply ;
  void *tmp ;
  void *tmp___0 ;
  rtime_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  rtime_t tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;

  {
  nodecount = 1;
  iters = 0;
  frees = 0;
  ply = 1;
  maxply = 0;
  forwards = 0;
  hash_history[(move_number + ply) - 1] = hash;
  if (white_to_move) {
    root_to_move = 0;
  } else {
    root_to_move = 1;
  }
  xstart_time = rtime();
  tmp = calloc((size_t )1, sizeof(node_t ));
  root = (node_t *)tmp;
  tmp___0 = calloc((size_t )PBSize, sizeof(node_t ));
  membuff = (unsigned char *)tmp___0;
  pn_eval(root);
  if ((int )root->value == 0) {
    pn_move = dummy;
    Xfree();
    free((void *)root);
    free((void *)membuff);
    return;
  }
  set_proof_and_disproof_numbers(root);
  currentnode = root;
  while (1) {
    if (root->proof != 0) {
      if (root->disproof != 0) {
        if (! ((unsigned long )((unsigned int )bufftop) < (unsigned long )(PBSize - 10000) * sizeof(node_t ))) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    mostproving = select_most_proving(currentnode);
    develop_node(mostproving);
    update_ancestors(mostproving);
    iters ++;
    if (iters % 32 == 0) {
      tmp___1 = rtime();
      tmp___2 = rdifftime(tmp___1, xstart_time);
      if (tmp___2 > pn_time) {
        tmp___3 = interrupt();
        if (! tmp___3) {
          break;
        }
      }
    }
  }
  printf("P: %d D: %d N: %d S: %d Mem: %2.2fM Iters: %d MaxDepth: %d\n", root->proof,
         root->disproof, nodecount, frees, (double )((float )((unsigned long )nodecount * sizeof(node_t )) / (float )1048576),
         iters, maxply);
  if (xb_mode) {
    if (post) {
      printf("tellics whisper proof %d, disproof %d, %d nodes, %d forwards, %d iters, highest depth %d\n",
             root->proof, root->disproof, nodecount, forwards, iters, maxply);
    }
  }
  if (! xb_mode) {
    tmp___4 = rtime();
    tmp___5 = rdifftime(tmp___4, xstart_time);
    printf("Time : %f\n", (double )((float )tmp___5) / 100.);
  }
  while ((unsigned long )currentnode != (unsigned long )root) {
    unmake(& currentnode->move, 0);
    currentnode = currentnode->parent;
  }
  if (root->proof == 0) {
    root->value = (unsigned char)1;
    printf("This position is WON.\n");
    printf("PV: ");
    tmp___7 = __builtin_object_size((void *)(output), 0);
    if (tmp___7 != 0xffffffffffffffffUL) {
      tmp___6 = __builtin_object_size((void *)(output), 0);
      __builtin___memset_chk((void *)(output), 0, sizeof(output), tmp___6);
    } else {
      __inline_memset_chk((void *)(output), 0, sizeof(output));
    }
    tmp___9 = __builtin_object_size((void *)(PV), 0);
    if (tmp___9 != 0xffffffffffffffffUL) {
      tmp___8 = __builtin_object_size((void *)(PV), 0);
      __builtin___memset_chk((void *)(PV), 0, sizeof(PV), tmp___8);
    } else {
      __inline_memset_chk((void *)(PV), 0, sizeof(PV));
    }
    ply = 1;
    while (currentnode->expanded) {
      if (white_to_move) {
        tmp___10 = 0;
      } else {
        tmp___10 = 1;
      }
      if (tmp___10 == root_to_move) {
        i = 0;
        while ((*(currentnode->children + i))->proof != currentnode->proof) {
          i ++;
        }
      } else {
        i = 0;
        while ((*(currentnode->children + i))->disproof != currentnode->disproof) {
          i ++;
        }
      }
      currentnode = *(currentnode->children + i);
      comp_to_coord(currentnode->move, output);
      printf("%s ", output);
      tmp___12 = __builtin_object_size((void *)(PV), 0);
      if (tmp___12 != 0xffffffffffffffffUL) {
        tmp___11 = __builtin_object_size((void *)(PV), 1);
        __builtin___strcat_chk(PV, (char const   *)(output), tmp___11);
      } else {
        __inline_strcat_chk(PV, (char const   *)(output));
      }
      tmp___14 = __builtin_object_size((void *)(PV), 0);
      if (tmp___14 != 0xffffffffffffffffUL) {
        tmp___13 = __builtin_object_size((void *)(PV), 1);
        __builtin___strcat_chk(PV, " ", tmp___13);
      } else {
        __inline_strcat_chk(PV, " ");
      }
      make(& currentnode->move, 0);
      if (ply == 1) {
        pn_move = currentnode->move;
      }
      forcedwin = 1;
    }
    oldply = ply;
    while ((unsigned long )currentnode != (unsigned long )root) {
      unmake(& currentnode->move, 0);
      currentnode = currentnode->parent;
    }
    if (! kibitzed) {
      if (xb_mode) {
        if (post) {
          kibitzed = (xbool )1;
          printf("\ntellics kibitz Forced win in %d moves.\n", oldply / 2);
        }
      }
    }
    if (oldply == 1) {
      if (root->proof == 0) {
        goto _L;
      } else
      if (root->disproof == 0) {
        _L: /* CIL Label */ 
        if (root_to_move == 0) {
          printf("\n1-0 {White mates}\n");
          result = 3;
        } else {
          printf("\n0-1 {Black mates}\n");
          result = 2;
        }
      }
    }
    printf("\n");
  } else
  if (root->disproof == 0) {
    root->value = (unsigned char)0;
    printf("This position is LOST.\n");
    pn_move = dummy;
  } else {
    root->value = (unsigned char)2;
    printf("This position is UNKNOWN.\n");
    pn_move = dummy;
  }
  bdp = (float )-1;
  i = 0;
  while (i < (int )root->num_children) {
    if ((*(root->children + i))->proof != 0) {
      if ((float )(*(root->children + i))->disproof / (float )(*(root->children + i))->proof > bdp) {
        bdp = (float )(*(root->children + i))->disproof / (float )(*(root->children + i))->proof;
        pn_move = (*(root->children + i))->move;
      }
    } else {
      pn_move = (*(root->children + i))->move;
      break;
    }
    i ++;
  }
  pn_saver = pn_move;
  free((void *)root);
  Xfree();
  free((void *)membuff);
  return;
}
}
move_s proofnumbercheck(move_s compmove ) 
{ 
  node_t *root ;
  node_t *mostproving ;
  node_t *currentnode ;
  rtime_t xstart_time ;
  move_s resmove ;
  void *tmp ;
  void *tmp___0 ;
  rtime_t tmp___1 ;
  int tmp___2 ;

  {
  if (piece_count <= 3) {
    if (Variant == 3) {
      return (compmove);
    }
  }
  nodecount = 0;
  iters = 0;
  frees = 0;
  ply = 1;
  maxply = 0;
  make(& compmove, 0);
  hash_history[(move_number + ply) - 1] = hash;
  if (white_to_move) {
    root_to_move = 0;
  } else {
    root_to_move = 1;
  }
  xstart_time = rtime();
  tmp = calloc((size_t )1, sizeof(node_t ));
  root = (node_t *)tmp;
  tmp___0 = calloc((size_t )PBSize, sizeof(node_t ));
  membuff = (unsigned char *)tmp___0;
  pn_eval(root);
  set_proof_and_disproof_numbers(root);
  currentnode = root;
  while (1) {
    if (root->proof != 0) {
      if (root->disproof != 0) {
        if (! ((unsigned long )((unsigned int )bufftop) < (unsigned long )(PBSize - 10000) * sizeof(node_t ))) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    mostproving = select_most_proving(currentnode);
    develop_node(mostproving);
    update_ancestors(mostproving);
    iters ++;
    if (iters % 32 == 0) {
      tmp___1 = rtime();
      tmp___2 = rdifftime(tmp___1, xstart_time);
      if (tmp___2 > pn_time) {
        break;
      }
    }
  }
  printf("P: %d D: %d N: %d S: %d Mem: %2.2fM Iters: %d\n", root->proof, root->disproof,
         nodecount, frees, (double )((float )((unsigned long )nodecount * sizeof(node_t )) / (float )1048576),
         iters);
  while ((unsigned long )currentnode != (unsigned long )root) {
    unmake(& currentnode->move, 0);
    currentnode = currentnode->parent;
  }
  unmake(& compmove, 0);
  if (root->proof == 0) {
    root->value = (unsigned char)1;
    resmove = pn_move;
    s_threat = 1;
  } else
  if (root->disproof == 0) {
    root->value = (unsigned char)0;
    resmove = compmove;
  } else {
    root->value = (unsigned char)2;
    resmove = compmove;
  }
  Xfree();
  free((void *)root);
  free((void *)membuff);
  return (resmove);
}
}
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-PSgBEmvw.i","-O3")
void alloc_hash(void) ;
void read_rcfile(void) ;
int cfg_booklearn  ;
int cfg_devscale  ;
int cfg_razordrop  ;
int cfg_cutdrop  ;
int cfg_futprune  ;
int cfg_onerep  ;
int cfg_recap  ;
int cfg_smarteval  ;
int cfg_attackeval  ;
float cfg_scalefac  ;
int cfg_ksafety[15][9]  ;
int cfg_tropism[5][7]  ;
int havercfile  ;
int TTSize  ;
int PBSize  ;
int ECacheSize  ;
char setcode[30] ;
FILE *rcfile  ;
char line[256]  ;
void read_rcfile(void) 
{ 
  unsigned int setc ;
  unsigned long tmp ;

  {
  TTSize = 3000000;
  ECacheSize = 1000000;
  PBSize = 200000;
  cfg_devscale = 1;
  cfg_scalefac = (float )1.0;
  cfg_razordrop = 1;
  cfg_cutdrop = 0;
  cfg_futprune = 1;
  cfg_smarteval = 1;
  cfg_attackeval = 0;
  cfg_onerep = 1;
  cfg_recap = 0;
  havercfile = 0;
  setc = (unsigned int )(((((((havercfile + (cfg_devscale << 1)) + (1 << 2)) + (cfg_razordrop << 3)) + (cfg_cutdrop << 4)) + (cfg_futprune << 5)) + (cfg_smarteval << 6)) + (cfg_attackeval << 7));
  tmp = __builtin_object_size((void *)(setcode), 1);
  __builtin___sprintf_chk(setcode, 0, tmp, "%u", setc);
  initialize_eval();
  alloc_hash();
  alloc_ecache();
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-zB_aR_w1.i","-O3")
extern int ( /* format attribute */  fprintf)(FILE * , char const   *  , ...) ;
extern int fputc(int  , FILE * ) ;
int pv_length[300] ;
int i_depth ;
int raw_nodes ;
int killer_scores[300] ;
int killer_scores2[300] ;
int killer_scores3[300] ;
int moves_to_tc ;
int inc ;
int time_left ;
int time_cushion ;
int time_for_move ;
int cur_score ;
unsigned int history_h[144][144] ;
xbool searching_pv ;
xbool time_exit ;
xbool time_failure ;
move_s pv[300][300] ;
move_s killer1[300] ;
move_s killer2[300] ;
move_s killer3[300] ;
move_s path[300] ;
rtime_t start_time ;
xbool is_pondering ;
unsigned int FH  ;
unsigned int FHF  ;
unsigned int PVS ;
unsigned int FULL ;
unsigned int PVSF ;
unsigned int ext_recap  ;
unsigned int ext_onerep  ;
unsigned int razor_drop  ;
unsigned int razor_material  ;
xbool is_analyzing ;
int tradefreely  ;
char true_i_depth  ;
int bestmovenum  ;
int ugly_ep_hack  ;
int s_threat  ;
int moveleft  ;
int movetotal  ;
char searching_move[20]  ;
int allocate_time(void) ;
void order_moves(move_s *moves , int *move_ordering , int *see_values , int num_moves ,
                 int best ) ;
void perft(int depth ) ;
void post_thinking(int score ) ;
void post_fl_thinking(int score , move_s *failmove ) ;
void post_fh_thinking(int score , move_s *failmove ) ;
void post_fail_thinking(int score , move_s *failmove ) ;
void print_move(move_s *moves , int m , FILE *stream ) ;
int qsearch(int alpha , int beta , int depth ) ;
xbool remove_one(int *marker , int *move_ordering , int num_moves ) ;
int search(int alpha , int beta , int depth , int is_null ) ;
move_s search_root(int originalalpha , int originalbeta , int depth ) ;
void tree(int depth , int indent , FILE *output , char *disp_b ) ;
void QStoreTT(int score , int alpha , int beta , int best ) ;
int ProbeTT(int *score , int beta , int *best , int *threat , int *donull , int depth ) ;
int QProbeTT(int *score , int *best ) ;
void stringize_pv(char *str ) ;
int see(int color , int square , int from ) ;
unsigned int drop_cuts  ;
char postpv[256]  ;
int legals  ;
int failed  ;
int extendedtime  ;
unsigned int rootnodecount[512]  ;
xbool checks[300]  ;
xbool recaps[300]  ;
xbool singular[300]  ;
void order_moves(move_s *moves , int *move_ordering , int *see_values , int num_moves ,
                 int best ) 
{ 
  int promoted ;
  int captured ;
  int i ;
  int from ;
  int target ;
  int seev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
  if (searching_pv) {
    searching_pv = (xbool )0;
    i = 0;
    while (i < num_moves) {
      from = (moves + i)->from;
      target = (moves + i)->target;
      promoted = (moves + i)->promoted;
      captured = (moves + i)->captured;
      if (captured != 13) {
        tmp___2 = abs(material[captured]);
        tmp___3 = abs(material[board[from]]);
        if (tmp___2 + 15 >= tmp___3) {
          tmp = abs(material[captured]);
          tmp___0 = abs(material[board[from]]);
          *(see_values + i) = tmp - (tmp___0 >> 4);
          *(move_ordering + i) = 50000000 + *(see_values + i);
        } else {
          if (white_to_move) {
            tmp___1 = 0;
          } else {
            tmp___1 = 1;
          }
          seev = see(tmp___1, target, from);
          if (seev >= -50) {
            *(move_ordering + i) = 50000000 + seev;
          } else {
            *(move_ordering + i) = seev;
          }
          *(see_values + i) = seev;
        }
      } else {
        *(move_ordering + i) = 0;
      }
      if (from == pv[1][ply].from) {
        if (target == pv[1][ply].target) {
          if (promoted == pv[1][ply].promoted) {
            searching_pv = (xbool )1;
            *(move_ordering + i) = 100000000;
            if (captured != 13) {
              tmp___7 = abs(material[captured]);
              tmp___8 = abs(material[board[from]]);
              if (tmp___7 + 15 >= tmp___8) {
                tmp___4 = abs(material[captured]);
                tmp___5 = abs(material[board[from]]);
                *(see_values + i) = tmp___4 - (tmp___5 >> 4);
              } else {
                if (white_to_move) {
                  tmp___6 = 0;
                } else {
                  tmp___6 = 1;
                }
                seev = see(tmp___6, target, from);
                *(see_values + i) = seev;
              }
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
      if (best != -1) {
        if (best != -2) {
          if (i == best) {
            *(move_ordering + i) = 100000000;
            if (captured != 13) {
              tmp___12 = abs(material[captured]);
              tmp___13 = abs(material[board[from]]);
              if (tmp___12 + 15 >= tmp___13) {
                tmp___9 = abs(material[captured]);
                tmp___10 = abs(material[board[from]]);
                *(see_values + i) = tmp___9 - (tmp___10 >> 4);
              } else {
                if (white_to_move) {
                  tmp___11 = 0;
                } else {
                  tmp___11 = 1;
                }
                seev = see(tmp___11, target, from);
                *(see_values + i) = seev;
              }
            }
          } else {
            goto _L___5;
          }
        } else {
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
      if (best == -2) {
        if (from == pv[ply + 1][ply + 1].from) {
          if (target == pv[ply + 1][ply + 1].target) {
            if (promoted == pv[ply + 1][ply + 1].promoted) {
              *(move_ordering + i) = 100000000;
              if (captured != 13) {
                tmp___17 = abs(material[captured]);
                tmp___18 = abs(material[board[from]]);
                if (tmp___17 + 15 >= tmp___18) {
                  tmp___14 = abs(material[captured]);
                  tmp___15 = abs(material[board[from]]);
                  *(see_values + i) = tmp___14 - (tmp___15 >> 4);
                } else {
                  if (white_to_move) {
                    tmp___16 = 0;
                  } else {
                    tmp___16 = 1;
                  }
                  seev = see(tmp___16, target, from);
                  *(see_values + i) = seev;
                }
              }
            }
          }
        }
      } else
      if (ply != 1) {
        goto _L___3;
      } else
      if (i_depth < 2) {
        _L___3: /* CIL Label */ 
        *(move_ordering + i) = (int )((unsigned int )*(move_ordering + i) + history_h[from][target]);
        if (from == killer1[ply].from) {
          if (target == killer1[ply].target) {
            if (promoted == killer1[ply].promoted) {
              *(move_ordering + i) += 25000000;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
        if (from == killer2[ply].from) {
          if (target == killer2[ply].target) {
            if (promoted == killer2[ply].promoted) {
              *(move_ordering + i) += 20000000;
            } else {
              goto _L___0;
            }
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (from == killer3[ply].from) {
          if (target == killer3[ply].target) {
            if (promoted == killer3[ply].promoted) {
              *(move_ordering + i) += 15000000;
            }
          }
        }
      } else
      if (nodes / 100 > 100000000) {
        *(move_ordering + i) = (int )(rootnodecount[i] / 1000U);
      } else {
        *(move_ordering + i) = (int )(rootnodecount[i] / 100U);
      }
      i ++;
    }
  } else {
    i = 0;
    while (i < num_moves) {
      from = (moves + i)->from;
      target = (moves + i)->target;
      promoted = (moves + i)->promoted;
      captured = (moves + i)->captured;
      if (best != -1) {
        if (i == best) {
          *(move_ordering + i) = 100000000;
          if (captured != 13) {
            tmp___22 = abs(material[captured]);
            tmp___23 = abs(material[board[from]]);
            if (tmp___22 + 15 >= tmp___23) {
              tmp___19 = abs(material[captured]);
              tmp___20 = abs(material[board[from]]);
              *(see_values + i) = tmp___19 - (tmp___20 >> 4);
            } else {
              if (white_to_move) {
                tmp___21 = 0;
              } else {
                tmp___21 = 1;
              }
              seev = see(tmp___21, target, from);
              *(see_values + i) = seev;
            }
          }
        } else {
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
      if (best == -2) {
        if (from == pv[ply + 1][ply + 1].from) {
          if (target == pv[ply + 1][ply + 1].target) {
            if (promoted == pv[ply + 1][ply + 1].promoted) {
              *(move_ordering + i) = 100000000;
              if (captured != 13) {
                tmp___27 = abs(material[captured]);
                tmp___28 = abs(material[board[from]]);
                if (tmp___27 + 15 >= tmp___28) {
                  tmp___24 = abs(material[captured]);
                  tmp___25 = abs(material[board[from]]);
                  *(see_values + i) = tmp___24 - (tmp___25 >> 4);
                } else {
                  if (white_to_move) {
                    tmp___26 = 0;
                  } else {
                    tmp___26 = 1;
                  }
                  seev = see(tmp___26, target, from);
                  *(see_values + i) = seev;
                }
              }
            }
          }
        }
      } else
      if (captured != 13) {
        tmp___32 = abs(material[captured]);
        tmp___33 = abs(material[board[from]]);
        if (tmp___32 + 15 >= tmp___33) {
          tmp___29 = abs(material[captured]);
          tmp___30 = abs(material[board[from]]);
          *(see_values + i) = tmp___29 - (tmp___30 >> 4);
          *(move_ordering + i) = 50000000 + *(see_values + i);
        } else {
          if (white_to_move) {
            tmp___31 = 0;
          } else {
            tmp___31 = 1;
          }
          seev = see(tmp___31, target, from);
          if (seev >= -50) {
            *(move_ordering + i) = 50000000 + seev;
          } else {
            *(move_ordering + i) = seev;
          }
          *(see_values + i) = seev;
        }
      } else {
        *(move_ordering + i) = 0;
      }
      *(move_ordering + i) = (int )((unsigned int )*(move_ordering + i) + history_h[from][target]);
      if (from == killer1[ply].from) {
        if (target == killer1[ply].target) {
          if (promoted == killer1[ply].promoted) {
            *(move_ordering + i) += 25000000;
          } else {
            goto _L___12;
          }
        } else {
          goto _L___12;
        }
      } else
      _L___12: /* CIL Label */ 
      if (from == killer2[ply].from) {
        if (target == killer2[ply].target) {
          if (promoted == killer2[ply].promoted) {
            *(move_ordering + i) += 20000000;
          } else {
            goto _L___10;
          }
        } else {
          goto _L___10;
        }
      } else
      _L___10: /* CIL Label */ 
      if (from == killer3[ply].from) {
        if (target == killer3[ply].target) {
          if (promoted == killer3[ply].promoted) {
            *(move_ordering + i) += 15000000;
          }
        }
      }
      i ++;
    }
  }
  return;
}
}
void perft(int depth ) 
{ 
  move_s moves[512] ;
  int num_moves ;
  int i ;
  int ic ;
  xbool tmp ;
  xbool tmp___0 ;

  {
  num_moves = 0;
  if (! depth) {
    raw_nodes ++;
    return;
  }
  gen(& moves[0]);
  num_moves = numb_moves;
  tmp = in_check();
  ic = (int )tmp;
  i = 0;
  while (i < num_moves) {
    make(& moves[0], i);
    tmp___0 = check_legal(& moves[0], i, ic);
    if (tmp___0) {
      perft(depth - 1);
    }
    unmake(& moves[0], i);
    i ++;
  }
  return;
}
}
int qsearch(int alpha , int beta , int depth ) 
{ 
  move_s moves[512] ;
  int num_moves ;
  int i ;
  int j ;
  int score ;
  int standpat ;
  int move_ordering[512] ;
  int see_values[512] ;
  xbool legal_move ;
  xbool no_moves ;
  int sbest ;
  int best_score ;
  int best ;
  int delta ;
  int bound ;
  int originalalpha ;
  int oldtime ;
  int seev ;
  int tmp ;
  int tmp___0 ;
  rtime_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  xbool tmp___6 ;

  {
  score = -1000000;
  no_moves = (xbool )1;
  pv_length[ply] = ply;
  if (! (nodes & ((1 << 16) - 1))) {
    tmp___3 = interrupt();
    if (tmp___3) {
      time_exit = (xbool )1;
      return (0);
    } else {
      tmp___1 = rtime();
      tmp___2 = rdifftime(tmp___1, start_time);
      if (tmp___2 >= time_for_move) {
        if (i_depth > 1) {
          if (failed == 1) {
            if (! extendedtime) {
              if (! fixed_time) {
                if (! go_fast) {
                  if (Variant != 1) {
                    if (time_for_move * 4 > 1000) {
                      tmp___0 = time_for_move * 4;
                    } else {
                      tmp___0 = 1000;
                    }
                    if (time_left > tmp___0) {
                      extendedtime = 1;
                      oldtime = time_for_move;
                      tmp = allocate_time();
                      time_for_move += tmp;
                      printf("Extended from %d to %d, time left %d\n", oldtime, time_for_move,
                             time_left);
                    } else {
                      time_exit = (xbool )1;
                      return (0);
                    }
                  } else {
                    time_exit = (xbool )1;
                    return (0);
                  }
                } else {
                  time_exit = (xbool )1;
                  return (0);
                }
              } else {
                time_exit = (xbool )1;
                return (0);
              }
            } else {
              time_exit = (xbool )1;
              return (0);
            }
          } else {
            time_exit = (xbool )1;
            return (0);
          }
        }
      }
    }
  }
  if (depth <= 0) {
    score = eval(alpha, beta);
    return (score);
  } else
  if (ply >= 300) {
    score = eval(alpha, beta);
    return (score);
  }
  qnodes ++;
  nodes ++;
  originalalpha = alpha;
  tmp___4 = QProbeTT(& bound, & best);
  switch (tmp___4) {
  case 3: 
  return (bound);
  break;
  case 1: 
  if (bound <= alpha) {
    return (bound);
  }
  break;
  case 2: 
  if (bound >= beta) {
    return (bound);
  }
  break;
  case 0: 
  break;
  case 4: 
  best = -1;
  break;
  }
  standpat = eval(alpha, beta);
  if (standpat >= beta) {
    QStoreTT(standpat, originalalpha, beta, 500);
    return (standpat);
  } else
  if (standpat > alpha) {
    alpha = standpat;
  }
  sbest = -1;
  best_score = -1000000;
  num_moves = 0;
  gen(& moves[0]);
  num_moves = numb_moves;
  if (kingcap) {
    return (50000);
  }
  delta = (alpha - 150) - standpat;
  order_moves(& moves[0], & move_ordering[0], & see_values[0], num_moves, best);
  while (1) {
    tmp___6 = remove_one(& i, & move_ordering[0], num_moves);
    if (! tmp___6) {
      break;
    }
    legal_move = (xbool )0;
    if (! moves[i].promoted) {
      seev = see_values[i];
      if (seev < delta) {
        continue;
      } else
      if (seev < 0) {
        continue;
      }
    }
    make(& moves[0], i);
    tmp___5 = qsearch(- beta, - alpha, depth - 1);
    score = - tmp___5;
    if (score != -50000) {
      legal_move = (xbool )1;
      no_moves = (xbool )0;
    }
    unmake(& moves[0], i);
    if (score > best_score) {
      if (legal_move) {
        best_score = score;
      }
    }
    if (score > alpha) {
      if (legal_move) {
        best = i;
        if (score >= beta) {
          QStoreTT(score, originalalpha, beta, i);
          return (score);
        }
        alpha = score;
        pv[ply][ply] = moves[i];
        j = ply + 1;
        while (j < pv_length[ply + 1]) {
          pv[ply][j] = pv[ply + 1][j];
          j ++;
        }
        pv_length[ply] = pv_length[ply + 1];
      }
    }
  }
  QStoreTT(alpha, originalalpha, beta, best);
  return (alpha);
}
}
xbool remove_one(int *marker , int *move_ordering , int num_moves ) 
{ 
  int i ;
  int best ;

  {
  best = -1000000;
  *marker = -1000000;
  i = 0;
  while (i < num_moves) {
    if (*(move_ordering + i) > best) {
      *marker = i;
      best = *(move_ordering + i);
    }
    i ++;
  }
  if (*marker > -1000000) {
    *(move_ordering + *marker) = -1000000;
    return ((xbool )1);
  } else {
    return ((xbool )0);
  }
}
}
static int const   rc_index[14]  = 
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )2,      (int const   )5,      (int const   )5,      (int const   )3, 
        (int const   )3,      (int const   )4,      (int const   )4,      (int const   )2, 
        (int const   )2,      (int const   )0};
int search(int alpha , int beta , int depth , int is_null ) 
{ 
  move_s moves[512] ;
  int num_moves ;
  int i ;
  int j ;
  int score ;
  int move_ordering[512] ;
  int see_values[512] ;
  xbool no_moves ;
  xbool legal_move ;
  int bound ;
  int threat ;
  int donull ;
  int best ;
  int sbest ;
  int best_score ;
  int old_ep ;
  xbool incheck ;
  xbool first ;
  int extend ;
  int fscore ;
  int fmax ;
  int selective ;
  move_s kswap ;
  int ksswap ;
  int originalalpha ;
  int afterincheck ;
  int legalmoves ;
  int dropcut ;
  int oldtime ;
  int tmp ;
  int tmp___0 ;
  rtime_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  xbool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  xbool tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  xbool tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  xbool tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  xbool tmp___30 ;
  xbool tmp___31 ;
  xbool tmp___32 ;

  {
  score = -1000000;
  nodes ++;
  if (! (nodes & ((1 << 16) - 1))) {
    tmp___3 = interrupt();
    if (tmp___3) {
      time_exit = (xbool )1;
      return (0);
    } else {
      tmp___1 = rtime();
      tmp___2 = rdifftime(tmp___1, start_time);
      if (tmp___2 >= time_for_move) {
        if (i_depth > 1) {
          if (failed == 1) {
            if (! extendedtime) {
              if (! fixed_time) {
                if (! go_fast) {
                  if (Variant != 1) {
                    if (time_for_move * 4 > 1000) {
                      tmp___0 = time_for_move * 4;
                    } else {
                      tmp___0 = 1000;
                    }
                    if (time_left > tmp___0) {
                      extendedtime = 1;
                      oldtime = time_for_move;
                      tmp = allocate_time();
                      time_for_move += tmp;
                      printf("Extended from %d to %d, time left %d\n", oldtime, time_for_move,
                             time_left);
                    } else {
                      time_exit = (xbool )1;
                      return (0);
                    }
                  } else {
                    time_exit = (xbool )1;
                    return (0);
                  }
                } else {
                  time_exit = (xbool )1;
                  return (0);
                }
              } else {
                time_exit = (xbool )1;
                return (0);
              }
            } else {
              time_exit = (xbool )1;
              return (0);
            }
          } else {
            time_exit = (xbool )1;
            return (0);
          }
        }
      }
    }
  }
  originalalpha = alpha;
  fmax = -1000000;
  threat = 0;
  extend = 0;
  pv_length[ply] = ply;
  tmp___4 = is_draw();
  if (tmp___4) {
    return (0);
  }
  incheck = checks[ply];
  singular[ply] = (xbool )0;
  recaps[ply] = (xbool )0;
  if (ply < 300) {
    if (incheck) {
      if (ply <= i_depth * 2) {
        depth ++;
        ext_check ++;
        extend ++;
      } else
      if (depth == 0) {
        depth ++;
        ext_check ++;
        extend ++;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (ply < 300) {
    if (ply > 2) {
      if (ply <= i_depth * 2) {
        if (! recaps[ply - 2]) {
          if (cfg_recap) {
            if (path[ply - 1].captured != 13) {
              if (rc_index[path[ply - 1].captured] == rc_index[path[ply - 2].captured]) {
                depth ++;
                ext_recap ++;
                extend ++;
                recaps[ply] = (xbool )1;
              }
            }
          }
        }
      }
    }
  }
  if (depth <= 0) {
    goto _L___2;
  } else
  if (ply >= 300) {
    _L___2: /* CIL Label */ 
    if (Variant != 3) {
      if (Variant != 4) {
        captures = (xbool )1;
        score = qsearch(alpha, beta, 300 - ply);
        captures = (xbool )0;
        return (score);
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (Variant == 3) {
      tmp___5 = suicide_eval();
      return (tmp___5);
    } else
    if (Variant == 4) {
      i = losers_eval();
      tmp___7 = abs(i);
      if (tmp___7 == 1000000) {
        if (i > 0) {
          tmp___6 = 1000000 - ply;
        } else {
          tmp___6 = -1000000 + ply;
        }
        return (tmp___6);
      } else {
        return (i);
      }
    }
  }
  num_moves = 0;
  no_moves = (xbool )1;
  tmp___8 = ProbeTT(& bound, beta, & best, & threat, & donull, depth);
  switch (tmp___8) {
  case 3: 
  return (bound);
  break;
  case 1: 
  if (bound <= alpha) {
    return (bound);
  }
  break;
  case 2: 
  if (bound >= beta) {
    return (bound);
  }
  break;
  case 0: 
  break;
  case 4: 
  best = -1;
  threat = 0;
  break;
  }
  if (best == 500) {
    best = -1;
  }
  sbest = -1;
  best_score = -1000000;
  old_ep = ep_square;
  legalmoves = 0;
  if (Variant == 4) {
    i = losers_eval();
    tmp___10 = abs(i);
    if (tmp___10 == 1000000) {
      if (i > 0) {
        tmp___9 = i - ply;
      } else {
        tmp___9 = i + ply;
      }
      return (tmp___9);
    }
    captures = (xbool )1;
    gen(& moves[0]);
    num_moves = numb_moves;
    captures = (xbool )0;
    if (num_moves) {
      i = 0;
      while (i < num_moves) {
        make(& moves[0], i);
        tmp___11 = check_legal(& moves[0], i, (int )incheck);
        if (tmp___11) {
          legalmoves ++;
        }
        unmake(& moves[0], i);
        i ++;
      }
    }
    if (! legalmoves) {
      captures = (xbool )0;
      gen(& moves[0]);
      num_moves = numb_moves;
    }
    legalmoves = 0;
  }
  if (is_null == 0) {
    if (phase != 2) {
      goto _L___11;
    } else
    if (phase == 2) {
      if (depth <= 6) {
        _L___11: /* CIL Label */ 
        if (! incheck) {
          if (donull) {
            if (! searching_pv) {
              if (threat == 0) {
                if (Variant != 3) {
                  if (Variant != 4) {
                    goto _L___4;
                  } else {
                    goto _L___5;
                  }
                } else
                _L___5: /* CIL Label */ 
                if (Variant == 4) {
                  if (moves[0].captured == 13) {
                    _L___4: /* CIL Label */ 
                    ep_square = 0;
                    white_to_move ^= 1;
                    ply ++;
                    fifty ++;
                    hash ^= 3735928559U;
                    if (Variant != 2) {
                      if (Variant != 4) {
                        if (depth > 3) {
                          tmp___12 = (depth - 2) - 1;
                        } else {
                          tmp___12 = (depth - 1) - 1;
                        }
                        tmp___13 = search(- beta, - beta + 1, tmp___12, 1);
                        score = - tmp___13;
                      } else {
                        tmp___14 = search(- beta, - beta + 1, (depth - 3) - 1, 1);
                        score = - tmp___14;
                      }
                    } else {
                      tmp___14 = search(- beta, - beta + 1, (depth - 3) - 1, 1);
                      score = - tmp___14;
                    }
                    hash ^= 3735928559U;
                    fifty --;
                    ply --;
                    white_to_move ^= 1;
                    ep_square = old_ep;
                    if (time_exit) {
                      return (0);
                    }
                    NTries ++;
                    if (score >= beta) {
                      NCuts ++;
                      StoreTT(score, alpha, beta, 500, 0, depth);
                      return (score);
                    } else
                    if (score < -999900) {
                      threat = 1;
                      TExt ++;
                      depth ++;
                      extend ++;
                      ext_onerep ++;
                    }
                  } else {
                    goto _L___10;
                  }
                } else {
                  goto _L___10;
                }
              } else {
                goto _L___10;
              }
            } else {
              goto _L___10;
            }
          } else {
            goto _L___10;
          }
        } else {
          goto _L___10;
        }
      } else {
        goto _L___10;
      }
    } else {
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
  if (threat == 1) {
    TExt ++;
    depth ++;
    extend ++;
    ext_onerep ++;
  }
  score = -1000000;
  if (Variant != 4) {
    gen(& moves[0]);
    num_moves = numb_moves;
  }
  if (cfg_onerep) {
    if (incheck) {
      if (num_moves) {
        i = 0;
        while (1) {
          if (i < num_moves) {
            if (! (legalmoves < 2)) {
              break;
            }
          } else {
            break;
          }
          make(& moves[0], i);
          tmp___15 = check_legal(& moves[0], i, (int )incheck);
          if (tmp___15) {
            legalmoves ++;
          }
          unmake(& moves[0], i);
          i ++;
        }
      }
    }
  }
  if (ply < 300) {
    if (Variant == 3) {
      if (num_moves == 1) {
        depth ++;
        ext_onerep ++;
        singular[ply] = (xbool )1;
      } else {
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
    if (legalmoves == 1) {
      if (! singular[ply - 2]) {
        depth ++;
        ext_onerep ++;
        singular[ply] = (xbool )1;
      }
    }
  }
  first = (xbool )1;
  selective = 0;
  if (phase != 2) {
    if (Variant != 3) {
      if (cfg_futprune) {
        if (white_to_move) {
          tmp___16 = Material;
        } else {
          tmp___16 = - Material;
        }
        fscore = tmp___16 + 900;
        if (! extend) {
          if (depth == 3) {
            if (fscore <= alpha) {
              depth = 2;
            }
          }
        }
        if (white_to_move) {
          tmp___17 = Material;
        } else {
          tmp___17 = - Material;
        }
        fscore = tmp___17 + 500;
        if (! extend) {
          if (depth == 2) {
            if (fscore <= alpha) {
              selective = 1;
              fmax = fscore;
              best_score = fmax;
            }
          }
        }
        if (white_to_move) {
          tmp___18 = Material;
        } else {
          tmp___18 = - Material;
        }
        if (Variant == 2) {
          tmp___19 = 150;
        } else {
          tmp___19 = 200;
        }
        fscore = tmp___18 + tmp___19;
        if (! extend) {
          if (depth == 1) {
            if (fscore <= alpha) {
              selective = 1;
              fmax = fscore;
              best_score = fmax;
            }
          }
        }
      }
    }
  }
  if (num_moves > 0) {
    order_moves(& moves[0], & move_ordering[0], & see_values[0], num_moves, best);
    while (1) {
      tmp___31 = remove_one(& i, & move_ordering[0], num_moves);
      if (! tmp___31) {
        break;
      }
      make(& moves[0], i);
      legal_move = (xbool )0;
      hash_history[(move_number + ply) - 1] = hash;
      path[ply - 1] = moves[i];
      extend = 0;
      tmp___30 = check_legal(& moves[0], i, (int )incheck);
      if (tmp___30) {
        tmp___20 = f_in_check(& moves[0], i);
        afterincheck = (int )tmp___20;
        checks[ply] = (xbool )afterincheck;
        if (! afterincheck) {
          if (Variant == 2) {
            goto _L___14;
          } else
          if (Variant == 3) {
            goto _L___14;
          } else
          if (Variant == 4) {
            _L___14: /* CIL Label */ 
            if (depth < 3) {
              if (board[moves[i].target] == 1) {
                if (Xrank[moves[i].target] >= 6) {
                  extend ++;
                } else {
                  goto _L___13;
                }
              } else
              _L___13: /* CIL Label */ 
              if (board[moves[i].target] == 2) {
                if (Xrank[moves[i].target] <= 3) {
                  extend ++;
                }
              }
            }
          }
        }
        dropcut = 0;
        if (moves[i].from == 0) {
          if (depth > 1) {
            if (afterincheck == 0) {
              if ((unsigned int )incheck == 0U) {
                if (! searching_pv) {
                  if (cfg_razordrop) {
                    razor_drop ++;
                    extend --;
                  } else {
                    goto _L___19;
                  }
                } else {
                  goto _L___19;
                }
              } else {
                goto _L___19;
              }
            } else {
              goto _L___19;
            }
          } else {
            goto _L___19;
          }
        } else
        _L___19: /* CIL Label */ 
        if (moves[i].from == 0) {
          if (depth == 1) {
            if ((unsigned int )incheck == 0U) {
              if (cfg_cutdrop) {
                if (white_to_move) {
                  tmp___21 = calc_attackers(moves[i].target, 1);
                  tmp___22 = calc_attackers(moves[i].target, 0);
                  dropcut = tmp___21 - tmp___22 > 0;
                  if (dropcut) {
                    drop_cuts ++;
                  }
                } else {
                  tmp___23 = calc_attackers(moves[i].target, 0);
                  tmp___24 = calc_attackers(moves[i].target, 1);
                  dropcut = tmp___23 - tmp___24 > 0;
                  if (dropcut) {
                    drop_cuts ++;
                  }
                }
              }
            }
          }
        }
        if (! dropcut) {
          if (! selective) {
            goto _L___20;
          } else
          if (afterincheck != 0) {
            goto _L___20;
          } else {
            tmp___28 = abs(material[moves[i].captured]);
            if (Variant == 2) {
              tmp___29 = 1;
            } else
            if (Variant == 4) {
              tmp___29 = 1;
            } else {
              tmp___29 = 2;
            }
            if (fmax + tmp___28 * tmp___29 > alpha) {
              goto _L___20;
            } else
            if (moves[i].promoted) {
              _L___20: /* CIL Label */ 
              if ((unsigned int )first == 1U) {
                tmp___25 = search(- beta, - alpha, (depth + extend) - 1, 0);
                score = - tmp___25;
                FULL ++;
              } else {
                tmp___26 = search(- alpha - 1, - alpha, (depth + extend) - 1, 0);
                score = - tmp___26;
                PVS ++;
                if (score > best_score) {
                  if (! time_exit) {
                    if (score != -50000) {
                      if (score > alpha) {
                        if (score < beta) {
                          tmp___27 = search(- beta, - alpha, (depth + extend) - 1,
                                            0);
                          score = - tmp___27;
                          PVSF ++;
                          if (score > best_score) {
                            best_score = score;
                          }
                        } else {
                          best_score = score;
                        }
                      } else {
                        best_score = score;
                      }
                    }
                  }
                }
              }
              legal_move = (xbool )1;
            } else {
              razor_material ++;
            }
          }
        } else {
          razor_material ++;
        }
        legalmoves ++;
        no_moves = (xbool )0;
      }
      if (score > best_score) {
        if (legal_move) {
          best_score = score;
        }
      }
      unmake(& moves[0], i);
      if (time_exit) {
        return (0);
      }
      if (score > alpha) {
        if (legal_move) {
          if (score >= beta) {
            (history_h[moves[i].from][moves[i].target]) ++;
            if (moves[i].captured == 13) {
              if (moves[i].from == killer1[ply].from) {
                if (moves[i].target == killer1[ply].target) {
                  if (moves[i].promoted == killer1[ply].promoted) {
                    (killer_scores[ply]) ++;
                  } else {
                    goto _L___24;
                  }
                } else {
                  goto _L___24;
                }
              } else
              _L___24: /* CIL Label */ 
              if (moves[i].from == killer2[ply].from) {
                if (moves[i].target == killer2[ply].target) {
                  if (moves[i].promoted == killer2[ply].promoted) {
                    (killer_scores2[ply]) ++;
                    if (killer_scores2[ply] > killer_scores[ply]) {
                      kswap = killer1[ply];
                      killer1[ply] = killer2[ply];
                      killer2[ply] = kswap;
                      ksswap = killer_scores[ply];
                      killer_scores[ply] = killer_scores2[ply];
                      killer_scores2[ply] = ksswap;
                    }
                  } else {
                    goto _L___22;
                  }
                } else {
                  goto _L___22;
                }
              } else
              _L___22: /* CIL Label */ 
              if (moves[i].from == killer3[ply].from) {
                if (moves[i].target == killer3[ply].target) {
                  if (moves[i].promoted == killer3[ply].promoted) {
                    (killer_scores3[ply]) ++;
                    if (killer_scores3[ply] > killer_scores2[ply]) {
                      kswap = killer2[ply];
                      killer2[ply] = killer3[ply];
                      killer3[ply] = kswap;
                      ksswap = killer_scores2[ply];
                      killer_scores2[ply] = killer_scores3[ply];
                      killer_scores3[ply] = ksswap;
                    }
                  } else {
                    killer_scores3[ply] = 1;
                    killer3[ply] = moves[i];
                  }
                } else {
                  killer_scores3[ply] = 1;
                  killer3[ply] = moves[i];
                }
              } else {
                killer_scores3[ply] = 1;
                killer3[ply] = moves[i];
              }
            }
            if ((unsigned int )first == 1U) {
              FHF ++;
            }
            FH ++;
            StoreTT(score, originalalpha, beta, i, threat, depth);
            return (score);
          }
          alpha = score;
          sbest = i;
          pv[ply][ply] = moves[i];
          j = ply + 1;
          while (j < pv_length[ply + 1]) {
            pv[ply][j] = pv[ply + 1][j];
            j ++;
          }
          pv_length[ply] = pv_length[ply + 1];
        }
      }
      if (legal_move) {
        first = (xbool )0;
      }
    }
  } else {
    StoreTT(1000000 - ply, originalalpha, beta, 0, threat, depth);
    return (1000000 - ply);
  }
  if (no_moves) {
    if (Variant != 4) {
      if (Variant != 3) {
        tmp___32 = in_check();
        if (tmp___32) {
          StoreTT(-1000000 + ply, originalalpha, beta, 0, threat, depth);
          return (-1000000 + ply);
        } else {
          StoreTT(0, originalalpha, beta, 0, threat, depth);
          return (0);
        }
      } else {
        StoreTT(1000000 - ply, originalalpha, beta, 0, threat, depth);
        return (1000000 - ply);
      }
    } else {
      StoreTT(1000000 - ply, originalalpha, beta, 0, threat, depth);
      return (1000000 - ply);
    }
  } else
  if (fifty > 100) {
    return (0);
  }
  if (sbest == -1) {
    sbest = 500;
  }
  if (best_score <= originalalpha) {
    if (! selective) {
      StoreTT(best_score, originalalpha, beta, sbest, threat, depth);
    }
  } else
  if (! selective) {
    StoreTT(best_score, originalalpha, beta, sbest, threat, depth);
  } else {
    StoreTT(best_score, -1000000, -1000000, sbest, threat, depth);
  }
  return (best_score);
}
}
move_s search_root(int originalalpha , int originalbeta , int depth ) 
{ 
  move_s moves[512] ;
  move_s best_move ;
  int num_moves ;
  int i ;
  int j ;
  int root_score ;
  int move_ordering[512] ;
  int see_values[512] ;
  xbool no_moves ;
  xbool legal_move ;
  xbool first ;
  int alpha ;
  int beta ;
  move_s kswap ;
  int ksswap ;
  int incheck ;
  int mc ;
  int oldnodecount ;
  xbool tmp ;
  xbool tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  xbool tmp___6 ;
  xbool tmp___7 ;
  xbool tmp___8 ;

  {
  best_move = dummy;
  root_score = -1000000;
  mc = 0;
  alpha = originalalpha;
  beta = originalbeta;
  num_moves = 0;
  no_moves = (xbool )1;
  ply = 1;
  searching_pv = (xbool )1;
  time_exit = (xbool )0;
  time_failure = (xbool )0;
  first = (xbool )1;
  cur_score = -1000000;
  nodes ++;
  tmp = is_draw();
  if (tmp) {
    result = 5;
    cur_score = 0;
    pv_length[ply] = 0;
    return (dummy);
  }
  pv_length[ply] = ply;
  hash_history[(move_number + ply) - 1] = hash;
  tmp___0 = in_check();
  incheck = (int )tmp___0;
  if (incheck) {
    ext_check ++;
    depth ++;
  }
  checks[ply] = (xbool )incheck;
  recaps[ply] = (xbool )0;
  singular[ply] = (xbool )0;
  if (Variant == 4) {
    legals = 0;
    captures = (xbool )1;
    gen(& moves[0]);
    num_moves = numb_moves;
    captures = (xbool )0;
    if (num_moves) {
      i = 0;
      while (i < num_moves) {
        make(& moves[0], i);
        tmp___1 = check_legal(& moves[0], i, incheck);
        if (tmp___1) {
          legals ++;
        }
        unmake(& moves[0], i);
        i ++;
      }
    }
    if (! legals) {
      captures = (xbool )0;
      gen(& moves[0]);
      num_moves = numb_moves;
      i = 0;
      while (i < num_moves) {
        make(& moves[0], i);
        tmp___2 = check_legal(& moves[0], i, incheck);
        if (tmp___2) {
          legals ++;
        }
        unmake(& moves[0], i);
        i ++;
      }
    }
  } else {
    gen(& moves[0]);
    num_moves = numb_moves;
  }
  movetotal = legals;
  order_moves(& moves[0], & move_ordering[0], & see_values[0], num_moves, -1);
  while (1) {
    tmp___7 = remove_one(& i, & move_ordering[0], num_moves);
    if (! tmp___7) {
      break;
    }
    if (! alllosers) {
      if (rootlosers[i]) {
        if (Variant == 4) {
          continue;
        } else
        if (Variant == 3) {
          continue;
        }
      }
    }
    make(& moves[0], i);
    legal_move = (xbool )0;
    hash_history[(move_number + ply) - 1] = hash;
    path[ply - 1] = moves[i];
    oldnodecount = nodes;
    tmp___6 = check_legal(& moves[0], i, incheck);
    if (tmp___6) {
      unmake(& moves[0], i);
      mc ++;
      moveleft = movetotal - mc;
      comp_to_san(moves[i], searching_move);
      make(& moves[0], i);
      checks[ply] = f_in_check(& moves[0], i);
      recaps[ply] = (xbool )0;
      singular[ply] = (xbool )0;
      if ((unsigned int )first == 1U) {
        goto _L___0;
      } else
      if (i_depth < 2) {
        _L___0: /* CIL Label */ 
        tmp___3 = search(- beta, - alpha, depth - 1, 0);
        root_score = - tmp___3;
        if (! time_exit) {
          if (post) {
            goto _L;
          } else
          if (! xb_mode) {
            _L: /* CIL Label */ 
            if (i_depth >= 2) {
              if (root_score >= beta) {
                post_fh_thinking(root_score, & moves[i]);
              } else
              if (root_score <= alpha) {
                failed = 1;
                post_fl_thinking(root_score, & moves[i]);
              } else {
                pv[ply - 1][ply - 1] = moves[i];
                j = ply;
                while (j < pv_length[ply]) {
                  pv[ply - 1][j] = pv[ply][j];
                  j ++;
                }
                pv_length[ply - 1] = pv_length[ply];
                post_thinking(root_score);
              }
              if (root_score > cur_score) {
                if (! time_exit) {
                  cur_score = root_score;
                  bestmovenum = i;
                  best_move = moves[i];
                }
              }
            }
          }
        }
      } else {
        tmp___4 = search(- alpha - 1, - alpha, depth - 1, 0);
        root_score = - tmp___4;
        if (root_score > alpha) {
          if (root_score < beta) {
            if (! time_exit) {
              post_fail_thinking(root_score, & moves[i]);
              tmp___5 = search(- beta, - alpha, depth - 1, 0);
              root_score = - tmp___5;
              if (root_score > alpha) {
                if (! time_exit) {
                  failed = 0;
                  cur_score = root_score;
                  bestmovenum = i;
                  best_move = moves[i];
                  if (root_score < beta) {
                    if (i_depth >= 2) {
                      pv[ply - 1][ply - 1] = moves[i];
                      j = ply;
                      while (j < pv_length[ply]) {
                        pv[ply - 1][j] = pv[ply][j];
                        j ++;
                      }
                      pv_length[ply - 1] = pv_length[ply];
                    }
                  }
                }
              }
            }
          }
        }
        if (root_score >= beta) {
          if (! time_exit) {
            post_fh_thinking(root_score, & moves[i]);
          }
        }
      }
      if (root_score > cur_score) {
        if (! time_exit) {
          cur_score = root_score;
          bestmovenum = i;
          best_move = moves[i];
        }
      }
      if (time_exit) {
        if (cur_score == -1000000) {
          if (no_moves) {
            time_failure = (xbool )1;
          }
        }
      }
      no_moves = (xbool )0;
      legal_move = (xbool )1;
    }
    unmake(& moves[0], i);
    if (time_exit) {
      return (best_move);
    }
    if (root_score > alpha) {
      if (legal_move) {
        if (moves[i].from == killer1[ply].from) {
          if (moves[i].target == killer1[ply].target) {
            if (moves[i].promoted == killer1[ply].promoted) {
              (killer_scores[ply]) ++;
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
        if (moves[i].from == killer2[ply].from) {
          if (moves[i].target == killer2[ply].target) {
            if (moves[i].promoted == killer2[ply].promoted) {
              (killer_scores2[ply]) ++;
              if (killer_scores2[ply] > killer_scores[ply]) {
                kswap = killer1[ply];
                killer1[ply] = killer2[ply];
                killer2[ply] = kswap;
                ksswap = killer_scores[ply];
                killer_scores[ply] = killer_scores2[ply];
                killer_scores2[ply] = ksswap;
              }
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
        if (moves[i].from == killer3[ply].from) {
          if (moves[i].target == killer3[ply].target) {
            if (moves[i].promoted == killer3[ply].promoted) {
              (killer_scores3[ply]) ++;
              if (killer_scores3[ply] > killer_scores2[ply]) {
                kswap = killer2[ply];
                killer2[ply] = killer3[ply];
                killer3[ply] = kswap;
                ksswap = killer_scores2[ply];
                killer_scores2[ply] = killer_scores3[ply];
                killer_scores3[ply] = ksswap;
              }
            } else {
              killer_scores3[ply] = 1;
              killer3[ply] = moves[i];
            }
          } else {
            killer_scores3[ply] = 1;
            killer3[ply] = moves[i];
          }
        } else {
          killer_scores3[ply] = 1;
          killer3[ply] = moves[i];
        }
        (history_h[moves[i].from][moves[i].target]) ++;
        alpha = root_score;
        best_move = moves[i];
        bestmovenum = i;
        cur_score = alpha;
        pv[ply][ply] = moves[i];
        j = ply + 1;
        while (j < pv_length[ply + 1]) {
          pv[ply][j] = pv[ply + 1][j];
          j ++;
        }
        pv_length[ply] = pv_length[ply + 1];
        if (cur_score >= beta) {
          return (best_move);
        }
        if (post) {
          if (i_depth >= 2) {
            post_thinking(alpha);
          }
        }
      }
    }
    if (legal_move) {
      first = (xbool )0;
    }
    rootnodecount[i] = (unsigned int )(nodes - oldnodecount);
  }
  if (no_moves) {
    if (! is_pondering) {
      if (Variant != 3) {
        if (Variant != 4) {
          tmp___8 = in_check();
          if (tmp___8) {
            if (white_to_move == 1) {
              result = 2;
            } else {
              result = 3;
            }
          } else {
            result = 1;
          }
        } else {
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
      if (white_to_move == 1) {
        result = 3;
      } else {
        result = 2;
      }
    } else {
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
  if (! is_pondering) {
    if (fifty > 100) {
      result = 4;
      cur_score = 0;
      pv_length[ply] = 0;
      return (dummy);
    }
  }
  return (best_move);
}
}
move_s think(void) 
{ 
  move_s comp_move ;
  move_s temp_move ;
  move_s old_move ;
  int i ;
  int j ;
  int k ;
  int elapsed ;
  int temp_score ;
  int true_score ;
  int alpha ;
  int beta ;
  int tmptmp ;
  int rs ;
  move_s moves[512] ;
  int l ;
  int lastlegal ;
  int ic ;
  int pn_restart ;
  int num_moves ;
  char output[8] ;
  int tmp ;
  xbool tmp___0 ;
  xbool tmp___1 ;
  xbool tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  rtime_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  rtime_t tmp___13 ;

  {
  k = 0;
  temp_score = 0;
  lastlegal = 0;
  userealholdings = 0;
  pn_restart = 0;
  restart: 
  nodes = 0;
  qnodes = 0;
  ply = 1;
  ECacheProbes = 0U;
  ECacheHits = 0U;
  TTProbes = 0U;
  TTHits = 0U;
  TTStores = 0U;
  NCuts = 0U;
  NTries = 0U;
  TExt = 0U;
  FH = 0U;
  FHF = 0U;
  PVS = 0U;
  FULL = 0U;
  PVSF = 0U;
  ext_check = 0U;
  ext_recap = 0U;
  ext_onerep = 0U;
  razor_drop = 0U;
  razor_material = 0U;
  drop_cuts = 0U;
  rs = 0;
  extendedtime = 0;
  forcedwin = 0;
  maxposdiff = 200;
  true_i_depth = (char)0;
  bestmovenum = -1;
  tmp = interrupt();
  if (tmp) {
    if (is_analyzing) {
      return (dummy);
    } else
    if (is_pondering) {
      return (dummy);
    }
  }
  start_time = rtime();
  legals = 0;
  if (Variant == 4) {
    captures = (xbool )1;
  } else {
    captures = (xbool )0;
  }
  gen(& moves[0]);
  num_moves = numb_moves;
  tmp___0 = in_check();
  ic = (int )tmp___0;
  l = 0;
  while (l < numb_moves) {
    make(& moves[0], l);
    tmp___1 = check_legal(& moves[0], l, ic);
    if (tmp___1) {
      legals ++;
      lastlegal = l;
    }
    unmake(& moves[0], l);
    l ++;
  }
  if (Variant == 4) {
    if (legals == 0) {
      captures = (xbool )0;
      num_moves = 0;
      gen(& moves[0]);
      num_moves = numb_moves;
      l = 0;
      while (l < numb_moves) {
        make(& moves[0], l);
        tmp___2 = check_legal(& moves[0], l, ic);
        if (tmp___2) {
          legals ++;
          lastlegal = l;
        }
        unmake(& moves[0], l);
        l ++;
      }
    }
  }
  if (Variant != 1) {
    if (! is_pondering) {
      if (legals == 1) {
        time_cushion += inc * 100;
        return (moves[lastlegal]);
      }
    }
  }
  check_phase();
  switch (phase) {
  case 0: 
  printf("Opening phase.\n");
  break;
  case 1: 
  printf("Middlegame phase.\n");
  break;
  case 2: 
  printf("Endgame phase.\n");
  break;
  }
  if (! is_pondering) {
    if (! fixed_time) {
      if (go_fast) {
        tmptmp = allocate_time();
        if (tmptmp > 40) {
          time_for_move = 40;
        } else {
          time_for_move = tmptmp;
        }
      } else {
        time_for_move = allocate_time();
      }
    } else {
      time_for_move = fixed_time;
    }
  } else {
    time_for_move = 999999;
  }
  if (pn_restart) {
    time_for_move = (int )((double )((float )time_for_move * (float )2) / ((double )((float )pn_restart) + 1.0));
  }
  printf("Time for move : %d\n", time_for_move);
  if (! pn_restart) {
    clear_tt();
    reset_ecache();
    tmp___4 = __builtin_object_size((void *)(rootlosers), 0);
    if (tmp___4 != 0xffffffffffffffffUL) {
      tmp___3 = __builtin_object_size((void *)(rootlosers), 0);
      __builtin___memset_chk((void *)(rootlosers), 0, sizeof(rootlosers), tmp___3);
    } else {
      __inline_memset_chk((void *)(rootlosers), 0, sizeof(rootlosers));
    }
  }
  if (! pn_restart) {
    if (! is_pondering) {
      if (Variant == 3) {
        goto _L___1;
      } else
      if (Variant == 4) {
        _L___1: /* CIL Label */ 
        if (piece_count > 3) {
          pn_time = (int )(((double )((float )time_for_move) * 1.0) / 3.0);
          proofnumberscan();
        } else
        if (Variant != 3) {
          pn_time = (int )(((double )((float )time_for_move) * 1.0) / 3.0);
          proofnumberscan();
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (! pn_restart) {
    pn_move = dummy;
  }
  if (result) {
    if (pn_move.target == dummy.target) {
      return (pn_move);
    }
  }
  if (forcedwin) {
    goto _L___6;
  } else
  if (result) {
    _L___6: /* CIL Label */ 
    if (pn_move.target != dummy.target) {
      if (! is_analyzing) {
        comp_move = pn_move;
      } else {
        goto _L___5;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    i = 0;
    while (i < 300) {
      j = 0;
      while (j < 300) {
        pv[i][j] = dummy;
        j ++;
      }
      i ++;
    }
    tmp___6 = __builtin_object_size((void *)(history_h), 0);
    if (tmp___6 != 0xffffffffffffffffUL) {
      tmp___5 = __builtin_object_size((void *)(history_h), 0);
      __builtin___memset_chk((void *)(history_h), 0, sizeof(history_h), tmp___5);
    } else {
      __inline_memset_chk((void *)(history_h), 0, sizeof(history_h));
    }
    i = 0;
    while (i < 300) {
      killer_scores[i] = 0;
      killer_scores2[i] = 0;
      killer_scores3[i] = 0;
      killer1[i] = dummy;
      killer2[i] = dummy;
      killer3[i] = dummy;
      i ++;
    }
    tmp___8 = __builtin_object_size((void *)(rootnodecount), 0);
    if (tmp___8 != 0xffffffffffffffffUL) {
      tmp___7 = __builtin_object_size((void *)(rootnodecount), 0);
      __builtin___memset_chk((void *)(rootnodecount), 0, sizeof(rootnodecount), tmp___7);
    } else {
      __inline_memset_chk((void *)(rootnodecount), 0, sizeof(rootnodecount));
    }
    temp_score = 0;
    cur_score = 0;
    true_score = 0;
    i_depth = 1;
    while (i_depth <= maxdepth) {
      tmp___9 = rtime();
      elapsed = rdifftime(tmp___9, start_time);
      if ((double )elapsed > ((double )time_for_move * 2.1) / 3.0) {
        if (i_depth > 2) {
          break;
        }
      }
      failed = 0;
      if (Variant == 2) {
        tmp___10 = 35;
      } else {
        tmp___10 = 100;
      }
      alpha = temp_score - tmp___10;
      if (Variant == 2) {
        tmp___11 = 35;
      } else {
        tmp___11 = 100;
      }
      beta = temp_score + tmp___11;
      temp_move = search_root(alpha, beta, i_depth);
      if (result) {
        break;
      }
      if (cur_score <= alpha) {
        failed = 1;
      } else {
        failed = 0;
      }
      if (cur_score <= alpha) {
        if (! time_exit) {
          rs ++;
          temp_move = search_root(-1000000, 1000000, i_depth);
          if (! time_exit) {
            failed = 0;
          }
        } else {
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
      if (cur_score >= beta) {
        if (! time_exit) {
          comp_move = temp_move;
          temp_score = cur_score;
          rs ++;
          temp_move = search_root(-1000000, 1000000, i_depth);
          if (! time_exit) {
            failed = 0;
          }
        }
      }
      tmp___12 = interrupt();
      if (tmp___12) {
        if (i_depth > 1) {
          if (is_pondering) {
            return (dummy);
          } else
          if (! go_fast) {
            break;
          }
        }
      }
      if (! time_failure) {
        if (! failed) {
          if (cur_score == -1000000) {
            return (dummy);
          }
          comp_move = temp_move;
          temp_score = cur_score;
          stringize_pv(postpv);
          if (! time_exit) {
            true_i_depth = (char )i_depth;
          }
          if (i_depth >= 2) {
            post_thinking(cur_score);
          }
          if (temp_score > 900000) {
            if (1000000 - cur_score < i_depth) {
              break;
            }
          }
        }
      }
      if (time_exit) {
        break;
      }
      j = 0;
      while (j < 300) {
        killer_scores[j] = 0;
        killer_scores2[j] = 0;
        killer_scores3[j] = 0;
        j ++;
      }
      i_depth ++;
    }
  }
  if (! forcedwin) {
    old_move = comp_move;
    if (Variant == 4) {
      goto _L___7;
    } else
    if (Variant == 3) {
      _L___7: /* CIL Label */ 
      if (! result) {
        if (! alllosers) {
          if (! is_pondering) {
            s_threat = 0;
            comp_move = proofnumbercheck(comp_move);
            if (pn_restart < 10) {
              if (s_threat) {
                pn_restart ++;
                i = 0;
                while (i < num_moves) {
                  if (moves[i].from == old_move.from) {
                    if (moves[i].target == old_move.target) {
                      if (moves[i].promoted == old_move.promoted) {
                        rootlosers[i] = 1;
                        break;
                      }
                    }
                  }
                  i ++;
                }
                j = 0;
                while (j < num_moves) {
                  if (rootlosers[j]) {
                    k ++;
                  }
                  j ++;
                }
                if (k == legals) {
                  alllosers = 1;
                }
                goto restart;
              }
            }
          }
        }
      }
    }
  }
  if (alllosers) {
    comp_move = old_move;
  }
  if (pn_restart != 0) {
    if (xb_mode) {
      comp_to_san(comp_move, output);
      printf("tellics whisper %d restart(s), ended up with %s\n", pn_restart, output);
      result = 0;
    }
  }
  tmp___13 = rtime();
  elapsed = rdifftime(tmp___13, start_time);
  time_left -= elapsed;
  if (moves_to_tc) {
    if (! is_pondering) {
      time_cushion += (time_for_move - elapsed) + inc;
    }
  }
  if (temp_score == 999998) {
    if (! is_pondering) {
      if (white_to_move == 1) {
        result = 3;
      } else {
        result = 2;
      }
    } else {
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
  if (temp_score == -999998) {
    if (! is_pondering) {
      if (white_to_move == 1) {
        result = 2;
      } else {
        result = 3;
      }
    }
  }
  if (post) {
    if (xb_mode) {
      if (! is_pondering) {
        if (result != 3) {
          if (result != 2) {
            if (result != 4) {
              if (result != 5) {
                if (result != 1) {
                  if (! forcedwin) {
                    if (temp_score > 999600) {
                      if (Variant != 1) {
                        printf("tellics kibitz Mate in %d\n", (1000000 - temp_score) / 2);
                      } else {
                        printf("tellics ptell Mate in %d, give him no more pieces.\n",
                               (1000000 - temp_score) / 2);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (result != 2) {
    if (result != 3) {
      if (result != 1) {
        if (result != 4) {
          if (result != 5) {
            if ((int )true_i_depth >= 3) {
              if (pn_move.target == dummy.target) {
                if (! is_pondering) {
                  if (Variant != 1) {
                    if (bestmovenum == -1) {
                      *((int *)((void *)0)) = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (Variant == 1) {
    if (temp_score > -999900) {
      if (tradefreely == 0) {
        if (! userealholdings) {
          tradefreely = 1;
          printf("tellics ptell You can trade freely.\n");
        }
      }
    } else {
      goto _L___11;
    }
  } else
  _L___11: /* CIL Label */ 
  if (temp_score < -999900) {
    if (Variant == 1) {
      if (pn_move.target == dummy.target) {
        if (userealholdings) {
          must_sit = (xbool )1;
        } else {
          userealholdings = 1;
          ProcessHoldings(realholdings);
          tradefreely = 0;
          printf("tellics ptell ---trades\n");
          goto restart;
        }
        if (temp_score > -1000000) {
          if (partnerdead) {
            printf("tellics kibitz Both players dead...resigning...\n");
            printf("tellics resign\n");
          } else {
            printf("tellics ptell I am forcedly mated (dead). Tell me \'go\' to start moving into it.\n");
          }
        }
      } else {
        goto _L___10;
      }
    } else {
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
  if (temp_score > -60000) {
    if (temp_score < -40000) {
      if (Variant == 1) {
        if (! partnerdead) {
          if (pn_move.target == dummy.target) {
            must_sit = (xbool )1;
            printf("tellics ptell I\'ll have to sit...(lose piece that mates you)\n");
          }
        }
      }
    }
  }
  return (comp_move);
}
}
void tree(int depth , int indent , FILE *output , char *disp_b ) 
{ 
  move_s moves[512] ;
  int num_moves ;
  int i ;
  int j ;
  int ic ;
  xbool tmp ;
  xbool tmp___0 ;

  {
  num_moves = 0;
  if (! depth) {
    return;
  }
  gen(& moves[0]);
  num_moves = numb_moves;
  tmp = in_check();
  ic = (int )tmp;
  i = 0;
  while (i < num_moves) {
    make(& moves[0], i);
    tmp___0 = check_legal(& moves[0], i, ic);
    if (tmp___0) {
      j = 0;
      while (j < indent) {
        fputc(' ', output);
        j ++;
      }
      print_move(& moves[0], i, output);
      fprintf(output, "\n");
      if ((int )*(disp_b + 0) == 121) {
        display_board(output, 1);
      }
      tree(depth - 1, indent + 2, output, disp_b);
    }
    unmake(& moves[0], i);
    i ++;
  }
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-_5idgYlt.i","-O3")
see_data see_attackers[2][16]  ;
int see_num_attackers[2]  ;
void setup_attackers(int square ) ;
static int const   rook_o___2[4]  = {      (int const   )12,      (int const   )-12,      (int const   )1,      (int const   )-1};
static int const   bishop_o___2[4]  = {      (int const   )11,      (int const   )-11,      (int const   )13,      (int const   )-13};
static int const   knight_o___5[8]  = 
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
void setup_attackers(int square ) 
{ 
  register int a_sq ;
  register int b_sq ;
  register int i ;
  int numw ;
  int numb ;

  {
  numw = see_num_attackers[0];
  numb = see_num_attackers[1];
  i = 0;
  while (i < 4) {
    a_sq = square + (int )rook_o___2[i];
    b_sq = board[a_sq];
    if (b_sq == 5) {
      see_attackers[0][numw].piece = b_sq;
      see_attackers[0][numw].square = a_sq;
      numw ++;
      break;
    } else
    if (b_sq == 6) {
      see_attackers[1][numb].piece = b_sq;
      see_attackers[1][numb].square = a_sq;
      numb ++;
      break;
    } else {
      while (b_sq != 0) {
        if (b_sq == 7) {
          see_attackers[0][numw].piece = b_sq;
          see_attackers[0][numw].square = a_sq;
          numw ++;
          break;
        } else
        if (b_sq == 9) {
          see_attackers[0][numw].piece = b_sq;
          see_attackers[0][numw].square = a_sq;
          numw ++;
          break;
        } else
        if (b_sq == 8) {
          see_attackers[1][numb].piece = b_sq;
          see_attackers[1][numb].square = a_sq;
          numb ++;
          break;
        } else
        if (b_sq == 10) {
          see_attackers[1][numb].piece = b_sq;
          see_attackers[1][numb].square = a_sq;
          numb ++;
          break;
        } else
        if (b_sq != 13) {
          break;
        }
        a_sq += (int )rook_o___2[i];
        b_sq = board[a_sq];
      }
    }
    i ++;
  }
  i = 0;
  while (i < 4) {
    a_sq = square + (int )bishop_o___2[i];
    b_sq = board[a_sq];
    if (b_sq == 1) {
      if (i % 2) {
        see_attackers[0][numw].piece = b_sq;
        see_attackers[0][numw].square = a_sq;
        numw ++;
        break;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (b_sq == 2) {
      if (! (i % 2)) {
        see_attackers[1][numb].piece = b_sq;
        see_attackers[1][numb].square = a_sq;
        numb ++;
        break;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (b_sq == 5) {
      see_attackers[0][numw].piece = b_sq;
      see_attackers[0][numw].square = a_sq;
      numw ++;
      break;
    } else
    if (b_sq == 6) {
      see_attackers[1][numb].piece = b_sq;
      see_attackers[1][numb].square = a_sq;
      numb ++;
      break;
    } else {
      while (b_sq != 0) {
        if (b_sq == 11) {
          see_attackers[0][numw].piece = b_sq;
          see_attackers[0][numw].square = a_sq;
          numw ++;
          break;
        } else
        if (b_sq == 9) {
          see_attackers[0][numw].piece = b_sq;
          see_attackers[0][numw].square = a_sq;
          numw ++;
          break;
        } else
        if (b_sq == 12) {
          see_attackers[1][numb].piece = b_sq;
          see_attackers[1][numb].square = a_sq;
          numb ++;
          break;
        } else
        if (b_sq == 10) {
          see_attackers[1][numb].piece = b_sq;
          see_attackers[1][numb].square = a_sq;
          numb ++;
          break;
        } else
        if (b_sq != 13) {
          break;
        }
        a_sq += (int )bishop_o___2[i];
        b_sq = board[a_sq];
      }
    }
    i ++;
  }
  i = 0;
  while (i < 8) {
    a_sq = square + (int )knight_o___5[i];
    b_sq = board[a_sq];
    if (b_sq == 3) {
      see_attackers[0][numw].piece = b_sq;
      see_attackers[0][numw].square = a_sq;
      numw ++;
    } else
    if (b_sq == 4) {
      see_attackers[1][numb].piece = b_sq;
      see_attackers[1][numb].square = a_sq;
      numb ++;
    }
    i ++;
  }
  see_num_attackers[0] = numw;
  see_num_attackers[1] = numb;
  return;
}
}
void findlowest(int color , int next___0 ) 
{ 
  int lowestp ;
  int lowestv ;
  see_data swap ;
  int i ;
  int tmp ;

  {
  lowestp = next___0;
  lowestv = abs(material[see_attackers[color][next___0].piece]);
  i = next___0;
  while (i < see_num_attackers[color]) {
    tmp = abs(material[see_attackers[color][i].piece]);
    if (tmp < lowestv) {
      lowestp = i;
      lowestv = abs(material[see_attackers[color][i].piece]);
    }
    i ++;
  }
  swap = see_attackers[color][next___0];
  see_attackers[color][next___0] = see_attackers[color][lowestp];
  see_attackers[color][lowestp] = swap;
  return;
}
}
int see(int color , int square , int from ) 
{ 
  int sside ;
  int caps[2] ;
  int value ;
  int origpiece ;
  int ourbestvalue ;
  int hisbestvalue ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  see_num_attackers[0] = 0;
  see_num_attackers[1] = 0;
  origpiece = board[from];
  board[from] = 13;
  (see_num_attackers[color]) ++;
  see_attackers[color][0].piece = origpiece;
  see_attackers[color][0].square = from;
  setup_attackers(square);
  value = abs(material[board[square]]);
  if (! see_num_attackers[! color]) {
    board[from] = origpiece;
    return (value);
  } else {
    hisbestvalue = value;
    ourbestvalue = -1000000;
  }
  caps[color] = 1;
  caps[! color] = 0;
  sside = ! color;
  while (caps[sside] < see_num_attackers[sside]) {
    findlowest(sside, caps[sside]);
    if (sside == color) {
      tmp = abs(material[see_attackers[! sside][caps[! sside] - 1].piece]);
      value += tmp;
      if (see_num_attackers[! sside] <= caps[! sside]) {
        if (value > ourbestvalue) {
          ourbestvalue = value;
        }
      }
      if (value < hisbestvalue) {
        hisbestvalue = value;
      }
    } else {
      tmp___0 = abs(material[see_attackers[! sside][caps[! sside] - 1].piece]);
      value -= tmp___0;
      if (value > ourbestvalue) {
        ourbestvalue = value;
      }
      if (see_num_attackers[! sside] <= caps[! sside]) {
        if (value < hisbestvalue) {
          hisbestvalue = value;
        }
      }
    }
    (caps[sside]) ++;
    sside ^= 1;
  }
  board[from] = origpiece;
  if (ourbestvalue > hisbestvalue) {
    tmp___1 = hisbestvalue;
  } else {
    tmp___1 = ourbestvalue;
  }
  return (tmp___1);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-ojKuGbfb.i","-O3")
int suicide_mid_eval(void) ;
static int scentral[144]  = 
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      -20,      -10, 
        -10,      -10,      -10,      -10, 
        -10,      -20,      0,      0, 
        0,      0,      -10,      0, 
        3,      5,      5,      3, 
        0,      -10,      0,      0, 
        0,      0,      -10,      2, 
        15,      15,      15,      15, 
        2,      -10,      0,      0, 
        0,      0,      -10,      7, 
        15,      25,      25,      15, 
        7,      -10,      0,      0, 
        0,      0,      -10,      7, 
        15,      25,      25,      15, 
        7,      -10,      0,      0, 
        0,      0,      -10,      2, 
        15,      15,      15,      15, 
        2,      -10,      0,      0, 
        0,      0,      -10,      0, 
        3,      5,      5,      3, 
        0,      -10,      0,      0, 
        0,      0,      -20,      -10, 
        -10,      -10,      -10,      -10, 
        -10,      -20,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
static int const   knight_o___6[8]  = 
  {      (int const   )10,      (int const   )-10,      (int const   )14,      (int const   )-14, 
        (int const   )23,      (int const   )-23,      (int const   )25,      (int const   )-25};
static int const   king_o___0[8]  = 
  {      (int const   )13,      (int const   )12,      (int const   )11,      (int const   )1, 
        (int const   )-1,      (int const   )-11,      (int const   )-12,      (int const   )-13};
static int s_bishop_mobility(int square ) 
{ 
  register int l ;
  register int m ;

  {
  m = 0;
  l = square - 13;
  while (board[l] == 13) {
    m ++;
    l -= 13;
  }
  l = square - 11;
  while (board[l] == 13) {
    m ++;
    l -= 11;
  }
  l = square + 11;
  while (board[l] == 13) {
    m ++;
    l += 11;
  }
  l = square + 13;
  while (board[l] == 13) {
    m ++;
    l += 13;
  }
  return (m << 2);
}
}
static int s_rook_mobility(int square ) 
{ 
  register int l ;
  register int m ;

  {
  m = 0;
  l = square - 12;
  while (board[l] == 13) {
    m ++;
    l -= 12;
  }
  l = square - 1;
  while (board[l] == 13) {
    m ++;
    l --;
  }
  l = square + 1;
  while (board[l] == 13) {
    m ++;
    l ++;
  }
  l = square + 12;
  while (board[l] == 13) {
    m ++;
    l += 12;
  }
  return (m << 2);
}
}
static int s_knight_mobility(int square ) 
{ 
  register int d ;
  register int m ;

  {
  m = 0;
  d = 0;
  while (d < 8) {
    if (board[square + (int )knight_o___6[d]] == 13) {
      m ++;
    }
    d ++;
  }
  return (m << 2);
}
}
static int s_pawn_mobility(int square ) 
{ 
  register int m ;

  {
  m = 0;
  if (board[square] == 1) {
    if (board[square + 12] == 13) {
      m ++;
    }
  } else
  if (board[square - 12] == 13) {
    m ++;
  }
  return (m << 3);
}
}
static int s_king_mobility(int square ) 
{ 
  register int d ;
  register int m ;

  {
  m = 0;
  d = 0;
  while (d < 8) {
    if (board[square + (int )king_o___0[d]] == 13) {
      m ++;
    }
    d ++;
  }
  return (m << 2);
}
}
static int black_saccers(int square ) 
{ 
  register int f ;
  xbool tmp___0 ;
  xbool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  f = 0;
  if (board[square + 24] == 2) {
    return (0);
  } else
  if (board[square + 22] == 2) {
    return (0);
  } else
  if (board[square + 26] == 2) {
    return (0);
  }
  if (Xrank[square] < 6) {
    if (board[square + 25] == 2) {
      f = 1;
    } else
    if (board[square + 23] == 2) {
      f = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (Xrank[square] == 4) {
    if (board[square + 35] == 2) {
      f = 1;
    } else
    if (board[square + 37] == 2) {
      f = 1;
    }
  }
  if (! f) {
    tmp___0 = is_attacked(square + 11, 0);
    if (tmp___0) {
      f = 1;
    } else {
      f = 0;
    }
  }
  if (! f) {
    tmp___2 = is_attacked(square + 13, 0);
    if (tmp___2) {
      f = 2;
    } else {
      f = 0;
    }
  }
  if (! f) {
    return (0);
  } else
  if (f == 1) {
    tmp___3 = calc_attackers(square + 11, 0);
    if (tmp___3 > 1) {
      return (0);
    } else {
      return (30);
    }
  } else {
    tmp___4 = calc_attackers(square + 13, 0);
    if (tmp___4 > 1) {
      return (0);
    } else {
      return (30);
    }
  }
}
}
static int white_saccers(int square ) 
{ 
  register int f ;
  xbool tmp___0 ;
  xbool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  f = 0;
  if (board[square - 24] == 1) {
    return (0);
  } else
  if (board[square - 22] == 1) {
    return (0);
  } else
  if (board[square - 26] == 1) {
    return (0);
  }
  if (Xrank[square] > 3) {
    if (board[square - 25] == 1) {
      f = 1;
    } else
    if (board[square - 23] == 1) {
      f = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (Xrank[square] == 5) {
    if (board[square - 35] == 1) {
      f = 1;
    } else
    if (board[square - 37] == 1) {
      f = 1;
    }
  }
  if (! f) {
    tmp___0 = is_attacked(square - 11, 1);
    if (tmp___0) {
      f = 1;
    } else {
      f = 0;
    }
  }
  if (! f) {
    tmp___2 = is_attacked(square - 13, 1);
    if (tmp___2) {
      f = 2;
    } else {
      f = 0;
    }
  }
  if (! f) {
    return (0);
  } else
  if (f == 1) {
    tmp___3 = calc_attackers(square - 11, 1);
    if (tmp___3 > 1) {
      return (0);
    } else {
      return (30);
    }
  } else {
    tmp___4 = calc_attackers(square - 13, 1);
    if (tmp___4 > 1) {
      return (0);
    } else {
      return (30);
    }
  }
}
}
int suicide_eval(void) 
{ 
  int tmp ;

  {
  tmp = suicide_mid_eval();
  return (tmp);
}
}
int suicide_mid_eval(void) 
{ 
  int srank ;
  int pawn_file ;
  int pawns[2][11] ;
  int white_back_pawn[11] ;
  int black_back_pawn[11] ;
  int isolated ;
  int backwards ;
  int i ;
  int a ;
  int j ;
  int score ;
  int in_cache ;
  int wb ;
  int bb ;
  int wbc ;
  int bbc ;
  int wk ;
  int bk ;
  int wr ;
  int br ;
  int wn ;
  int bn ;
  int wp ;
  int bp ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  score = 0;
  wb = 0;
  bb = 0;
  wbc = 0;
  bbc = 0;
  wk = 0;
  bk = 0;
  wr = 0;
  br = 0;
  wn = 0;
  bn = 0;
  wp = 0;
  bp = 0;
  in_cache = 0;
  checkECache(& score, & in_cache);
  if (in_cache) {
    if (white_to_move == 1) {
      return (score);
    }
    return (- score);
  }
  score = Material;
  tmp___0 = __builtin_object_size((void *)(pawns), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(pawns), 0);
    __builtin___memset_chk((void *)(pawns), 0, sizeof(pawns), tmp);
  } else {
    __inline_memset_chk((void *)(pawns), 0, sizeof(pawns));
  }
  i = 0;
  while (i < 11) {
    white_back_pawn[i] = 7;
    black_back_pawn[i] = 2;
    i ++;
  }
  j = 1;
  a = 1;
  while (a <= piece_count) {
    i = pieces[j];
    if (! i) {
      goto __Cont;
    } else {
      a ++;
    }
    pawn_file = (int )(Xfile[i] + 1);
    srank = (int )Xrank[i];
    if (board[i] == 1) {
      (pawns[1][pawn_file]) ++;
      if (srank < white_back_pawn[pawn_file]) {
        white_back_pawn[pawn_file] = srank;
      }
    } else
    if (board[i] == 2) {
      (pawns[0][pawn_file]) ++;
      if (srank > black_back_pawn[pawn_file]) {
        black_back_pawn[pawn_file] = srank;
      }
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  j = 1;
  a = 1;
  while (a <= piece_count) {
    i = pieces[j];
    if (! i) {
      goto __Cont___0;
    } else {
      a ++;
    }
    pawn_file = (int )(Xfile[i] + 1);
    srank = (int )Xrank[i];
    switch (board[i]) {
    case 1: 
    score += scentral[i];
    tmp___1 = s_pawn_mobility(i);
    score += tmp___1;
    tmp___2 = black_saccers(i);
    score -= tmp___2;
    wp ++;
    isolated = 0;
    backwards = 0;
    if (white_back_pawn[pawn_file + 1] > srank) {
      if (white_back_pawn[pawn_file - 1] > srank) {
        score -= 8;
        backwards = 1;
        if (! pawns[1][pawn_file + 1]) {
          if (! pawns[1][pawn_file - 1]) {
            score -= 12;
            isolated = 1;
          }
        }
      }
    }
    if (! pawns[0][pawn_file]) {
      if (backwards) {
        score -= 5;
      }
      if (isolated) {
        score -= 8;
      }
    }
    if (pawns[1][pawn_file] > 1) {
      score -= 15 * (pawns[1][pawn_file] - 1);
    }
    if (! pawns[0][pawn_file]) {
      if (srank >= black_back_pawn[pawn_file - 1]) {
        if (srank >= black_back_pawn[pawn_file + 1]) {
          score += 30 + 3 * (int )(Xrank[i] - 2);
          if (Xfile[i] == 1) {
            score += 4 + 2 * (int )(Xrank[i] - 2);
          } else
          if (Xfile[i] == 8) {
            score += 4 + 2 * (int )(Xrank[i] - 2);
          }
          if (! isolated) {
            score += 6;
          }
        }
      }
    }
    if (! pawns[1][pawn_file - 1]) {
      score -= 20;
    }
    break;
    case 2: 
    score -= scentral[i];
    tmp___3 = s_pawn_mobility(i);
    score -= tmp___3;
    tmp___4 = white_saccers(i);
    score += tmp___4;
    isolated = 0;
    backwards = 0;
    bp ++;
    if (black_back_pawn[pawn_file + 1] < srank) {
      if (black_back_pawn[pawn_file - 1] < srank) {
        score += 8;
        backwards = 1;
        if (! pawns[0][pawn_file + 1]) {
          if (! pawns[0][pawn_file - 1]) {
            score += 12;
            isolated = 1;
          }
        }
      }
    }
    if (! pawns[1][pawn_file]) {
      if (backwards) {
        score += 5;
      }
      if (isolated) {
        score += 8;
      }
    }
    if (pawns[0][pawn_file] > 1) {
      score += 15 * (pawns[0][pawn_file] - 1);
    }
    if (! pawns[1][pawn_file]) {
      if (srank <= white_back_pawn[pawn_file - 1]) {
        if (srank <= white_back_pawn[pawn_file + 1]) {
          score -= 30 + 3 * (7 - (int )Xrank[i]);
          if (Xfile[i] == 1) {
            score -= 4 + 2 * (7 - (int )Xrank[i]);
          } else
          if (Xfile[i] == 8) {
            score -= 4 + 2 * (7 - (int )Xrank[i]);
          }
          if (! isolated) {
            score -= 6;
          }
        }
      }
    }
    if (! pawns[0][pawn_file - 1]) {
      score += 20;
    }
    break;
    case 7: 
    score += scentral[i];
    tmp___5 = s_rook_mobility(i);
    score += tmp___5;
    wr ++;
    break;
    case 8: 
    score -= scentral[i];
    tmp___6 = s_rook_mobility(i);
    score -= tmp___6;
    br ++;
    break;
    case 11: 
    score += scentral[i];
    tmp___7 = s_bishop_mobility(i);
    score += tmp___7;
    if (wb) {
      if (sqcolor[i] != (int const   )wbc) {
        wb = 99;
      }
    }
    wb ++;
    wbc = (int )sqcolor[i];
    break;
    case 12: 
    score -= scentral[i];
    tmp___8 = s_bishop_mobility(i);
    score -= tmp___8;
    if (bb) {
      if (sqcolor[i] != (int const   )bbc) {
        bb = 99;
      }
    }
    bb ++;
    bbc = (int )sqcolor[i];
    break;
    case 3: 
    score += scentral[i];
    tmp___9 = s_knight_mobility(i);
    score += tmp___9;
    wn ++;
    break;
    case 4: 
    score -= scentral[i];
    tmp___10 = s_knight_mobility(i);
    score -= tmp___10;
    bn ++;
    break;
    case 9: 
    score += scentral[i];
    tmp___11 = s_rook_mobility(i);
    score += tmp___11;
    tmp___12 = s_bishop_mobility(i);
    score += tmp___12;
    break;
    case 10: 
    score -= scentral[i];
    tmp___13 = s_rook_mobility(i);
    score -= tmp___13;
    tmp___14 = s_bishop_mobility(i);
    score -= tmp___14;
    break;
    case 5: 
    score += scentral[i] >> 1;
    tmp___15 = s_king_mobility(i);
    score += tmp___15;
    wk ++;
    break;
    case 6: 
    score -= scentral[i] >> 1;
    tmp___16 = s_king_mobility(i);
    score -= tmp___16;
    bk ++;
    break;
    }
    __Cont___0: /* CIL Label */ 
    j ++;
  }
  if (wb < 99) {
    if (bb < 99) {
      if (wbc != bbc) {
        if (piece_count < 32) {
          score = (int )((float )score * (float )((double )((float )piece_count) / 32.0));
        }
      }
    }
  }
  storeECache(score);
  if (white_to_move == 1) {
    return (score);
  } else {
    return (- score);
  }
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-r5slqplO.i","-O3")
extern __darwin_ct_rune_t __tolower(__darwin_ct_rune_t  ) ;
__inline static int tolower(int _c ) 
{ 
  __darwin_ct_rune_t tmp ;

  {
  tmp = __tolower(_c);
  return (tmp);
}
}
extern void (*signal(int  , void (*)(int  ) ))(int  ) ;
extern void setbuf(FILE * , char * ) ;
extern int strcmp(char const   * , char const   * ) ;
void init_game(void) ;
xbool is_move(char *str ) ;
void start_up(void) ;
void toggle_bool(xbool *var ) ;
xbool verify_coord(char *input , move_s *move ) ;
void initialize_zobrist(void) ;
void PutPiece(int color , char piece , char pfile , int prank ) ;
void reset_board(void) ;
void free_hash(void) ;
char divider[50] ;
int board[144]  ;
int moved[144]  ;
int ep_square  ;
int white_to_move  ;
int wking_loc  ;
int bking_loc  ;
int white_castled  ;
int black_castled  ;
int result  ;
int ply  ;
int pv_length[300]  ;
int squares[144]  ;
int num_pieces  ;
int i_depth  ;
int comp_color  ;
int fifty  ;
int piece_count  ;
int nodes  ;
int raw_nodes  ;
int qnodes  ;
int killer_scores[300]  ;
int killer_scores2[300]  ;
int killer_scores3[300]  ;
int moves_to_tc  ;
int min_per_game  ;
int sec_per_game  ;
int inc  ;
int time_left  ;
int opp_time  ;
int time_cushion  ;
int time_for_move  ;
int cur_score  ;
unsigned int history_h[144][144]  ;
xbool captures  ;
xbool searching_pv  ;
xbool post  ;
xbool time_exit  ;
xbool time_failure  ;
int xb_mode  ;
int maxdepth  ;
move_s pv[300][300]  ;
move_s killer1[300]  ;
move_s killer2[300]  ;
move_s killer3[300]  ;
move_x path_x[300]  ;
move_s path[300]  ;
rtime_t start_time  ;
int pieces[62]  ;
int is_promoted[62]  ;
int book_ply  ;
int use_book  ;
char opening_history[256]  ;
unsigned int bookidx  ;
unsigned int NTries  ;
unsigned int NCuts  ;
unsigned int TExt  ;
xbool is_pondering  ;
unsigned int PVS  ;
unsigned int FULL  ;
unsigned int PVSF  ;
unsigned int ext_check  ;
int Variant  ;
int Giveaway  ;
xbool is_analyzing  ;
char my_partner[256]  ;
xbool have_partner  ;
xbool must_sit  ;
xbool go_fast  ;
int fixed_time  ;
int phase  ;
int root_to_move  ;
int my_rating  ;
int opp_rating  ;
int move_number  ;
unsigned int hash_history[600]  ;
char setcode[30]  ;
char divider[50]  = 
  {      (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'\000'};
move_s dummy  =    {0, 0, 0, 0, 0, 0};
xbool allow_pondering  ;
int main__(int argc , char **argv ) 
{ 
  char input[256] ;
  char *p ;
  char output[256] ;
  char readbuff[256] ;
  move_s move ;
  move_s comp_move ;
  int depth ;
  xbool force_mode ;
  xbool show_board ;
  move_s game_history[600] ;
  move_x game_history_x[600] ;
  int is_edit_mode ;
  int edit_color ;
  int pingnum ;
  int braindeadinterface ;
  int automode ;
  rtime_t xstart_time ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  xbool tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  xbool tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  rtime_t tmp___20 ;
  int tmp___21 ;
  unsigned long tmp___22 ;
  unsigned long tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  unsigned long tmp___26 ;
  unsigned long tmp___27 ;
  unsigned long tmp___28 ;
  unsigned long tmp___29 ;
  unsigned long tmp___30 ;
  unsigned long tmp___31 ;
  unsigned long tmp___32 ;
  unsigned long tmp___33 ;
  unsigned long tmp___34 ;
  unsigned long tmp___35 ;
  unsigned long tmp___36 ;
  unsigned long tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  unsigned long tmp___44 ;
  unsigned long tmp___45 ;
  long tmp___46 ;
  unsigned long tmp___47 ;
  unsigned long tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  xbool tmp___102 ;

  {
  depth = 4;
  read_rcfile();
  initialize_zobrist();
  Variant = 2;
  tmp___0 = __builtin_object_size((void *)(material), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(material), 0);
    __builtin___memcpy_chk((void *)(material), (void const   *)(std_material), sizeof(std_material),
                           tmp);
  } else {
    __inline_memcpy_chk((void *)(material), (void const   *)(std_material), sizeof(std_material));
  }
  init_game();
  initialize_hash();
  clear_tt();
  reset_ecache();
  ECacheProbes = 0U;
  ECacheHits = 0U;
  TTProbes = 0U;
  TTStores = 0U;
  TTHits = 0U;
  bookidx = 0U;
  total_moves = 0U;
  ply = 0;
  braindeadinterface = 0;
  moves_to_tc = 40;
  min_per_game = 5;
  time_left = 30000;
  opp_rating = 2000;
  my_rating = opp_rating;
  maxdepth = 40;
  maxposdiff = 200;
  must_go = 1;
  tradefreely = 1;
  automode = 0;
  xb_mode = 0;
  force_mode = (xbool )0;
  comp_color = 0;
  edit_color = 0;
  show_board = (xbool )1;
  is_pondering = (xbool )0;
  allow_pondering = (xbool )1;
  is_analyzing = (xbool )0;
  is_edit_mode = 0;
  have_partner = (xbool )0;
  must_sit = (xbool )0;
  go_fast = (xbool )0;
  fixed_time = 0;
  phase = 0;
  root_to_move = 0;
  kibitzed = (xbool )0;
  move_number = 0;
  tmp___2 = __builtin_object_size((void *)(game_history), 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)(game_history), 0);
    __builtin___memset_chk((void *)(game_history), 0, sizeof(game_history), tmp___1);
  } else {
    __inline_memset_chk((void *)(game_history), 0, sizeof(game_history));
  }
  tmp___4 = __builtin_object_size((void *)(game_history_x), 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)(game_history_x), 0);
    __builtin___memset_chk((void *)(game_history_x), 0, sizeof(game_history_x), tmp___3);
  } else {
    __inline_memset_chk((void *)(game_history_x), 0, sizeof(game_history_x));
  }
  hash_history[move_number] = hash;
  setbuf(__stdoutp, (char *)((void *)0));
  setbuf(__stdinp, (char *)((void *)0));
  start_up();
  if (argc == 2) {
    printf("SPEC Workload\n");
    run_autotest(*(argv + 1));
  }
  while (1) {
    if (! is_edit_mode) {
      if (comp_color == white_to_move) {
        goto _L___10;
      } else
      if (automode) {
        _L___10: /* CIL Label */ 
        if (! force_mode) {
          if (! must_sit) {
            if (! result) {
              is_pondering = (xbool )0;
              comp_move = think();
              ply = 0;
              if (! must_sit) {
                goto _L___9;
              } else
              if (must_go != 0) {
                _L___9: /* CIL Label */ 
                if (Variant == 4) {
                  goto _L___8;
                } else
                if (Variant == 3) {
                  _L___8: /* CIL Label */ 
                  if (result != 2) {
                    if (result != 3) {
                      goto _L___4;
                    } else {
                      goto _L___7;
                    }
                  } else {
                    goto _L___7;
                  }
                } else
                _L___7: /* CIL Label */ 
                if (Variant == 2) {
                  goto _L___6;
                } else
                if (Variant == 0) {
                  goto _L___6;
                } else
                if (Variant == 1) {
                  _L___6: /* CIL Label */ 
                  if (comp_color == 1) {
                    if (result != 2) {
                      goto _L___4;
                    } else {
                      goto _L___5;
                    }
                  } else
                  _L___5: /* CIL Label */ 
                  if (comp_color == 0) {
                    if (result != 3) {
                      _L___4: /* CIL Label */ 
                      if (result != 1) {
                        if (result != 4) {
                          if (result != 5) {
                            comp_to_coord(comp_move, output);
                            hash_history[move_number] = hash;
                            game_history[move_number] = comp_move;
                            make(& comp_move, 0);
                            tmp___5 = move_number;
                            move_number ++;
                            game_history_x[tmp___5] = path_x[0];
                            userealholdings = 0;
                            must_go --;
                            tmp___6 = is_draw();
                            if (tmp___6) {
                              result = 5;
                            } else
                            if (fifty > 100) {
                              result = 4;
                            }
                            root_to_move ^= 1;
                            reset_piece_square();
                            if (book_ply < 40) {
                              if (! book_ply) {
                                tmp___8 = __builtin_object_size((void *)(opening_history),
                                                                0);
                                if (tmp___8 != 0xffffffffffffffffUL) {
                                  tmp___7 = __builtin_object_size((void *)(opening_history),
                                                                  1);
                                  __builtin___strcpy_chk(opening_history, (char const   *)(output),
                                                         tmp___7);
                                } else {
                                  __inline_strcpy_chk(opening_history, (char const   *)(output));
                                }
                              } else {
                                tmp___10 = __builtin_object_size((void *)(opening_history),
                                                                 0);
                                if (tmp___10 != 0xffffffffffffffffUL) {
                                  tmp___9 = __builtin_object_size((void *)(opening_history),
                                                                  1);
                                  __builtin___strcat_chk(opening_history, (char const   *)(output),
                                                         tmp___9);
                                } else {
                                  __inline_strcat_chk(opening_history, (char const   *)(output));
                                }
                              }
                            }
                            book_ply ++;
                            printf("\nNodes: %i (%0.2f%% qnodes)\n", nodes, (double )((float )((double )((float )qnodes / (float )nodes) * 100.0)));
                            printf("ECacheProbes : %u   ECacheHits : %u   HitRate : %f%%\n",
                                   ECacheProbes, ECacheHits, (double )(((float )ECacheHits / ((float )ECacheProbes + (float )1)) * (float )100));
                            printf("TTStores : %u TTProbes : %u   TTHits : %u   HitRate : %f%%\n",
                                   TTStores, TTProbes, TTHits, (double )(((float )TTHits / ((float )TTProbes + (float )1)) * (float )100));
                            printf("NTries : %u  NCuts : %u  CutRate : %f%%  TExt: %u\n",
                                   NTries, NCuts, (double )(((float )NCuts * (float )100) / ((float )NTries + (float )1)),
                                   TExt);
                            printf("Check extensions: %u  Razor drops : %u  Razor Material : %u\n",
                                   ext_check, razor_drop, razor_material);
                            printf("Move ordering : %f%%\n", (double )(((float )FHF * (float )100) / (float )(FH + 1U)));
                            tmp___11 = eval(-1000000, 1000000);
                            printf("Material score: %d   Eval : %d  MaxPosDiff: %d  White hand: %d  Black hand : %d\n",
                                   Material, tmp___11, maxposdiff, white_hand_eval,
                                   black_hand_eval);
                            printf("Hash : %X  HoldHash : %X\n", hash, hold_hash);
                            if (! result) {
                              if (xb_mode) {
                                if (comp_move.from != dummy.from) {
                                  printf("move %s\n", output);
                                } else
                                if (comp_move.target != dummy.target) {
                                  printf("move %s\n", output);
                                }
                                if (Variant == 1) {
                                  CheckBadFlow((xbool )0);
                                }
                              } else
                              if (comp_move.from != dummy.from) {
                                printf("\n%s\n", output);
                              } else
                              if (comp_move.target != dummy.target) {
                                printf("\n%s\n", output);
                              }
                            } else {
                              if (xb_mode) {
                                if (comp_move.from != dummy.from) {
                                  printf("move %s\n", output);
                                } else
                                if (comp_move.target != dummy.target) {
                                  printf("move %s\n", output);
                                }
                              } else
                              if (comp_move.from != dummy.from) {
                                printf("\n%s\n", output);
                              } else
                              if (comp_move.target != dummy.target) {
                                printf("\n%s\n", output);
                              }
                              if (result == 2) {
                                printf("0-1 {Black Mates}\n");
                              } else
                              if (result == 3) {
                                printf("1-0 {White Mates}\n");
                              } else
                              if (result == 4) {
                                printf("1/2-1/2 {Fifty move rule}\n");
                              } else
                              if (result == 5) {
                                printf("1/2-1/2 {3 fold repetition}\n");
                              } else {
                                printf("1/2-1/2 {Draw}\n");
                              }
                              automode = 0;
                            }
                          } else {
                            goto _L___3;
                          }
                        } else {
                          goto _L___3;
                        }
                      } else {
                        goto _L___3;
                      }
                    } else {
                      goto _L___3;
                    }
                  } else {
                    goto _L___3;
                  }
                } else {
                  _L___3: /* CIL Label */ 
                  if (result == 2) {
                    printf("0-1 {Black Mates}\n");
                  } else
                  if (result == 3) {
                    printf("1-0 {White Mates}\n");
                  } else
                  if (result == 4) {
                    printf("1/2-1/2 {Fifty move rule}\n");
                  } else
                  if (result == 5) {
                    printf("1/2-1/2 {3 fold repetition}\n");
                  } else {
                    printf("1/2-1/2 {Draw}\n");
                  }
                  automode = 0;
                }
              }
            }
          }
        }
      }
    }
    if (! xb_mode) {
      if (show_board) {
        printf("\n");
        display_board(__stdoutp, 1 - comp_color);
      }
      if (! automode) {
        printf("Sjeng: ");
        rinput(input, 256, __stdinp);
      }
    } else {
      if (must_sit) {
        goto _L___11;
      } else
      if (allow_pondering) {
        if (! is_edit_mode) {
          if (! force_mode) {
            if (move_number != 0) {
              goto _L___11;
            } else {
              goto _L___14;
            }
          } else {
            goto _L___14;
          }
        } else {
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
      if (is_analyzing) {
        _L___11: /* CIL Label */ 
        if (! result) {
          if (! automode) {
            is_pondering = (xbool )1;
            think();
            is_pondering = (xbool )0;
            ply = 0;
          }
        }
      }
      if (! automode) {
        rinput(input, 256, __stdinp);
      }
    }
    if (! is_edit_mode) {
      tmp___102 = is_move(& input[0]);
      if (tmp___102) {
        tmp___17 = verify_coord(input, & move);
        if (tmp___17) {
          game_history[move_number] = move;
          hash_history[move_number] = hash;
          make(& move, 0);
          tmp___12 = move_number;
          move_number ++;
          game_history_x[tmp___12] = path_x[0];
          reset_piece_square();
          root_to_move ^= 1;
          if (book_ply < 40) {
            if (! book_ply) {
              tmp___14 = __builtin_object_size((void *)(opening_history), 0);
              if (tmp___14 != 0xffffffffffffffffUL) {
                tmp___13 = __builtin_object_size((void *)(opening_history), 1);
                __builtin___strcpy_chk(opening_history, (char const   *)(input), tmp___13);
              } else {
                __inline_strcpy_chk(opening_history, (char const   *)(input));
              }
            } else {
              tmp___16 = __builtin_object_size((void *)(opening_history), 0);
              if (tmp___16 != 0xffffffffffffffffUL) {
                tmp___15 = __builtin_object_size((void *)(opening_history), 1);
                __builtin___strcat_chk(opening_history, (char const   *)(input), tmp___15);
              } else {
                __inline_strcat_chk(opening_history, (char const   *)(input));
              }
            }
          }
          book_ply ++;
          if (show_board) {
            printf("\n");
            display_board(__stdoutp, 1 - comp_color);
          }
        } else {
          printf("Illegal move: %s\n", input);
        }
      } else {
        goto _L___21;
      }
    } else {
      _L___21: /* CIL Label */ 
      tmp___19 = strstr((char const   *)(input), "setboard");
      if (! tmp___19) {
        p = input;
        while (*p) {
          tmp___18 = tolower((int )*p);
          *p = (char )tmp___18;
          p ++;
        }
      }
      tmp___101 = strcmp((char const   *)(input), "quit");
      if (tmp___101) {
        tmp___100 = strcmp((char const   *)(input), "exit");
        if (tmp___100) {
          tmp___98 = strcmp((char const   *)(input), "diagram");
          if (tmp___98) {
            tmp___99 = strcmp((char const   *)(input), "d");
            if (tmp___99) {
              tmp___97 = strncmp((char const   *)(input), "perft", (size_t )5);
              if (tmp___97) {
                tmp___96 = strcmp((char const   *)(input), "new");
                if (tmp___96) {
                  tmp___95 = strcmp((char const   *)(input), "xboard");
                  if (tmp___95) {
                    tmp___94 = strcmp((char const   *)(input), "nodes");
                    if (tmp___94) {
                      tmp___93 = strcmp((char const   *)(input), "post");
                      if (tmp___93) {
                        tmp___92 = strcmp((char const   *)(input), "nopost");
                        if (tmp___92) {
                          tmp___91 = strcmp((char const   *)(input), "random");
                          if (tmp___91) {
                            tmp___90 = strcmp((char const   *)(input), "hard");
                            if (tmp___90) {
                              tmp___89 = strcmp((char const   *)(input), "easy");
                              if (tmp___89) {
                                tmp___88 = strcmp((char const   *)(input), "?");
                                if (tmp___88) {
                                  tmp___87 = strcmp((char const   *)(input), "white");
                                  if (tmp___87) {
                                    tmp___86 = strcmp((char const   *)(input), "black");
                                    if (tmp___86) {
                                      tmp___85 = strcmp((char const   *)(input), "force");
                                      if (tmp___85) {
                                        tmp___84 = strcmp((char const   *)(input),
                                                          "eval");
                                        if (tmp___84) {
                                          tmp___83 = strcmp((char const   *)(input),
                                                            "go");
                                          if (tmp___83) {
                                            tmp___82 = strncmp((char const   *)(input),
                                                               "time", (size_t )4);
                                            if (tmp___82) {
                                              tmp___81 = strncmp((char const   *)(input),
                                                                 "otim", (size_t )4);
                                              if (tmp___81) {
                                                tmp___80 = strncmp((char const   *)(input),
                                                                   "level", (size_t )5);
                                                if (tmp___80) {
                                                  tmp___79 = strncmp((char const   *)(input),
                                                                     "rating", (size_t )6);
                                                  if (tmp___79) {
                                                    tmp___78 = strncmp((char const   *)(input),
                                                                       "holding",
                                                                       (size_t )7);
                                                    if (tmp___78) {
                                                      tmp___77 = strncmp((char const   *)(input),
                                                                         "variant",
                                                                         (size_t )7);
                                                      if (tmp___77) {
                                                        tmp___76 = strncmp((char const   *)(input),
                                                                           "analyze",
                                                                           (size_t )7);
                                                        if (tmp___76) {
                                                          tmp___75 = strncmp((char const   *)(input),
                                                                             "undo",
                                                                             (size_t )4);
                                                          if (tmp___75) {
                                                            tmp___74 = strncmp((char const   *)(input),
                                                                               "remove",
                                                                               (size_t )5);
                                                            if (tmp___74) {
                                                              tmp___73 = strncmp((char const   *)(input),
                                                                                 "edit",
                                                                                 (size_t )4);
                                                              if (tmp___73) {
                                                                tmp___72 = strncmp((char const   *)(input),
                                                                                   ".",
                                                                                   (size_t )1);
                                                                if (tmp___72) {
                                                                  _L___20: /* CIL Label */ 
                                                                  if (is_edit_mode) {
                                                                    tmp___71 = strncmp((char const   *)(input),
                                                                                       "c",
                                                                                       (size_t )1);
                                                                    if (tmp___71) {
                                                                      goto _L___19;
                                                                    } else
                                                                    if (edit_color == 0) {
                                                                      edit_color = 1;
                                                                    } else {
                                                                      edit_color = 0;
                                                                    }
                                                                  } else
                                                                  _L___19: /* CIL Label */ 
                                                                  if (is_edit_mode) {
                                                                    tmp___70 = strncmp((char const   *)(input),
                                                                                       "#",
                                                                                       (size_t )1);
                                                                    if (tmp___70) {
                                                                      goto _L___18;
                                                                    } else {
                                                                      reset_board();
                                                                      move_number = 0;
                                                                    }
                                                                  } else
                                                                  _L___18: /* CIL Label */ 
                                                                  if (is_edit_mode) {
                                                                    tmp___67 = isalpha((int )input[0]);
                                                                    if (tmp___67) {
                                                                      tmp___68 = isalpha((int )input[1]);
                                                                      if (tmp___68) {
                                                                        tmp___69 = isdigit((int )input[2]);
                                                                        if (tmp___69) {
                                                                          PutPiece(edit_color,
                                                                                   input[0],
                                                                                   input[1],
                                                                                   (int )input[2]);
                                                                        } else {
                                                                          goto _L___17;
                                                                        }
                                                                      } else {
                                                                        goto _L___17;
                                                                      }
                                                                    } else {
                                                                      goto _L___17;
                                                                    }
                                                                  } else {
                                                                    _L___17: /* CIL Label */ 
                                                                    tmp___66 = strncmp((char const   *)(input),
                                                                                       "partner",
                                                                                       (size_t )7);
                                                                    if (tmp___66) {
                                                                      tmp___65 = strncmp((char const   *)(input),
                                                                                         "$partner",
                                                                                         (size_t )8);
                                                                      if (tmp___65) {
                                                                        tmp___64 = strncmp((char const   *)(input),
                                                                                           "ptell",
                                                                                           (size_t )5);
                                                                        if (tmp___64) {
                                                                          tmp___63 = strncmp((char const   *)(input),
                                                                                             "test",
                                                                                             (size_t )4);
                                                                          if (tmp___63) {
                                                                            tmp___62 = strncmp((char const   *)(input),
                                                                                               "st",
                                                                                               (size_t )2);
                                                                            if (tmp___62) {
                                                                              tmp___61 = strncmp((char const   *)(input),
                                                                                                 "result",
                                                                                                 (size_t )6);
                                                                              if (tmp___61) {
                                                                                tmp___60 = strncmp((char const   *)(input),
                                                                                                   "prove",
                                                                                                   (size_t )5);
                                                                                if (tmp___60) {
                                                                                  tmp___59 = strncmp((char const   *)(input),
                                                                                                     "ping",
                                                                                                     (size_t )4);
                                                                                  if (tmp___59) {
                                                                                    tmp___58 = strncmp((char const   *)(input),
                                                                                                       "fritz",
                                                                                                       (size_t )5);
                                                                                    if (tmp___58) {
                                                                                      tmp___57 = strncmp((char const   *)(input),
                                                                                                         "reset",
                                                                                                         (size_t )5);
                                                                                      if (tmp___57) {
                                                                                        tmp___56 = strncmp((char const   *)(input),
                                                                                                           "setboard",
                                                                                                           (size_t )8);
                                                                                        if (tmp___56) {
                                                                                          tmp___55 = strncmp((char const   *)(input),
                                                                                                             ".",
                                                                                                             (size_t )1);
                                                                                          if (tmp___55) {
                                                                                            tmp___54 = strncmp((char const   *)(input),
                                                                                                               "sd",
                                                                                                               (size_t )2);
                                                                                            if (tmp___54) {
                                                                                              tmp___53 = strncmp((char const   *)(input),
                                                                                                                 "auto",
                                                                                                                 (size_t )4);
                                                                                              if (tmp___53) {
                                                                                                tmp___52 = strncmp((char const   *)(input),
                                                                                                                   "protover",
                                                                                                                   (size_t )8);
                                                                                                if (tmp___52) {
                                                                                                  tmp___51 = strncmp((char const   *)(input),
                                                                                                                     "accepted",
                                                                                                                     (size_t )8);
                                                                                                  if (tmp___51) {
                                                                                                    tmp___50 = strncmp((char const   *)(input),
                                                                                                                       "rejected",
                                                                                                                       (size_t )8);
                                                                                                    if (tmp___50) {
                                                                                                      tmp___49 = strcmp((char const   *)(input),
                                                                                                                        "help");
                                                                                                      if (tmp___49) {
                                                                                                        if (! xb_mode) {
                                                                                                          printf("Illegal move: %s\n",
                                                                                                                 input);
                                                                                                        }
                                                                                                      } else {
                                                                                                        printf("\n%s\n\n",
                                                                                                               divider);
                                                                                                        printf("diagram/d:       toggle diagram display\n");
                                                                                                        printf("exit/quit:       terminate Sjeng\n");
                                                                                                        printf("go:              make Sjeng play the side to move\n");
                                                                                                        printf("new:             start a new game\n");
                                                                                                        printf("level <x>:       the xboard style command to set time\n");
                                                                                                        printf("  <x> should be in the form: <a> <b> <c> where:\n");
                                                                                                        printf("  a -> moves to TC (0 if using an ICS style TC)\n");
                                                                                                        printf("  b -> minutes per game\n");
                                                                                                        printf("  c -> increment in seconds\n");
                                                                                                        printf("nodes:           outputs the number of nodes searched\n");
                                                                                                        printf("perft <x>:       compute raw nodes to depth x\n");
                                                                                                        printf("post:            toggles thinking output\n");
                                                                                                        printf("xboard:          put Sjeng into xboard mode\n");
                                                                                                        printf("test:            run an EPD testsuite\n");
                                                                                                        printf("speed:           test movegen and evaluation speed\n");
                                                                                                        printf("proof:           try to prove or disprove the current pos\n");
                                                                                                        printf("sd <x>:          limit thinking to depth x\n");
                                                                                                        printf("st <x>:          limit thinking to x centiseconds\n");
                                                                                                        printf("setboard <FEN>:  set board to a specified FEN string\n");
                                                                                                        printf("undo:            back up a half move\n");
                                                                                                        printf("remove:          back up a full move\n");
                                                                                                        printf("force:           disable computer moving\n");
                                                                                                        printf("auto:            computer plays both sides\n");
                                                                                                        printf("\n%s\n\n",
                                                                                                               divider);
                                                                                                        show_board = (xbool )0;
                                                                                                      }
                                                                                                    } else {
                                                                                                      printf("Interface does not support a required feature...expect trouble.\n");
                                                                                                    }
                                                                                                  }
                                                                                                } else {
                                                                                                  printf("feature ping=0 setboard=1 playother=0 san=0 usermove=0 time=1\n");
                                                                                                  printf("feature draw=0 sigint=0 sigterm=0 reuse=1 analyze=0\n");
                                                                                                  printf("feature myname=\"Sjeng SPEC 1.0\"\n");
                                                                                                  printf("feature variants=\"normal,bughouse,crazyhouse,suicide,giveaway,losers\"\n");
                                                                                                  printf("feature colors=1 ics=0 name=0 pause=0 done=1\n");
                                                                                                  xb_mode = 2;
                                                                                                }
                                                                                              } else {
                                                                                                automode = 1;
                                                                                                continue;
                                                                                              }
                                                                                            } else {
                                                                                              sscanf((char const   *)(input + 3),
                                                                                                     "%d",
                                                                                                     & maxdepth);
                                                                                              printf("New max depth set to: %d\n",
                                                                                                     maxdepth);
                                                                                              continue;
                                                                                            }
                                                                                          } else {
                                                                                            continue;
                                                                                          }
                                                                                        } else {
                                                                                          setup_epd_line(input + 9);
                                                                                        }
                                                                                      } else {
                                                                                        tmp___48 = __builtin_object_size((void *)(material),
                                                                                                                         0);
                                                                                        if (tmp___48 != 0xffffffffffffffffUL) {
                                                                                          tmp___47 = __builtin_object_size((void *)(material),
                                                                                                                           0);
                                                                                          __builtin___memcpy_chk((void *)(material),
                                                                                                                 (void const   *)(std_material),
                                                                                                                 sizeof(std_material),
                                                                                                                 tmp___47);
                                                                                        } else {
                                                                                          __inline_memcpy_chk((void *)(material),
                                                                                                              (void const   *)(std_material),
                                                                                                              sizeof(std_material));
                                                                                        }
                                                                                        Variant = 2;
                                                                                        init_game();
                                                                                        initialize_hash();
                                                                                        clear_tt();
                                                                                        reset_ecache();
                                                                                        force_mode = (xbool )0;
                                                                                        fixed_time = 0;
                                                                                        root_to_move = 0;
                                                                                        comp_color = 0;
                                                                                        move_number = 0;
                                                                                        bookidx = 0U;
                                                                                        opp_rating = 2000;
                                                                                        my_rating = opp_rating;
                                                                                      }
                                                                                    } else {
                                                                                      braindeadinterface = 1;
                                                                                    }
                                                                                  } else {
                                                                                    sscanf((char const   *)(input + 5),
                                                                                           "%d",
                                                                                           & pingnum);
                                                                                    printf("pong %d\n",
                                                                                           pingnum);
                                                                                  }
                                                                                } else {
                                                                                  printf("\nMax time to search (s): ");
                                                                                  start_time = rtime();
                                                                                  rinput(readbuff,
                                                                                         256,
                                                                                         __stdinp);
                                                                                  tmp___46 = atol((char const   *)(readbuff));
                                                                                  pn_time = (int )(tmp___46 * 100L);
                                                                                  printf("\n");
                                                                                  proofnumbersearch();
                                                                                }
                                                                              }
                                                                            } else {
                                                                              sscanf((char const   *)(input + 3),
                                                                                     "%d",
                                                                                     & fixed_time);
                                                                              fixed_time *= 100;
                                                                            }
                                                                          } else {
                                                                            run_epd_testsuite();
                                                                          }
                                                                        } else {
                                                                          HandlePtell(input);
                                                                        }
                                                                      } else {
                                                                        HandlePartner(input + 8);
                                                                      }
                                                                    } else {
                                                                      HandlePartner(input + 7);
                                                                    }
                                                                  }
                                                                } else
                                                                if (is_edit_mode) {
                                                                  is_edit_mode = 0;
                                                                  if (wking_loc == 30) {
                                                                    white_castled = 0;
                                                                  }
                                                                  if (bking_loc == 114) {
                                                                    black_castled = 0;
                                                                  }
                                                                  book_ply = 50;
                                                                  ep_square = 0;
                                                                  move_number = 0;
                                                                  tmp___45 = __builtin_object_size((void *)(opening_history),
                                                                                                   0);
                                                                  if (tmp___45 != 0xffffffffffffffffUL) {
                                                                    tmp___44 = __builtin_object_size((void *)(opening_history),
                                                                                                     0);
                                                                    __builtin___memset_chk((void *)(opening_history),
                                                                                           0,
                                                                                           sizeof(opening_history),
                                                                                           tmp___44);
                                                                  } else {
                                                                    __inline_memset_chk((void *)(opening_history),
                                                                                        0,
                                                                                        sizeof(opening_history));
                                                                  }
                                                                  clear_tt();
                                                                  initialize_hash();
                                                                  reset_piece_square();
                                                                } else {
                                                                  goto _L___20;
                                                                }
                                                              } else {
                                                                is_edit_mode = 1;
                                                                edit_color = 0;
                                                              }
                                                            } else
                                                            if (move_number > 1) {
                                                              move_number --;
                                                              path_x[0] = game_history_x[move_number];
                                                              unmake(& game_history[move_number],
                                                                     0);
                                                              reset_piece_square();
                                                              move_number --;
                                                              path_x[0] = game_history_x[move_number];
                                                              unmake(& game_history[move_number],
                                                                     0);
                                                              reset_piece_square();
                                                            }
                                                          } else {
                                                            printf("Move number : %d\n",
                                                                   move_number);
                                                            if (move_number > 0) {
                                                              move_number --;
                                                              path_x[0] = game_history_x[move_number];
                                                              unmake(& game_history[move_number],
                                                                     0);
                                                              reset_piece_square();
                                                              root_to_move ^= 1;
                                                            }
                                                          }
                                                        } else {
                                                          is_analyzing = (xbool )1;
                                                          is_pondering = (xbool )1;
                                                          think();
                                                          ply = 0;
                                                        }
                                                      } else {
                                                        tmp___43 = strstr((char const   *)(input),
                                                                          "normal");
                                                        if (tmp___43) {
                                                          Variant = 2;
                                                          tmp___27 = __builtin_object_size((void *)(material),
                                                                                           0);
                                                          if (tmp___27 != 0xffffffffffffffffUL) {
                                                            tmp___26 = __builtin_object_size((void *)(material),
                                                                                             0);
                                                            __builtin___memcpy_chk((void *)(material),
                                                                                   (void const   *)(std_material),
                                                                                   sizeof(std_material),
                                                                                   tmp___26);
                                                          } else {
                                                            __inline_memcpy_chk((void *)(material),
                                                                                (void const   *)(std_material),
                                                                                sizeof(std_material));
                                                          }
                                                        } else {
                                                          tmp___42 = strstr((char const   *)(input),
                                                                            "crazyhouse");
                                                          if (tmp___42) {
                                                            Variant = 0;
                                                            tmp___29 = __builtin_object_size((void *)(material),
                                                                                             0);
                                                            if (tmp___29 != 0xffffffffffffffffUL) {
                                                              tmp___28 = __builtin_object_size((void *)(material),
                                                                                               0);
                                                              __builtin___memcpy_chk((void *)(material),
                                                                                     (void const   *)(zh_material),
                                                                                     sizeof(zh_material),
                                                                                     tmp___28);
                                                            } else {
                                                              __inline_memcpy_chk((void *)(material),
                                                                                  (void const   *)(zh_material),
                                                                                  sizeof(zh_material));
                                                            }
                                                          } else {
                                                            tmp___41 = strstr((char const   *)(input),
                                                                              "bughouse");
                                                            if (tmp___41) {
                                                              Variant = 1;
                                                              tmp___31 = __builtin_object_size((void *)(material),
                                                                                               0);
                                                              if (tmp___31 != 0xffffffffffffffffUL) {
                                                                tmp___30 = __builtin_object_size((void *)(material),
                                                                                                 0);
                                                                __builtin___memcpy_chk((void *)(material),
                                                                                       (void const   *)(zh_material),
                                                                                       sizeof(zh_material),
                                                                                       tmp___30);
                                                              } else {
                                                                __inline_memcpy_chk((void *)(material),
                                                                                    (void const   *)(zh_material),
                                                                                    sizeof(zh_material));
                                                              }
                                                            } else {
                                                              tmp___40 = strstr((char const   *)(input),
                                                                                "suicide");
                                                              if (tmp___40) {
                                                                Variant = 3;
                                                                Giveaway = 0;
                                                                tmp___33 = __builtin_object_size((void *)(material),
                                                                                                 0);
                                                                if (tmp___33 != 0xffffffffffffffffUL) {
                                                                  tmp___32 = __builtin_object_size((void *)(material),
                                                                                                   0);
                                                                  __builtin___memcpy_chk((void *)(material),
                                                                                         (void const   *)(suicide_material),
                                                                                         sizeof(suicide_material),
                                                                                         tmp___32);
                                                                } else {
                                                                  __inline_memcpy_chk((void *)(material),
                                                                                      (void const   *)(suicide_material),
                                                                                      sizeof(suicide_material));
                                                                }
                                                              } else {
                                                                tmp___39 = strstr((char const   *)(input),
                                                                                  "giveaway");
                                                                if (tmp___39) {
                                                                  Variant = 3;
                                                                  Giveaway = 1;
                                                                  tmp___35 = __builtin_object_size((void *)(material),
                                                                                                   0);
                                                                  if (tmp___35 != 0xffffffffffffffffUL) {
                                                                    tmp___34 = __builtin_object_size((void *)(material),
                                                                                                     0);
                                                                    __builtin___memcpy_chk((void *)(material),
                                                                                           (void const   *)(suicide_material),
                                                                                           sizeof(suicide_material),
                                                                                           tmp___34);
                                                                  } else {
                                                                    __inline_memcpy_chk((void *)(material),
                                                                                        (void const   *)(suicide_material),
                                                                                        sizeof(suicide_material));
                                                                  }
                                                                } else {
                                                                  tmp___38 = strstr((char const   *)(input),
                                                                                    "losers");
                                                                  if (tmp___38) {
                                                                    Variant = 4;
                                                                    tmp___37 = __builtin_object_size((void *)(material),
                                                                                                     0);
                                                                    if (tmp___37 != 0xffffffffffffffffUL) {
                                                                      tmp___36 = __builtin_object_size((void *)(material),
                                                                                                       0);
                                                                      __builtin___memcpy_chk((void *)(material),
                                                                                             (void const   *)(losers_material),
                                                                                             sizeof(losers_material),
                                                                                             tmp___36);
                                                                    } else {
                                                                      __inline_memcpy_chk((void *)(material),
                                                                                          (void const   *)(losers_material),
                                                                                          sizeof(losers_material));
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                        initialize_hash();
                                                        clear_tt();
                                                        reset_ecache();
                                                      }
                                                    } else {
                                                      ProcessHoldings(input);
                                                    }
                                                  } else {
                                                    sscanf((char const   *)(input + 7),
                                                           "%i %i", & my_rating, & opp_rating);
                                                    if (my_rating == 0) {
                                                      my_rating = 2000;
                                                    }
                                                    if (opp_rating == 0) {
                                                      opp_rating = 2000;
                                                    }
                                                  }
                                                } else {
                                                  tmp___25 = strstr((char const   *)(input + 6),
                                                                    ":");
                                                  if (tmp___25) {
                                                    sscanf((char const   *)(input + 6),
                                                           "%i %i:%i %i", & moves_to_tc,
                                                           & min_per_game, & sec_per_game,
                                                           & inc);
                                                    time_left = min_per_game * 6000 + sec_per_game * 100;
                                                    opp_time = time_left;
                                                  } else {
                                                    sscanf((char const   *)(input + 6),
                                                           "%i %i %i", & moves_to_tc,
                                                           & min_per_game, & inc);
                                                    time_left = min_per_game * 6000;
                                                    opp_time = time_left;
                                                  }
                                                  fixed_time = 0;
                                                  time_cushion = 0;
                                                }
                                              } else {
                                                sscanf((char const   *)(input + 5),
                                                       "%i", & opp_time);
                                              }
                                            } else {
                                              sscanf((char const   *)(input + 5),
                                                     "%i", & time_left);
                                            }
                                          } else {
                                            comp_color = white_to_move;
                                            force_mode = (xbool )0;
                                          }
                                        } else {
                                          check_phase();
                                          tmp___24 = eval(-1000000, 1000000);
                                          printf("Eval: %d\n", tmp___24);
                                        }
                                      } else {
                                        force_mode = (xbool )1;
                                      }
                                    } else {
                                      white_to_move = 0;
                                      root_to_move = 1;
                                      comp_color = 1;
                                    }
                                  } else {
                                    white_to_move = 1;
                                    root_to_move = 0;
                                    comp_color = 0;
                                  }
                                } else {
                                  continue;
                                }
                              } else {
                                allow_pondering = (xbool )0;
                                continue;
                              }
                            } else {
                              allow_pondering = (xbool )1;
                              continue;
                            }
                          } else {
                            continue;
                          }
                        } else {
                          post = (xbool )0;
                        }
                      } else {
                        toggle_bool(& post);
                        if (xb_mode) {
                          post = (xbool )1;
                        }
                      }
                    } else {
                      printf("Number of nodes: %i (%0.2f%% qnodes)\n", nodes, (double )((float )((double )((float )qnodes / (float )nodes) * 100.0)));
                    }
                  } else {
                    xb_mode = 1;
                    toggle_bool(& show_board);
                    signal(2, (void (*)(int  ))1);
                    printf("\n");
                    printf("tellics set f5 1=1\n");
                    BegForPartner();
                  }
                } else {
                  if (xb_mode) {
                    printf("tellics set 1 Sjeng SPEC 1.0 (SPEC/%s)\n", setcode);
                  }
                  if (! is_analyzing) {
                    tmp___23 = __builtin_object_size((void *)(material), 0);
                    if (tmp___23 != 0xffffffffffffffffUL) {
                      tmp___22 = __builtin_object_size((void *)(material), 0);
                      __builtin___memcpy_chk((void *)(material), (void const   *)(std_material),
                                             sizeof(std_material), tmp___22);
                    } else {
                      __inline_memcpy_chk((void *)(material), (void const   *)(std_material),
                                          sizeof(std_material));
                    }
                    Variant = 2;
                    init_game();
                    initialize_hash();
                    if (! braindeadinterface) {
                      clear_tt();
                      reset_ecache();
                    }
                    force_mode = (xbool )0;
                    must_sit = (xbool )0;
                    go_fast = (xbool )0;
                    piecedead = (xbool )0;
                    partnerdead = (xbool )0;
                    kibitzed = (xbool )0;
                    fixed_time = 0;
                    root_to_move = 0;
                    comp_color = 0;
                    move_number = 0;
                    hash_history[move_number] = 0U;
                    bookidx = 0U;
                    opp_rating = 2000;
                    my_rating = opp_rating;
                    must_go = 0;
                    tradefreely = 1;
                    automode = 0;
                    CheckBadFlow((xbool )1);
                    ResetHandValue();
                  } else {
                    init_game();
                    move_number = 0;
                  }
                }
              } else {
                sscanf((char const   *)(input + 6), "%d", & depth);
                raw_nodes = 0;
                xstart_time = rtime();
                perft(depth);
                printf("Raw nodes for depth %d: %i\n", depth, raw_nodes);
                tmp___20 = rtime();
                tmp___21 = rdifftime(tmp___20, xstart_time);
                printf("Time : %.2f\n", (double )((float )tmp___21) / 100.);
              }
            } else {
              toggle_bool(& show_board);
            }
          } else {
            toggle_bool(& show_board);
          }
        } else
        if (is_analyzing) {
          is_analyzing = (xbool )0;
          is_pondering = (xbool )0;
          time_for_move = 0;
        } else {
          free_hash();
          free_ecache();
          exit(0);
        }
      } else {
        free_hash();
        free_ecache();
        exit(0);
      }
    }
  }
  return (0);
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-ZrwiTs3s.i","-O3")
void LearnStoreTT(int score , unsigned int nhash , unsigned int hhash , int tomove ,
                  int best , int depth ) ;
void clear_dp_tt(void) ;
void seedMT(unsigned int seed ) ;
unsigned int randomMT(void) ;
unsigned int zobrist[14][144]  ;
unsigned int hash  ;
unsigned int TTProbes  ;
unsigned int TTHits  ;
unsigned int TTStores  ;
TType *DP_TTable  ;
TType *AS_TTable  ;
QTType *QS_TTable  ;
void clear_tt(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  tmp___0 = __builtin_object_size((void *)DP_TTable, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)DP_TTable, 0);
    __builtin___memset_chk((void *)DP_TTable, 0, sizeof(TType ) * (unsigned long )TTSize,
                           tmp);
  } else {
    __inline_memset_chk((void *)DP_TTable, 0, sizeof(TType ) * (unsigned long )TTSize);
  }
  tmp___2 = __builtin_object_size((void *)AS_TTable, 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)AS_TTable, 0);
    __builtin___memset_chk((void *)AS_TTable, 0, sizeof(TType ) * (unsigned long )TTSize,
                           tmp___1);
  } else {
    __inline_memset_chk((void *)AS_TTable, 0, sizeof(TType ) * (unsigned long )TTSize);
  }
  tmp___4 = __builtin_object_size((void *)QS_TTable, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)QS_TTable, 0);
    __builtin___memset_chk((void *)QS_TTable, 0, sizeof(QTType ) * (unsigned long )TTSize,
                           tmp___3);
  } else {
    __inline_memset_chk((void *)QS_TTable, 0, sizeof(QTType ) * (unsigned long )TTSize);
  }
  return;
}
}
void clear_dp_tt(void) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  tmp___0 = __builtin_object_size((void *)DP_TTable, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)DP_TTable, 0);
    __builtin___memset_chk((void *)DP_TTable, 0, sizeof(TType ) * (unsigned long )TTSize,
                           tmp);
  } else {
    __inline_memset_chk((void *)DP_TTable, 0, sizeof(TType ) * (unsigned long )TTSize);
  }
  return;
}
}
void initialize_zobrist(void) 
{ 
  int p ;
  int q ;

  {
  seedMT(31657U);
  p = 0;
  while (p < 14) {
    q = 0;
    while (q < 144) {
      zobrist[p][q] = randomMT();
      q ++;
    }
    p ++;
  }
  hash = 3735928559U;
  hold_hash = 3237998080U;
  return;
}
}
void initialize_hash(void) 
{ 
  int p ;

  {
  hash = 3735928559U;
  p = 0;
  while (p < 144) {
    if (board[p] != 13) {
      if (board[p] != 0) {
        hash ^= zobrist[board[p]][p];
      }
    }
    p ++;
  }
  hold_hash = 3237998080U;
  return;
}
}
void QStoreTT(int score , int alpha , int beta , int best ) 
{ 
  unsigned int ttindex ;

  {
  TTStores ++;
  ttindex = hash % (unsigned int )TTSize;
  if (score <= alpha) {
    (QS_TTable + ttindex)->Type = (char)1;
  } else
  if (score >= beta) {
    (QS_TTable + ttindex)->Type = (char)2;
  } else {
    (QS_TTable + ttindex)->Type = (char)3;
  }
  (QS_TTable + ttindex)->HashKey = hash;
  (QS_TTable + ttindex)->Hold_hash = hold_hash;
  (QS_TTable + ttindex)->Bestmove = (unsigned short )best;
  (QS_TTable + ttindex)->Bound = score;
  if (white_to_move) {
    (QS_TTable + ttindex)->OnMove = (char)0;
  } else {
    (QS_TTable + ttindex)->OnMove = (char)1;
  }
  return;
}
}
void StoreTT(int score , int alpha , int beta , int best , int threat , int depth ) 
{ 
  unsigned int ttindex ;

  {
  TTStores ++;
  ttindex = hash % (unsigned int )TTSize;
  if ((int )(DP_TTable + ttindex)->Depth < depth) {
    goto _L___2;
  } else
  if ((int )(DP_TTable + ttindex)->Depth == depth) {
    if ((int )(DP_TTable + ttindex)->Type == 1) {
      if (score > alpha) {
        goto _L___2;
      } else {
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
    if (score > alpha) {
      if (score < beta) {
        _L___2: /* CIL Label */ 
        if (! is_pondering) {
          if (score <= alpha) {
            (DP_TTable + ttindex)->Type = (char)1;
            if (score < -999500) {
              score = -999500;
            }
          } else
          if (score >= beta) {
            (DP_TTable + ttindex)->Type = (char)2;
            if (score > 999500) {
              score = 999500;
            }
          } else {
            (DP_TTable + ttindex)->Type = (char)3;
            if (score > 999500) {
              score += ply;
            } else
            if (score < -999500) {
              score -= ply;
            }
          }
          (DP_TTable + ttindex)->HashKey = hash;
          (DP_TTable + ttindex)->Hold_hash = hold_hash;
          (DP_TTable + ttindex)->Depth = (char )depth;
          (DP_TTable + ttindex)->Bestmove = (unsigned short )best;
          (DP_TTable + ttindex)->Bound = score;
          if (white_to_move) {
            (DP_TTable + ttindex)->OnMove = (char)0;
          } else {
            (DP_TTable + ttindex)->OnMove = (char)1;
          }
          (DP_TTable + ttindex)->Threat = (char )threat;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    if (score <= alpha) {
      (AS_TTable + ttindex)->Type = (char)1;
      if (score < -999500) {
        score = -999500;
      }
    } else
    if (score >= beta) {
      (AS_TTable + ttindex)->Type = (char)2;
      if (score > 999500) {
        score = 999500;
      }
    } else {
      (AS_TTable + ttindex)->Type = (char)3;
      if (score > 999500) {
        score += ply;
      } else
      if (score < -999500) {
        score -= ply;
      }
    }
    (AS_TTable + ttindex)->HashKey = hash;
    (AS_TTable + ttindex)->Hold_hash = hold_hash;
    (AS_TTable + ttindex)->Depth = (char )depth;
    (AS_TTable + ttindex)->Bestmove = (unsigned short )best;
    (AS_TTable + ttindex)->Bound = score;
    if (white_to_move) {
      (AS_TTable + ttindex)->OnMove = (char)0;
    } else {
      (AS_TTable + ttindex)->OnMove = (char)1;
    }
    (AS_TTable + ttindex)->Threat = (char )threat;
  }
  return;
}
}
void LearnStoreTT(int score , unsigned int nhash , unsigned int hhash , int tomove ,
                  int best , int depth ) 
{ 
  unsigned int ttindex ;

  {
  ttindex = nhash % (unsigned int )TTSize;
  (AS_TTable + ttindex)->Depth = (char )depth;
  if (Variant != 3) {
    if (Variant != 4) {
      (AS_TTable + ttindex)->Type = (char)3;
    } else {
      (AS_TTable + ttindex)->Type = (char)1;
    }
  } else {
    (AS_TTable + ttindex)->Type = (char)1;
  }
  (AS_TTable + ttindex)->HashKey = nhash;
  (AS_TTable + ttindex)->Hold_hash = hhash;
  (AS_TTable + ttindex)->Bestmove = (unsigned short )best;
  (AS_TTable + ttindex)->Bound = score;
  (AS_TTable + ttindex)->OnMove = (char )tomove;
  (AS_TTable + ttindex)->Threat = (char)0;
  return;
}
}
int ProbeTT(int *score , int beta , int *best , int *threat , int *donull , int depth ) 
{ 
  unsigned int ttindex ;
  int tmp ;
  int tmp___0 ;

  {
  *donull = 1;
  TTProbes ++;
  ttindex = hash % (unsigned int )TTSize;
  if ((DP_TTable + ttindex)->HashKey == hash) {
    if ((DP_TTable + ttindex)->Hold_hash == hold_hash) {
      if (white_to_move) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
      if ((int )(DP_TTable + ttindex)->OnMove == (int )((char )tmp___0)) {
        TTHits ++;
        if ((int )(DP_TTable + ttindex)->Type == 1) {
          if ((depth - 2) - 1 <= (int )(DP_TTable + ttindex)->Depth) {
            if ((DP_TTable + ttindex)->Bound < beta) {
              *donull = 0;
            }
          }
        }
        if ((DP_TTable + ttindex)->Threat) {
          depth ++;
        }
        if ((int )(DP_TTable + ttindex)->Depth >= depth) {
          *score = (DP_TTable + ttindex)->Bound;
          if (*score > 999500) {
            *score -= ply;
          } else
          if (*score < -999500) {
            *score += ply;
          }
          *best = (int )(DP_TTable + ttindex)->Bestmove;
          *threat = (int )(DP_TTable + ttindex)->Threat;
          return ((int )(DP_TTable + ttindex)->Type);
        } else {
          *best = (int )(DP_TTable + ttindex)->Bestmove;
          *threat = (int )(DP_TTable + ttindex)->Threat;
          return (0);
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if ((AS_TTable + ttindex)->HashKey == hash) {
    if ((AS_TTable + ttindex)->Hold_hash == hold_hash) {
      if (white_to_move) {
        tmp = 0;
      } else {
        tmp = 1;
      }
      if ((int )(AS_TTable + ttindex)->OnMove == (int )((char )tmp)) {
        TTHits ++;
        if ((int )(AS_TTable + ttindex)->Type == 1) {
          if ((depth - 2) - 1 <= (int )(AS_TTable + ttindex)->Depth) {
            if ((AS_TTable + ttindex)->Bound < beta) {
              *donull = 0;
            }
          }
        }
        if ((AS_TTable + ttindex)->Threat) {
          depth ++;
        }
        if ((int )(AS_TTable + ttindex)->Depth >= depth) {
          *score = (AS_TTable + ttindex)->Bound;
          if (*score > 999500) {
            *score -= ply;
          } else
          if (*score < -999500) {
            *score += ply;
          }
          *best = (int )(AS_TTable + ttindex)->Bestmove;
          *threat = (int )(AS_TTable + ttindex)->Threat;
          return ((int )(AS_TTable + ttindex)->Type);
        } else {
          *best = (int )(AS_TTable + ttindex)->Bestmove;
          *threat = (int )(AS_TTable + ttindex)->Threat;
          return (0);
        }
      } else {
        return (4);
      }
    } else {
      return (4);
    }
  } else {
    return (4);
  }
}
}
int QProbeTT(int *score , int *best ) 
{ 
  unsigned int ttindex ;
  int tmp ;

  {
  TTProbes ++;
  ttindex = hash % (unsigned int )TTSize;
  if ((QS_TTable + ttindex)->HashKey == hash) {
    if ((QS_TTable + ttindex)->Hold_hash == hold_hash) {
      if (white_to_move) {
        tmp = 0;
      } else {
        tmp = 1;
      }
      if ((int )(QS_TTable + ttindex)->OnMove == (int )((char )tmp)) {
        TTHits ++;
        *score = (QS_TTable + ttindex)->Bound;
        *best = (int )(QS_TTable + ttindex)->Bestmove;
        return ((int )(QS_TTable + ttindex)->Type);
      } else {
        return (4);
      }
    } else {
      return (4);
    }
  } else {
    return (4);
  }
}
}
void alloc_hash(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = malloc(sizeof(TType ) * (unsigned long )TTSize);
  AS_TTable = (TType *)tmp;
  tmp___0 = malloc(sizeof(TType ) * (unsigned long )TTSize);
  DP_TTable = (TType *)tmp___0;
  tmp___1 = malloc(sizeof(QTType ) * (unsigned long )TTSize);
  QS_TTable = (QTType *)tmp___1;
  if ((unsigned long )AS_TTable == (unsigned long )((void *)0)) {
    printf("Out of memory allocating hashtables.\n");
    exit(1);
  } else
  if ((unsigned long )DP_TTable == (unsigned long )((void *)0)) {
    printf("Out of memory allocating hashtables.\n");
    exit(1);
  } else
  if ((unsigned long )QS_TTable == (unsigned long )((void *)0)) {
    printf("Out of memory allocating hashtables.\n");
    exit(1);
  }
  return;
}
}
void free_hash(void) 
{ 


  {
  free((void *)AS_TTable);
  free((void *)DP_TTable);
  free((void *)QS_TTable);
  return;
}
}
#pragma merger("0","/var/folders/t8/sjj4fszn7kn63wvbnwnnpcf40000gn/T/cil-_d080rgB.i","-O3")
extern FILE *__stderrp ;
extern int getc(FILE * ) ;
extern double difftime(time_t  , time_t  ) ;
void perft_debug(void) ;
void rdelay(int time_in_s ) ;
void check_piece_square(void) ;
void tree_debug(void) ;
static unsigned int state[625]  ;
static unsigned int *next  ;
int left  =    -1;
int allocate_time(void) 
{ 
  double allocated_time ;
  double move_speed ;

  {
  allocated_time = 0.0;
  move_speed = 20.0;
  if (! moves_to_tc) {
    if (min_per_game < 6) {
      if (! inc) {
        goto _L___1;
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
    if ((double )time_left < ((double )(min_per_game * 6000 + sec_per_game * 100) * 4.0) / 5.0) {
      _L___1: /* CIL Label */ 
      if ((double )(opp_time - time_left) > (double )opp_time / 5.0) {
        if (xb_mode) {
          move_speed = 40.0;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if ((double )(opp_time - time_left) > (double )opp_time / 10.0) {
        if (xb_mode) {
          move_speed = 30.0;
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if ((double )(opp_time - time_left) > (double )opp_time / 20.0) {
        if (xb_mode) {
          move_speed = 25.0;
        }
      }
    }
    if (Variant != 3) {
      if (Variant != 4) {
        if ((double )(time_left - opp_time) > (double )time_left / 5.0) {
          if (xb_mode) {
            move_speed -= (double )10;
          } else {
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
        if ((double )(time_left - opp_time) > (double )time_left / 10.0) {
          if (xb_mode) {
            move_speed -= (double )5;
          }
        }
      } else {
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
    if (Variant == 3) {
      move_speed -= (double )10;
    } else
    if (Variant == 4) {
      move_speed -= (double )5;
    }
    allocated_time = (double )time_left / move_speed;
    if (inc) {
      if (((double )time_left - allocated_time) - (double )inc > (double )500) {
        allocated_time += (double )inc;
      } else
      if (((double )time_left - allocated_time) - ((double )inc * 2.0) / 3.0 > (double )100) {
        allocated_time += ((double )inc * 2.0) / 3.0;
      }
    }
  } else {
    allocated_time = ((double )((float )min_per_game) * 6000. + (double )((float )sec_per_game) * 100.) / (double )((float )moves_to_tc) - 100.;
    if (time_cushion) {
      allocated_time += ((double )time_cushion * 2.1) / 3.0;
      time_cushion -= (int )(((double )time_cushion * 2.1) / 3.0);
    }
  }
  if (Variant == 1) {
    allocated_time *= 1. / 4.;
    if (opp_time > time_left) {
      allocated_time *= 1. / 2.;
    } else
    if (opp_time < 1500) {
      allocated_time *= 1. / 2.;
    }
  }
  return ((int )allocated_time);
}
}
void comp_to_san(move_s move , char *str ) 
{ 
  move_s moves[512] ;
  move_s evade_moves[512] ;
  int type_to_char[14] ;
  int i ;
  int num_moves ;
  int evasions ;
  int ambig ;
  int mate ;
  int f_rank ;
  int t_rank ;
  int converter ;
  char f_file ;
  char t_file ;
  int ic ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  xbool tmp___6 ;
  xbool tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  unsigned long tmp___15 ;
  xbool tmp___16 ;
  xbool tmp___17 ;
  unsigned long tmp___18 ;
  unsigned long tmp___19 ;
  unsigned long tmp___20 ;
  unsigned long tmp___21 ;
  xbool tmp___22 ;

  {
  type_to_char[0] = 'F';
  type_to_char[1] = 'P';
  type_to_char[2] = 'P';
  type_to_char[3] = 'N';
  type_to_char[4] = 'N';
  type_to_char[5] = 'K';
  type_to_char[6] = 'K';
  type_to_char[7] = 'R';
  type_to_char[8] = 'R';
  type_to_char[9] = 'Q';
  type_to_char[10] = 'Q';
  type_to_char[11] = 'B';
  type_to_char[12] = 'B';
  type_to_char[13] = 'E';
  f_rank = (int )Xrank[move.from];
  t_rank = (int )Xrank[move.target];
  converter = 'a';
  f_file = (char )((Xfile[move.from] + (int const   )converter) - 1);
  t_file = (char )((Xfile[move.target] + (int const   )converter) - 1);
  if (move.from == 0) {
    tmp = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp, "%c@%c%d", type_to_char[move.promoted], (int )t_file,
                            t_rank);
  } else
  if (board[move.from] == 1) {
    goto _L___0;
  } else
  if (board[move.from] == 2) {
    _L___0: /* CIL Label */ 
    if (board[move.target] == 13) {
      if (! move.ep) {
        if (! move.promoted) {
          tmp___0 = __builtin_object_size((void *)str, 1);
          __builtin___sprintf_chk(str, 0, tmp___0, "%c%d", (int )t_file, t_rank);
        } else {
          tmp___1 = __builtin_object_size((void *)str, 1);
          __builtin___sprintf_chk(str, 0, tmp___1, "%c%d=%c", (int )t_file, t_rank,
                                  type_to_char[move.promoted]);
        }
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (! move.promoted) {
      tmp___2 = __builtin_object_size((void *)str, 1);
      __builtin___sprintf_chk(str, 0, tmp___2, "%cx%c%d", (int )f_file, (int )t_file,
                              t_rank);
    } else {
      tmp___3 = __builtin_object_size((void *)str, 1);
      __builtin___sprintf_chk(str, 0, tmp___3, "%cx%c%d=%c", (int )f_file, (int )t_file,
                              t_rank, type_to_char[move.promoted]);
    }
  } else
  if (move.castled != 0) {
    if (move.castled == 1) {
      tmp___4 = __builtin_object_size((void *)str, 1);
      __builtin___sprintf_chk(str, 0, tmp___4, "O-O");
    } else
    if (move.castled == 3) {
      tmp___4 = __builtin_object_size((void *)str, 1);
      __builtin___sprintf_chk(str, 0, tmp___4, "O-O");
    } else {
      tmp___5 = __builtin_object_size((void *)str, 1);
      __builtin___sprintf_chk(str, 0, tmp___5, "O-O-O");
    }
  } else {
    ambig = -1;
    num_moves = 0;
    gen(& moves[0]);
    num_moves = numb_moves;
    tmp___6 = in_check();
    ic = (int )tmp___6;
    i = 0;
    while (i < num_moves) {
      if (moves[i].target == move.target) {
        if (board[moves[i].from] == board[move.from]) {
          if (moves[i].from != move.from) {
            make(& moves[0], i);
            tmp___7 = check_legal(& moves[0], i, ic);
            if (tmp___7) {
              unmake(& moves[0], i);
              ambig = i;
              break;
            }
            unmake(& moves[0], i);
          }
        }
      }
      i ++;
    }
    if (ambig != -1) {
      if (board[move.target] == 13) {
        if (Xfile[moves[ambig].from] != Xfile[move.from]) {
          tmp___8 = __builtin_object_size((void *)str, 1);
          __builtin___sprintf_chk(str, 0, tmp___8, "%c%c%c%d", type_to_char[board[move.from]],
                                  (int )f_file, (int )t_file, t_rank);
        } else {
          tmp___9 = __builtin_object_size((void *)str, 1);
          __builtin___sprintf_chk(str, 0, tmp___9, "%c%d%c%d", type_to_char[board[move.from]],
                                  f_rank, (int )t_file, t_rank);
        }
      } else
      if (Xfile[moves[ambig].from] != Xfile[move.from]) {
        tmp___10 = __builtin_object_size((void *)str, 1);
        __builtin___sprintf_chk(str, 0, tmp___10, "%c%cx%c%d", type_to_char[board[move.from]],
                                (int )f_file, (int )t_file, t_rank);
      } else {
        tmp___11 = __builtin_object_size((void *)str, 1);
        __builtin___sprintf_chk(str, 0, tmp___11, "%c%dx%c%d", type_to_char[board[move.from]],
                                f_rank, (int )t_file, t_rank);
      }
    } else
    if (board[move.target] == 13) {
      tmp___12 = __builtin_object_size((void *)str, 1);
      __builtin___sprintf_chk(str, 0, tmp___12, "%c%c%d", type_to_char[board[move.from]],
                              (int )t_file, t_rank);
    } else {
      tmp___13 = __builtin_object_size((void *)str, 1);
      __builtin___sprintf_chk(str, 0, tmp___13, "%cx%c%d", type_to_char[board[move.from]],
                              (int )t_file, t_rank);
    }
  }
  make(& move, 0);
  tmp___16 = check_legal(& move, 0, 1);
  if (! tmp___16) {
    tmp___15 = __builtin_object_size((void *)str, 0);
    if (tmp___15 != 0xffffffffffffffffUL) {
      tmp___14 = __builtin_object_size((void *)str, 1);
      __builtin___strcpy_chk(str, "illg", tmp___14);
    } else {
      __inline_strcpy_chk(str, "illg");
    }
    unmake(& move, 0);
    return;
  }
  tmp___22 = in_check();
  if (tmp___22) {
    mate = 1;
    evasions = 0;
    gen(& evade_moves[0]);
    evasions = numb_moves;
    i = 0;
    while (i < evasions) {
      make(& evade_moves[0], i);
      tmp___17 = check_legal(& evade_moves[0], i, 1);
      if (tmp___17) {
        mate = 0;
        unmake(& evade_moves[0], i);
        break;
      }
      unmake(& evade_moves[0], i);
      i ++;
    }
    if (mate == 1) {
      tmp___19 = __builtin_object_size((void *)str, 0);
      if (tmp___19 != 0xffffffffffffffffUL) {
        tmp___18 = __builtin_object_size((void *)str, 1);
        __builtin___strcat_chk(str, "#", tmp___18);
      } else {
        __inline_strcat_chk(str, "#");
      }
    } else {
      tmp___21 = __builtin_object_size((void *)str, 0);
      if (tmp___21 != 0xffffffffffffffffUL) {
        tmp___20 = __builtin_object_size((void *)str, 1);
        __builtin___strcat_chk(str, "+", tmp___20);
      } else {
        __inline_strcat_chk(str, "+");
      }
    }
  }
  unmake(& move, 0);
  return;
}
}
void comp_to_coord(move_s move , char *str ) 
{ 
  int prom ;
  int from ;
  int target ;
  int f_rank ;
  int t_rank ;
  int converter ;
  char f_file ;
  char t_file ;
  int type_to_char[14] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;

  {
  type_to_char[0] = 'F';
  type_to_char[1] = 'P';
  type_to_char[2] = 'p';
  type_to_char[3] = 'N';
  type_to_char[4] = 'n';
  type_to_char[5] = 'K';
  type_to_char[6] = 'k';
  type_to_char[7] = 'R';
  type_to_char[8] = 'r';
  type_to_char[9] = 'Q';
  type_to_char[10] = 'q';
  type_to_char[11] = 'B';
  type_to_char[12] = 'b';
  type_to_char[13] = 'E';
  prom = move.promoted;
  from = move.from;
  target = move.target;
  f_rank = (int )Xrank[from];
  t_rank = (int )Xrank[target];
  converter = 'a';
  f_file = (char )((Xfile[from] + (int const   )converter) - 1);
  t_file = (char )((Xfile[target] + (int const   )converter) - 1);
  if (from == 0) {
    tmp = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp, "%c@%c%d", type_to_char[prom], (int )t_file,
                            t_rank);
  } else
  if (! prom) {
    tmp___0 = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp___0, "%c%d%c%d", (int )f_file, f_rank, (int )t_file,
                            t_rank);
  } else
  if (prom == 3) {
    tmp___1 = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp___1, "%c%d%c%dn", (int )f_file, f_rank, (int )t_file,
                            t_rank);
  } else
  if (prom == 4) {
    tmp___1 = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp___1, "%c%d%c%dn", (int )f_file, f_rank, (int )t_file,
                            t_rank);
  } else
  if (prom == 7) {
    tmp___2 = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp___2, "%c%d%c%dr", (int )f_file, f_rank, (int )t_file,
                            t_rank);
  } else
  if (prom == 8) {
    tmp___2 = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp___2, "%c%d%c%dr", (int )f_file, f_rank, (int )t_file,
                            t_rank);
  } else
  if (prom == 11) {
    tmp___3 = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp___3, "%c%d%c%db", (int )f_file, f_rank, (int )t_file,
                            t_rank);
  } else
  if (prom == 12) {
    tmp___3 = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp___3, "%c%d%c%db", (int )f_file, f_rank, (int )t_file,
                            t_rank);
  } else
  if (prom == 5) {
    tmp___4 = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp___4, "%c%d%c%dk", (int )f_file, f_rank, (int )t_file,
                            t_rank);
  } else
  if (prom == 6) {
    tmp___4 = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp___4, "%c%d%c%dk", (int )f_file, f_rank, (int )t_file,
                            t_rank);
  } else {
    tmp___5 = __builtin_object_size((void *)str, 1);
    __builtin___sprintf_chk(str, 0, tmp___5, "%c%d%c%dq", (int )f_file, f_rank, (int )t_file,
                            t_rank);
  }
  return;
}
}
void display_board(FILE *stream , int color ) 
{ 
  char const   *line_sep ;
  char const   *piece_rep[14] ;
  int a ;
  int b ;
  int c ;

  {
  line_sep = "+----+----+----+----+----+----+----+----+";
  piece_rep[0] = "!!";
  piece_rep[1] = " P";
  piece_rep[2] = "*P";
  piece_rep[3] = " N";
  piece_rep[4] = "*N";
  piece_rep[5] = " K";
  piece_rep[6] = "*K";
  piece_rep[7] = " R";
  piece_rep[8] = "*R";
  piece_rep[9] = " Q";
  piece_rep[10] = "*Q";
  piece_rep[11] = " B";
  piece_rep[12] = "*B";
  piece_rep[13] = "  ";
  if (color % 2) {
    fprintf(stream, "  %s\n", line_sep);
    a = 1;
    while (a <= 8) {
      fprintf(stream, "%d |", 9 - a);
      b = 0;
      while (b <= 11) {
        c = (120 - a * 12) + b;
        if (board[c] != 0) {
          fprintf(stream, " %s |", piece_rep[board[c]]);
        }
        b ++;
      }
      fprintf(stream, "\n  %s\n", line_sep);
      a ++;
    }
    fprintf(stream, "\n     a    b    c    d    e    f    g    h\n\n");
  } else {
    fprintf(stream, "  %s\n", line_sep);
    a = 1;
    while (a <= 8) {
      fprintf(stream, "%d |", a);
      b = 0;
      while (b <= 11) {
        c = (24 + a * 12) - b;
        if (board[c] != 0) {
          fprintf(stream, " %s |", piece_rep[board[c]]);
        }
        b ++;
      }
      fprintf(stream, "\n  %s\n", line_sep);
      a ++;
    }
    fprintf(stream, "\n     h    g    f    e    d    c    b    a\n\n");
  }
  return;
}
}
void init_game(void) 
{ 
  int init_board[144] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;

  {
  init_board[0] = 0;
  init_board[1] = 0;
  init_board[2] = 0;
  init_board[3] = 0;
  init_board[4] = 0;
  init_board[5] = 0;
  init_board[6] = 0;
  init_board[7] = 0;
  init_board[8] = 0;
  init_board[9] = 0;
  init_board[10] = 0;
  init_board[11] = 0;
  init_board[12] = 0;
  init_board[13] = 0;
  init_board[14] = 0;
  init_board[15] = 0;
  init_board[16] = 0;
  init_board[17] = 0;
  init_board[18] = 0;
  init_board[19] = 0;
  init_board[20] = 0;
  init_board[21] = 0;
  init_board[22] = 0;
  init_board[23] = 0;
  init_board[24] = 0;
  init_board[25] = 0;
  init_board[26] = 7;
  init_board[27] = 3;
  init_board[28] = 11;
  init_board[29] = 9;
  init_board[30] = 5;
  init_board[31] = 11;
  init_board[32] = 3;
  init_board[33] = 7;
  init_board[34] = 0;
  init_board[35] = 0;
  init_board[36] = 0;
  init_board[37] = 0;
  init_board[38] = 1;
  init_board[39] = 1;
  init_board[40] = 1;
  init_board[41] = 1;
  init_board[42] = 1;
  init_board[43] = 1;
  init_board[44] = 1;
  init_board[45] = 1;
  init_board[46] = 0;
  init_board[47] = 0;
  init_board[48] = 0;
  init_board[49] = 0;
  init_board[50] = 13;
  init_board[51] = 13;
  init_board[52] = 13;
  init_board[53] = 13;
  init_board[54] = 13;
  init_board[55] = 13;
  init_board[56] = 13;
  init_board[57] = 13;
  init_board[58] = 0;
  init_board[59] = 0;
  init_board[60] = 0;
  init_board[61] = 0;
  init_board[62] = 13;
  init_board[63] = 13;
  init_board[64] = 13;
  init_board[65] = 13;
  init_board[66] = 13;
  init_board[67] = 13;
  init_board[68] = 13;
  init_board[69] = 13;
  init_board[70] = 0;
  init_board[71] = 0;
  init_board[72] = 0;
  init_board[73] = 0;
  init_board[74] = 13;
  init_board[75] = 13;
  init_board[76] = 13;
  init_board[77] = 13;
  init_board[78] = 13;
  init_board[79] = 13;
  init_board[80] = 13;
  init_board[81] = 13;
  init_board[82] = 0;
  init_board[83] = 0;
  init_board[84] = 0;
  init_board[85] = 0;
  init_board[86] = 13;
  init_board[87] = 13;
  init_board[88] = 13;
  init_board[89] = 13;
  init_board[90] = 13;
  init_board[91] = 13;
  init_board[92] = 13;
  init_board[93] = 13;
  init_board[94] = 0;
  init_board[95] = 0;
  init_board[96] = 0;
  init_board[97] = 0;
  init_board[98] = 2;
  init_board[99] = 2;
  init_board[100] = 2;
  init_board[101] = 2;
  init_board[102] = 2;
  init_board[103] = 2;
  init_board[104] = 2;
  init_board[105] = 2;
  init_board[106] = 0;
  init_board[107] = 0;
  init_board[108] = 0;
  init_board[109] = 0;
  init_board[110] = 8;
  init_board[111] = 4;
  init_board[112] = 12;
  init_board[113] = 10;
  init_board[114] = 6;
  init_board[115] = 12;
  init_board[116] = 4;
  init_board[117] = 8;
  init_board[118] = 0;
  init_board[119] = 0;
  init_board[120] = 0;
  init_board[121] = 0;
  init_board[122] = 0;
  init_board[123] = 0;
  init_board[124] = 0;
  init_board[125] = 0;
  init_board[126] = 0;
  init_board[127] = 0;
  init_board[128] = 0;
  init_board[129] = 0;
  init_board[130] = 0;
  init_board[131] = 0;
  init_board[132] = 0;
  init_board[133] = 0;
  init_board[134] = 0;
  init_board[135] = 0;
  init_board[136] = 0;
  init_board[137] = 0;
  init_board[138] = 0;
  init_board[139] = 0;
  init_board[140] = 0;
  init_board[141] = 0;
  init_board[142] = 0;
  init_board[143] = 0;
  tmp___0 = __builtin_object_size((void *)(board), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(board), 0);
    __builtin___memcpy_chk((void *)(board), (void const   *)(init_board), sizeof(init_board),
                           tmp);
  } else {
    __inline_memcpy_chk((void *)(board), (void const   *)(init_board), sizeof(init_board));
  }
  tmp___2 = __builtin_object_size((void *)(moved), 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)(moved), 0);
    __builtin___memset_chk((void *)(moved), 0, sizeof(moved), tmp___1);
  } else {
    __inline_memset_chk((void *)(moved), 0, sizeof(moved));
  }
  white_to_move = 1;
  ep_square = 0;
  wking_loc = 30;
  bking_loc = 114;
  white_castled = 0;
  black_castled = 0;
  result = 0;
  captures = (xbool )0;
  piece_count = 32;
  Material = 0;
  tmp___4 = __builtin_object_size((void *)(is_promoted), 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)(is_promoted), 0);
    __builtin___memset_chk((void *)(is_promoted), 0, sizeof(is_promoted), tmp___3);
  } else {
    __inline_memset_chk((void *)(is_promoted), 0, sizeof(is_promoted));
  }
  tmp___6 = __builtin_object_size((void *)(holding), 0);
  if (tmp___6 != 0xffffffffffffffffUL) {
    tmp___5 = __builtin_object_size((void *)(holding), 0);
    __builtin___memset_chk((void *)(holding), 0, sizeof(holding), tmp___5);
  } else {
    __inline_memset_chk((void *)(holding), 0, sizeof(holding));
  }
  white_hand_eval = 0;
  black_hand_eval = 0;
  reset_piece_square();
  bookidx = 0U;
  book_ply = 0;
  fifty = 0;
  ply = 0;
  phase = 0;
  return;
}
}
xbool is_move(char *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp___2 = isalpha((int )*(str + 0));
  if (tmp___2) {
    tmp___3 = isdigit((int )*(str + 1));
    if (tmp___3) {
      tmp___4 = isalpha((int )*(str + 2));
      if (tmp___4) {
        tmp___5 = isdigit((int )*(str + 3));
        if (tmp___5) {
          return ((xbool )1);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    tmp = isalpha((int )*(str + 0));
    if (tmp) {
      if ((int )*(str + 1) == 64) {
        tmp___0 = isalpha((int )*(str + 2));
        if (tmp___0) {
          tmp___1 = isdigit((int )*(str + 3));
          if (tmp___1) {
            return ((xbool )1);
          } else {
            return ((xbool )0);
          }
        } else {
          return ((xbool )0);
        }
      } else {
        return ((xbool )0);
      }
    } else {
      return ((xbool )0);
    }
  }
}
}
void perft_debug(void) 
{ 
  char input[256] ;
  char *p ;
  move_s move ;
  int depth ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  xbool tmp___5 ;
  xbool tmp___6 ;

  {
  init_game();
  while (1) {
    printf("\n\nPlease enter the desired depth for perft():\n");
    rinput(input, 256, __stdinp);
    depth = atoi((char const   *)(input));
    raw_nodes = 0;
    perft(depth);
    printf("\n\nRaw nodes for depth %d: %i\n\n", depth, raw_nodes);
    display_board(__stdoutp, 1);
    printf("\nPlease input a move/command:\n");
    rinput(input, 256, __stdinp);
    p = input;
    while (*p) {
      tmp = tolower((int )*p);
      *p = (char )tmp;
      p ++;
    }
    tmp___0 = strcmp((char const   *)(input), "exit");
    if (tmp___0) {
      tmp___1 = strcmp((char const   *)(input), "quit");
      if (! tmp___1) {
        exit(0);
      }
    } else {
      exit(0);
    }
    tmp___6 = verify_coord(input, & move);
    if (! tmp___6) {
      while (1) {
        printf("\nIllegal move/command!  Please input a new move/command:\n");
        rinput(input, 256, __stdinp);
        p = input;
        while (*p) {
          tmp___2 = tolower((int )*p);
          *p = (char )tmp___2;
          p ++;
        }
        tmp___3 = strcmp((char const   *)(input), "exit");
        if (tmp___3) {
          tmp___4 = strcmp((char const   *)(input), "quit");
          if (! tmp___4) {
            exit(0);
          }
        } else {
          exit(0);
        }
        tmp___5 = verify_coord(input, & move);
        if (tmp___5) {
          break;
        }
      }
    }
    make(& move, 0);
  }
}
}
void hash_extract_pv(int level , char *str ) 
{ 
  int xdummy ;
  int bm ;
  move_s moves[512] ;
  int num_moves ;
  char output[256] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  xbool tmp___5 ;
  int tmp___6 ;

  {
  level --;
  if (! level) {
    return;
  }
  tmp___6 = ProbeTT(& xdummy, 0, & bm, & xdummy, & xdummy, 0);
  if (tmp___6 != 4) {
    gen(& moves[0]);
    num_moves = numb_moves;
    if (bm >= 0) {
      if (bm < num_moves) {
        comp_to_san(moves[bm], output);
        make(& moves[0], bm);
        tmp___5 = check_legal(& moves[0], bm, 1);
        if (tmp___5) {
          tmp___0 = __builtin_object_size((void *)str, 0);
          if (tmp___0 != 0xffffffffffffffffUL) {
            tmp = __builtin_object_size((void *)str, 1);
            __builtin___strcat_chk(str, "<", tmp);
          } else {
            __inline_strcat_chk(str, "<");
          }
          tmp___2 = __builtin_object_size((void *)str, 0);
          if (tmp___2 != 0xffffffffffffffffUL) {
            tmp___1 = __builtin_object_size((void *)str, 1);
            __builtin___strcat_chk(str, (char const   *)(output), tmp___1);
          } else {
            __inline_strcat_chk(str, (char const   *)(output));
          }
          tmp___4 = __builtin_object_size((void *)str, 0);
          if (tmp___4 != 0xffffffffffffffffUL) {
            tmp___3 = __builtin_object_size((void *)str, 1);
            __builtin___strcat_chk(str, "> ", tmp___3);
          } else {
            __inline_strcat_chk(str, "> ");
          }
          hash_extract_pv(level, str);
        }
        unmake(& moves[0], bm);
      }
    }
  }
  return;
}
}
void stringize_pv(char *str ) 
{ 
  char output[256] ;
  int i ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  tmp___0 = __builtin_object_size((void *)str, 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)str, 0);
    __builtin___memset_chk((void *)str, 0, 256UL, tmp);
  } else {
    __inline_memset_chk((void *)str, 0, (size_t )256);
  }
  i = 1;
  while (i < pv_length[1]) {
    comp_to_san(pv[1][i], output);
    make(& pv[1][i], 0);
    tmp___2 = __builtin_object_size((void *)str, 0);
    if (tmp___2 != 0xffffffffffffffffUL) {
      tmp___1 = __builtin_object_size((void *)str, 1);
      __builtin___strcat_chk(str, (char const   *)(output), tmp___1);
    } else {
      __inline_strcat_chk(str, (char const   *)(output));
    }
    tmp___4 = __builtin_object_size((void *)str, 0);
    if (tmp___4 != 0xffffffffffffffffUL) {
      tmp___3 = __builtin_object_size((void *)str, 1);
      __builtin___strcat_chk(str, " ", tmp___3);
    } else {
      __inline_strcat_chk(str, " ");
    }
    i ++;
  }
  hash_extract_pv(7, str);
  i = pv_length[1] - 1;
  while (i > 0) {
    unmake(& pv[1][i], 0);
    i --;
  }
  return;
}
}
void post_thinking(int score ) 
{ 
  int i ;
  int remake ;
  int nps ;
  int elapsed ;
  char output[256] ;
  char hashpv[256] ;
  rtime_t tmp ;
  double dnps ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  remake = 0;
  tmp = rtime();
  elapsed = rdifftime(tmp, start_time);
  if (elapsed > 0) {
    dnps = (100.0 * (double )nodes) / (double )elapsed;
    nps = (int )dnps;
  } else {
    nps = nodes;
  }
  if (xb_mode) {
    printf("%2i %7i %5i %8i  ", i_depth, score, elapsed, nodes);
  } else {
    tmp___0 = abs(score % 100);
    tmp___1 = abs(score / 100);
    if (score < 0) {
      tmp___2 = '-';
    } else {
      tmp___2 = ' ';
    }
    printf("%2i %c%1i.%02i %9i ", i_depth, tmp___2, tmp___1, tmp___0, nodes);
  }
  if (pv[1][1].from != 0) {
    if (board[pv[1][1].from] == 13) {
      unmake(& pv[1][1], 0);
      remake = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (pv[1][1].from == 0) {
    if (board[pv[1][1].target] != 13) {
      unmake(& pv[1][1], 0);
      remake = 1;
    }
  }
  i = 1;
  while (i < pv_length[1]) {
    comp_to_san(pv[1][i], output);
    make(& pv[1][i], 0);
    printf("%s ", output);
    i ++;
  }
  tmp___4 = __builtin_object_size((void *)(hashpv), 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)(hashpv), 0);
    __builtin___memset_chk((void *)(hashpv), 0, sizeof(hashpv), tmp___3);
  } else {
    __inline_memset_chk((void *)(hashpv), 0, sizeof(hashpv));
  }
  hash_extract_pv(7, hashpv);
  printf("%s", hashpv);
  i = pv_length[1] - 1;
  while (i > 0) {
    unmake(& pv[1][i], 0);
    i --;
  }
  if (remake) {
    make(& pv[1][1], 0);
  }
  printf("\n");
  return;
}
}
void post_fail_thinking(int score , move_s *failmove ) 
{ 
  int elapsed ;
  int nps ;
  char output[256] ;
  rtime_t tmp ;
  double dnps ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = rtime();
  elapsed = rdifftime(tmp, start_time);
  if (elapsed > 0) {
    dnps = (100.0 * (double )nodes) / (double )elapsed;
    nps = (int )dnps;
  } else {
    nps = nodes;
  }
  if (xb_mode) {
    printf("%2i %7i %5i %8i  ", i_depth, score, elapsed, nodes);
  } else {
    tmp___0 = abs(score % 100);
    tmp___1 = abs(score / 100);
    if (score < 0) {
      tmp___2 = '-';
    } else {
      tmp___2 = ' ';
    }
    printf("%2i %c%1i.%02i %9i ", i_depth, tmp___2, tmp___1, tmp___0, nodes);
  }
  unmake(failmove, 0);
  comp_to_san(*failmove, output);
  make(failmove, 0);
  printf("%s !", output);
  printf("\n");
  return;
}
}
void post_fh_thinking(int score , move_s *failmove ) 
{ 
  int elapsed ;
  int nps ;
  char output[256] ;
  rtime_t tmp ;
  double dnps ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = rtime();
  elapsed = rdifftime(tmp, start_time);
  if (elapsed > 0) {
    dnps = (100.0 * (double )nodes) / (double )elapsed;
    nps = (int )dnps;
  } else {
    nps = nodes;
  }
  if (xb_mode) {
    printf("%2i %7i %5i %8i  ", i_depth, score, elapsed, nodes);
  } else {
    tmp___0 = abs(score % 100);
    tmp___1 = abs(score / 100);
    if (score < 0) {
      tmp___2 = '-';
    } else {
      tmp___2 = ' ';
    }
    printf("%2i %c%1i.%02i %9i ", i_depth, tmp___2, tmp___1, tmp___0, nodes);
  }
  unmake(failmove, 0);
  comp_to_san(*failmove, output);
  make(failmove, 0);
  printf("%s !!", output);
  printf("\n");
  return;
}
}
void post_fl_thinking(int score , move_s *failmove ) 
{ 
  int elapsed ;
  int nps ;
  char output[256] ;
  rtime_t tmp ;
  double dnps ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = rtime();
  elapsed = rdifftime(tmp, start_time);
  if (elapsed > 0) {
    dnps = (100.0 * (double )nodes) / (double )elapsed;
    nps = (int )dnps;
  } else {
    nps = nodes;
  }
  if (xb_mode) {
    printf("%2i %7i %5i %8i  ", i_depth, score, elapsed, nodes);
  } else {
    tmp___0 = abs(score % 100);
    tmp___1 = abs(score / 100);
    if (score < 0) {
      tmp___2 = '-';
    } else {
      tmp___2 = ' ';
    }
    printf("%2i %c%1i.%02i %9i ", i_depth, tmp___2, tmp___1, tmp___0, nodes);
  }
  unmake(failmove, 0);
  comp_to_san(*failmove, output);
  make(failmove, 0);
  printf("%s ??", output);
  printf("\n");
  return;
}
}
void post_stat_thinking(void) 
{ 
  int elapsed ;
  rtime_t tmp ;

  {
  tmp = rtime();
  elapsed = rdifftime(tmp, start_time);
  if (xb_mode == 1) {
    printf("stat01: %i %i %i %i %i\n", elapsed, nodes, i_depth, moveleft, movetotal);
  } else
  if (xb_mode == 2) {
    printf("stat01: %i %i %i %i %i %s\n", elapsed, nodes, i_depth, moveleft, movetotal,
           searching_move);
  }
  return;
}
}
void print_move(move_s *moves , int m , FILE *stream ) 
{ 
  char move[256] ;

  {
  comp_to_san(*(moves + m), move);
  fprintf(stream, "%s", move);
  return;
}
}
void rdelay(int time_in_s ) 
{ 
  rtime_t time1 ;
  rtime_t time2 ;
  int timer ;

  {
  timer = 0;
  time1 = rtime();
  while (timer / 100 < time_in_s) {
    time2 = rtime();
    timer = rdifftime(time2, time1);
  }
  return;
}
}
int rdifftime(rtime_t end , rtime_t start ) 
{ 
  double tmp ;

  {
  tmp = difftime(end, start);
  return (100 * (int )tmp);
}
}
void check_piece_square(void) 
{ 
  int i ;

  {
  i = 1;
  while (i <= piece_count) {
    if (squares[pieces[i]] != i) {
      if (pieces[i] != 0) {
        printf("Piece->square->piece inconsistency\n");
        display_board(__stdoutp, 0);
        *((int *)((void *)0)) = 0;
      }
    }
    if (board[pieces[i]] == 13) {
      if (pieces[i] != 0) {
        printf("Board/Piece->square inconsistency\n");
        display_board(__stdoutp, 0);
        *((int *)((void *)0)) = 0;
      }
    }
    if (pieces[i] == 0) {
      if (squares[pieces[i]] != 0) {
        printf("Zero-ed piece inconsistency\n");
        display_board(__stdoutp, 0);
        *((int *)((void *)0)) = 0;
      }
    }
    i ++;
  }
  i = 0;
  while (i < 144) {
    if (board[i] == 13) {
      goto _L;
    } else
    if (board[i] == 0) {
      _L: /* CIL Label */ 
      if (squares[i] != 0) {
        printf("Empty square has piece pointer\n");
        display_board(__stdoutp, 0);
        *((int *)((void *)0)) = 0;
      }
    }
    if (board[i] != 13) {
      if (board[i] != 0) {
        if (squares[i] == 0) {
          printf("Filled square %d has no piece pointer\n", i);
          display_board(__stdoutp, 0);
          *((int *)((void *)0)) = 0;
        }
      }
    }
    if (pieces[squares[i]] != i) {
      if (squares[i] != 0) {
        printf("Square->piece->square inconsistency\n");
        display_board(__stdoutp, 0);
        *((int *)((void *)0)) = 0;
      }
    }
    i ++;
  }
  return;
}
}
void reset_piece_square(void) 
{ 
  int i ;
  int promoted_board[144] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  tmp___0 = __builtin_object_size((void *)(promoted_board), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(promoted_board), 0);
    __builtin___memset_chk((void *)(promoted_board), 0, sizeof(promoted_board), tmp);
  } else {
    __inline_memset_chk((void *)(promoted_board), 0, sizeof(promoted_board));
  }
  i = 1;
  while (i <= piece_count) {
    if (is_promoted[i]) {
      promoted_board[pieces[i]] = 1;
    }
    i ++;
  }
  Material = 0;
  piece_count = 0;
  tmp___2 = __builtin_object_size((void *)(pieces), 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)(pieces), 0);
    __builtin___memset_chk((void *)(pieces), 0, sizeof(pieces), tmp___1);
  } else {
    __inline_memset_chk((void *)(pieces), 0, sizeof(pieces));
  }
  tmp___4 = __builtin_object_size((void *)(is_promoted), 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)(is_promoted), 0);
    __builtin___memset_chk((void *)(is_promoted), 0, sizeof(is_promoted), tmp___3);
  } else {
    __inline_memset_chk((void *)(is_promoted), 0, sizeof(is_promoted));
  }
  pieces[0] = 0;
  i = 26;
  while (i < 118) {
    if (board[i]) {
      if (board[i] < 13) {
        Material += material[board[i]];
        piece_count ++;
        pieces[piece_count] = i;
        squares[i] = piece_count;
        if (promoted_board[i]) {
          is_promoted[piece_count] = 1;
        }
      } else {
        squares[i] = 0;
      }
    } else {
      squares[i] = 0;
    }
    i ++;
  }
  return;
}
}
void rinput(char *str , int n , FILE *stream ) 
{ 
  int ch ;
  int i ;
  int tmp ;

  {
  i = 0;
  while (1) {
    ch = getc(stream);
    if (ch != 10) {
      if (! (ch != -1)) {
        break;
      }
    } else {
      break;
    }
    if (i < n - 1) {
      tmp = i;
      i ++;
      *(str + tmp) = (char )ch;
    }
  }
  *(str + i) = (char )'\000';
  return;
}
}
rtime_t rtime(void) 
{ 


  {
  return ((rtime_t )0);
}
}
void start_up(void) 
{ 


  {
  printf("\nSjeng version SPEC 1.0, Copyright (C) 2000-2005 Gian-Carlo Pascutto\n\n");
  return;
}
}
void toggle_bool(xbool *var ) 
{ 


  {
  if (*var) {
    *var = (xbool )0;
  } else {
    *var = (xbool )1;
  }
  return;
}
}
void tree_debug(void) 
{ 
  char input[256] ;
  FILE *stream ;
  int depth ;

  {
  init_game();
  printf("\nPlease enter the desired depth:\n");
  rinput(input, 256, __stdinp);
  depth = atoi((char const   *)(input));
  printf("\nDo you want tree () output?  (y/n)\n");
  rinput(input, 256, __stdinp);
  if ((int )input[0] == 121) {
    printf("\nPlease enter the name of the output file for tree ():\n");
    rinput(input, 256, __stdinp);
    stream = fopen((char const   *)(input), "w");
    if ((unsigned long )stream == (unsigned long )((void *)0)) {
      fprintf(__stderrp, "Couldn\'t open file %s\n", input);
    }
    printf("\nDo you want to output diagrams? (y/n)\n");
    rinput(input, 256, __stdinp);
    tree(depth, 0, stream, input);
  }
  raw_nodes = 0;
  perft(depth);
  printf("\n\n%s\nRaw nodes for depth %d: %i\n%s\n\n", divider, depth, raw_nodes,
         divider);
  return;
}
}
xbool verify_coord(char *input , move_s *move ) 
{ 
  move_s moves[512] ;
  int num_moves ;
  int i ;
  char comp_move[6] ;
  xbool legal ;
  xbool mate ;
  xbool tmp ;
  xbool tmp___0 ;
  int tmp___1 ;

  {
  legal = (xbool )0;
  if (Variant == 4) {
    captures = (xbool )1;
    num_moves = 0;
    gen(& moves[0]);
    num_moves = numb_moves;
    captures = (xbool )0;
    mate = (xbool )1;
    i = 0;
    while (i < num_moves) {
      make(& moves[0], i);
      tmp = check_legal(& moves[0], i, 1);
      if (tmp) {
        mate = (xbool )0;
        unmake(& moves[0], i);
        break;
      }
      unmake(& moves[0], i);
      i ++;
    }
    if ((unsigned int )mate == 1U) {
      captures = (xbool )0;
      num_moves = 0;
      gen(& moves[0]);
      num_moves = numb_moves;
    }
  } else {
    gen(& moves[0]);
    num_moves = numb_moves;
  }
  i = 0;
  while (i < num_moves) {
    comp_to_coord(moves[i], comp_move);
    tmp___1 = strcmp((char const   *)input, (char const   *)(comp_move));
    if (! tmp___1) {
      make(& moves[0], i);
      tmp___0 = check_legal(& moves[0], i, 1);
      if (tmp___0) {
        legal = (xbool )1;
        *move = moves[i];
      }
      unmake(& moves[0], i);
    }
    i ++;
  }
  return (legal);
}
}
int interrupt(void) 
{ 


  {
  return (0);
}
}
void PutPiece(int color , char piece , char pfile , int prank ) 
{ 
  int converterf ;
  int converterr ;
  int norm_file ;
  int norm_rank ;
  int norm_square ;

  {
  converterf = 'a';
  converterr = '1';
  norm_file = (int )pfile - converterf;
  norm_rank = prank - converterr;
  norm_square = (norm_rank * 12 + 26) + norm_file;
  if (color == 0) {
    switch ((int )piece) {
    case 112: 
    board[norm_square] = 1;
    break;
    case 110: 
    board[norm_square] = 3;
    break;
    case 98: 
    board[norm_square] = 11;
    break;
    case 114: 
    board[norm_square] = 7;
    break;
    case 113: 
    board[norm_square] = 9;
    break;
    case 107: 
    board[norm_square] = 5;
    break;
    case 120: 
    board[norm_square] = 13;
    break;
    }
  } else
  if (color == 1) {
    switch ((int )piece) {
    case 112: 
    board[norm_square] = 2;
    break;
    case 110: 
    board[norm_square] = 4;
    break;
    case 98: 
    board[norm_square] = 12;
    break;
    case 114: 
    board[norm_square] = 8;
    break;
    case 113: 
    board[norm_square] = 10;
    break;
    case 107: 
    board[norm_square] = 6;
    break;
    case 120: 
    board[norm_square] = 13;
    break;
    }
  }
  return;
}
}
void reset_board(void) 
{ 
  int i ;
  int init_board[144] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  init_board[0] = 0;
  init_board[1] = 0;
  init_board[2] = 0;
  init_board[3] = 0;
  init_board[4] = 0;
  init_board[5] = 0;
  init_board[6] = 0;
  init_board[7] = 0;
  init_board[8] = 0;
  init_board[9] = 0;
  init_board[10] = 0;
  init_board[11] = 0;
  init_board[12] = 0;
  init_board[13] = 0;
  init_board[14] = 0;
  init_board[15] = 0;
  init_board[16] = 0;
  init_board[17] = 0;
  init_board[18] = 0;
  init_board[19] = 0;
  init_board[20] = 0;
  init_board[21] = 0;
  init_board[22] = 0;
  init_board[23] = 0;
  init_board[24] = 0;
  init_board[25] = 0;
  init_board[26] = 13;
  init_board[27] = 13;
  init_board[28] = 13;
  init_board[29] = 13;
  init_board[30] = 13;
  init_board[31] = 13;
  init_board[32] = 13;
  init_board[33] = 13;
  init_board[34] = 0;
  init_board[35] = 0;
  init_board[36] = 0;
  init_board[37] = 0;
  init_board[38] = 13;
  init_board[39] = 13;
  init_board[40] = 13;
  init_board[41] = 13;
  init_board[42] = 13;
  init_board[43] = 13;
  init_board[44] = 13;
  init_board[45] = 13;
  init_board[46] = 0;
  init_board[47] = 0;
  init_board[48] = 0;
  init_board[49] = 0;
  init_board[50] = 13;
  init_board[51] = 13;
  init_board[52] = 13;
  init_board[53] = 13;
  init_board[54] = 13;
  init_board[55] = 13;
  init_board[56] = 13;
  init_board[57] = 13;
  init_board[58] = 0;
  init_board[59] = 0;
  init_board[60] = 0;
  init_board[61] = 0;
  init_board[62] = 13;
  init_board[63] = 13;
  init_board[64] = 13;
  init_board[65] = 13;
  init_board[66] = 13;
  init_board[67] = 13;
  init_board[68] = 13;
  init_board[69] = 13;
  init_board[70] = 0;
  init_board[71] = 0;
  init_board[72] = 0;
  init_board[73] = 0;
  init_board[74] = 13;
  init_board[75] = 13;
  init_board[76] = 13;
  init_board[77] = 13;
  init_board[78] = 13;
  init_board[79] = 13;
  init_board[80] = 13;
  init_board[81] = 13;
  init_board[82] = 0;
  init_board[83] = 0;
  init_board[84] = 0;
  init_board[85] = 0;
  init_board[86] = 13;
  init_board[87] = 13;
  init_board[88] = 13;
  init_board[89] = 13;
  init_board[90] = 13;
  init_board[91] = 13;
  init_board[92] = 13;
  init_board[93] = 13;
  init_board[94] = 0;
  init_board[95] = 0;
  init_board[96] = 0;
  init_board[97] = 0;
  init_board[98] = 13;
  init_board[99] = 13;
  init_board[100] = 13;
  init_board[101] = 13;
  init_board[102] = 13;
  init_board[103] = 13;
  init_board[104] = 13;
  init_board[105] = 13;
  init_board[106] = 0;
  init_board[107] = 0;
  init_board[108] = 0;
  init_board[109] = 0;
  init_board[110] = 13;
  init_board[111] = 13;
  init_board[112] = 13;
  init_board[113] = 13;
  init_board[114] = 13;
  init_board[115] = 13;
  init_board[116] = 13;
  init_board[117] = 13;
  init_board[118] = 0;
  init_board[119] = 0;
  init_board[120] = 0;
  init_board[121] = 0;
  init_board[122] = 0;
  init_board[123] = 0;
  init_board[124] = 0;
  init_board[125] = 0;
  init_board[126] = 0;
  init_board[127] = 0;
  init_board[128] = 0;
  init_board[129] = 0;
  init_board[130] = 0;
  init_board[131] = 0;
  init_board[132] = 0;
  init_board[133] = 0;
  init_board[134] = 0;
  init_board[135] = 0;
  init_board[136] = 0;
  init_board[137] = 0;
  init_board[138] = 0;
  init_board[139] = 0;
  init_board[140] = 0;
  init_board[141] = 0;
  init_board[142] = 0;
  init_board[143] = 0;
  tmp___0 = __builtin_object_size((void *)(board), 0);
  if (tmp___0 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)(board), 0);
    __builtin___memcpy_chk((void *)(board), (void const   *)(init_board), sizeof(init_board),
                           tmp);
  } else {
    __inline_memcpy_chk((void *)(board), (void const   *)(init_board), sizeof(init_board));
  }
  i = 0;
  while (i <= 143) {
    moved[i] = 0;
    i ++;
  }
  ep_square = 0;
  piece_count = 0;
  Material = 0;
  tmp___2 = __builtin_object_size((void *)(is_promoted), 0);
  if (tmp___2 != 0xffffffffffffffffUL) {
    tmp___1 = __builtin_object_size((void *)(is_promoted), 0);
    __builtin___memset_chk((void *)(is_promoted), 0, sizeof(is_promoted), tmp___1);
  } else {
    __inline_memset_chk((void *)(is_promoted), 0, sizeof(is_promoted));
  }
  tmp___4 = __builtin_object_size((void *)(holding), 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp___3 = __builtin_object_size((void *)(holding), 0);
    __builtin___memset_chk((void *)(holding), 0, sizeof(holding), tmp___3);
  } else {
    __inline_memset_chk((void *)(holding), 0, sizeof(holding));
  }
  white_hand_eval = 0;
  black_hand_eval = 0;
  bookidx = 0U;
  fifty = 0;
  reset_piece_square();
  return;
}
}
void seedMT(unsigned int seed ) 
{ 
  register unsigned int x ;
  register unsigned int *s ;
  register int j ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;

  {
  x = (seed | 1U) & 4294967295U;
  s = state;
  left = 0;
  tmp = s;
  s ++;
  *tmp = x;
  j = 624;
  while (1) {
    j --;
    if (! j) {
      break;
    }
    tmp___0 = s;
    s ++;
    x *= 69069U;
    *tmp___0 = x & 4294967295U;
  }
  return;
}
}
unsigned int reloadMT(void) 
{ 
  register unsigned int *p0 ;
  register unsigned int *p2 ;
  register unsigned int *pM ;
  register unsigned int s0 ;
  register unsigned int s1 ;
  register int j ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  unsigned int *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int *tmp___3 ;
  unsigned int *tmp___4 ;
  unsigned int *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
  p0 = state;
  p2 = state + 2;
  pM = state + 397;
  if (left < -1) {
    seedMT(4357U);
  }
  left = 623;
  next = state + 1;
  s0 = state[0];
  s1 = state[1];
  j = 228;
  while (1) {
    j --;
    if (! j) {
      break;
    }
    tmp___0 = p0;
    p0 ++;
    tmp___1 = pM;
    pM ++;
    if (s1 & 1U) {
      tmp___2 = 2567483615U;
    } else {
      tmp___2 = 0U;
    }
    *tmp___0 = (*tmp___1 ^ (((s0 & 2147483648U) | (s1 & 2147483647U)) >> 1)) ^ tmp___2;
    s0 = s1;
    tmp = p2;
    p2 ++;
    s1 = *tmp;
  }
  pM = state;
  j = 397;
  while (1) {
    j --;
    if (! j) {
      break;
    }
    tmp___4 = p0;
    p0 ++;
    tmp___5 = pM;
    pM ++;
    if (s1 & 1U) {
      tmp___6 = 2567483615U;
    } else {
      tmp___6 = 0U;
    }
    *tmp___4 = (*tmp___5 ^ (((s0 & 2147483648U) | (s1 & 2147483647U)) >> 1)) ^ tmp___6;
    s0 = s1;
    tmp___3 = p2;
    p2 ++;
    s1 = *tmp___3;
  }
  s1 = state[0];
  if (s1 & 1U) {
    tmp___7 = 2567483615U;
  } else {
    tmp___7 = 0U;
  }
  *p0 = (*pM ^ (((s0 & 2147483648U) | (s1 & 2147483647U)) >> 1)) ^ tmp___7;
  s1 ^= s1 >> 11;
  s1 ^= (s1 << 7) & 2636928640U;
  s1 ^= (s1 << 15) & 4022730752U;
  return (s1 ^ (s1 >> 18));
}
}
unsigned int randomMT(void) 
{ 
  unsigned int y ;
  unsigned int tmp ;
  unsigned int *tmp___0 ;

  {
  left --;
  if (left < 0) {
    tmp = reloadMT();
    return (tmp);
  }
  tmp___0 = next;
  next ++;
  y = *tmp___0;
  y ^= y >> 11;
  y ^= (y << 7) & 2636928640U;
  y ^= (y << 15) & 4022730752U;
  return (y ^ (y >> 18));
}
}

int main(){
  return main__();
}